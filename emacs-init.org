#+POSTID: 26
#+DATE: [2015-07-15 Wed 14:13]
#+SETUPFILE: /home/matt/src/org-html-themes/setup/theme-readtheorg.setup
#+CATEGORY: emacs
#+PROPERTY: header-args    :tangle yes

* A few global settings before packages are loaded
this is stuff pulled from the old ~appearance.el~ and perhaps other places as well; these are all genral settings that improve the UI for me a fair bit. 

#+begin_src emacs-lisp


#+end_src

#+RESULTS:

** ACTION Old "Better Defaults" settings
These are magnar's "better defaults" -- which I am mostly going to try to get rid of

*Edit <2018-11-27 Tue>:* turning subword mode off... 
#+begin_src emacs-lisp
;; enforce utf-8
;; from https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs
;; http://ergoemacs.org/emacs/emacs_encoding_decoding_faq.html
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
  ;; better menu names
  (use-package uniquify
    :defer 3
    :config
    (setq uniquify-buffer-name-style 'forward))


  ;; use hippie to search and find buffers
  ;; I actually really don't like this b/c it expands *everything* as an html tag if 
  ;; accidentally pressed.  removing
  ;; (global-set-key (kbd "M-/") 'hippie-expand)
  (defun mwp-base-settings ()
    "For now, just turn on a bunch of key bindings and basic settings.
       In the future, maybe turn this into a minor mode the way Kaushal does. "

    ;; Highlight matching parentheses when the point is on them.
    (show-paren-mode 1)
  ;;;; show line and column number in mode line
    (setq column-number-mode t)
  ;;;; display line number in left column
    (linum-mode -1)
    ;; Highlight matching parentheses when the point is on them.

    ;; hsow buffer name in window title
    (when window-system
      (setq frame-title-format '(buffer-file-name "%f" ("%b")))
      (tooltip-mode -1)
      (blink-cursor-mode -1))


    ;; this is still really nice to have though.  Keeping
    (global-set-key (kbd "C-x C-b") 'ibuffer)

    ;; use regexes in search --this works but also ocmplicates. consider changing
    (global-set-key (kbd "C-s") 'isearch-forward-regexp)
    (global-set-key (kbd "C-r") 'isearch-backward-regexp)
    (global-set-key (kbd "C-M-s") 'isearch-forward)
    (global-set-key (kbd "C-M-r") 'isearch-backward)

    (setq-default indent-tabs-mode nil)
    (setq x-select-enable-clipboard t
          x-select-enable-primary t
          ;; one-line fix for disappearing clipboard entries 
          ;; Often I copy something in Firefox and then go to emacs, but in between I kill some text. Then when I want to
          ;;paste/yank in the ff text, it's gone and I have to recopy.  This one-line setting fixes that:
          save-interprogram-paste-before-kill t
          apropos-do-all t
          ;; this next one sometimes fucks me up, consider changing
          mouse-yank-at-point t
          save-place-file (concat user-emacs-directory "places")
          ;; backup-directory-alist `(("." . ,(concat user-emacs-directory
          ;;                                          "backups")))
          )

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; this stuff is from magnar
    ;; Move files to trash when deleting

    (setq delete-by-moving-to-trash t)


    ;; Also auto refresh dired, but be quiet about it
    (setq global-auto-revert-non-file-buffers t)
    (setq auto-revert-verbose nil)
    ;; Real emacs knights don't use shift to mark things
    ;; this is bs, commenting out
    ;; (setq shift-select-mode nil)
    (setq org-support-shift-select t)

    ;; Answering just 'y' or 'n' will do
    (defalias 'yes-or-no-p 'y-or-n-p)
    ;; UTF-8 please
    (setq locale-coding-system 'utf-8-emacs) ; pretty
    (set-terminal-coding-system 'utf-8-emacs) ; pretty
    (set-keyboard-coding-system 'utf-8-emacs) ; pretty
    (set-selection-coding-system 'utf-8-emacs) ; please
    (prefer-coding-system 'utf-8-emacs) ; with sugar on top
    
    ;; I don't know what this means
    ;; Don't highlight matches with jump-char - it's distracting

    ;; (setq jump-char-lazy-highlight-face nil)

    ;; Lines should be 80 characters wide, not 72
    (setq fill-column 80)
    ;; Save minibuffer history
    (savehist-mode 1)
    (setq history-length 1400)

    ;; Undo/redo window configuration with C-c <left>/<right>
    ;; worth coming back to this & rationalizing window management
    ;; commented out for now
    ;; (winner-mode 1)

    ;; Never insert tabs
    (set-default 'indent-tabs-mode nil)

    ;; Show me empty lines after buffer end
    (set-default 'indicate-empty-lines t)

    ;; Show active region
    (transient-mark-mode 1)
    (make-variable-buffer-local 'transient-mark-mode)
    (put 'transient-mark-mode 'permanent-local t)
    (setq-default transient-mark-mode t)


    )

  (mwp-base-settings)

  ;; Auto refresh buffers
  (global-auto-revert-mode 1)

  ;; Transparently open compressed files
  (auto-compression-mode t)

  ;; Enable syntax highlighting for older Emacsen that have it off
  (global-font-lock-mode t)


  ;; Save a list of recent files visited. (open recent file with C-x f)
  (use-package recentf
    :config

    (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
    (recentf-mode 1)
    (global-set-key "\C-x\ \C-r" 'recentf-open-files)
    (setq recentf-max-saved-items 200) ;; just 20 is too recent
    )


  ;; Easily navigate sillycased words
  ;; (global-subword-mode 1)
  (defvar subword-mode nil)
  ;; Don't break lines for me, please
  (setq-default truncate-lines t)

  ;; Keep cursor away from edges when scrolling up/down
  ;; (require 'smooth-scrolling)

  ;; Allow recursive minibuffers
  (setq enable-recursive-minibuffers t)

  ;; Don't be so stingy on the memory, we have lots now. It's the distant future.
  (setq gc-cons-threshold 20000000)


  ;; Fontify org-mode code blocks
  (setq org-src-fontify-natively t)

  ;; Represent undo-history as an actual tree (visualize with C-x u)
  (setq undo-tree-mode-lighter "")
  (require 'undo-tree)
  (global-undo-tree-mode)

  ;; Sentences do not need double spaces to end. Period.
  (set-default 'sentence-end-double-space nil)


  ;; A saner ediff
  (setq ediff-diff-options "-w")
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Nic says eval-expression-print-level needs to be set to nil (turned off) so
  ;; that you can always see what's happening.
  (setq eval-expression-print-level nil)

  ;; When popping the mark, continue popping until the cursor actually moves
  ;; Also, if the last command was a copy - skip past all the expand-region cruft.
  ;; I don't understand al lthisstuff and it may becausing problems, worth figuring out.

  ;; new versions fromKaushal, maybe better:
      ;;;; Popping marks
  ;; http://endlessparentheses.com/faster-pop-to-mark-command.html
  ;; https://github.com/magnars/expand-region.el/issues/159#issuecomment-83538021
  (defun modi/multi-pop-to-mark (orig-fun &rest args)
    "When popping the mark, continue popping until the cursor actually moves.
      Try the repeated popping up to 10 times."
    (let ((p (point)))
      (dotimes (i 10)
        (when (= p (point))
          (apply orig-fun args)))))
  (advice-add 'pop-to-mark-command :around #'modi/multi-pop-to-mark)

  ;; Ensure that we can quickly pop the mark several times by typing
  ;; C-u C-SPC C-SPC, instead of having to type C-u C-SPC C-u C-SPC.
  (setq set-mark-command-repeat-pop t)
#+end_src

#+RESULTS:
: t

* A number of Miscellaneous packages
** iMenu

THisi s mostly a buffer listing but I think there are lots of other aspects to it.  

#+begin_src emacs-lisp :tangle no
(use-package imenu )
#+end_src
** Require the packages

I'm not sure why I have most of these.  I'm currently experimenting with commenting out some of them. 

Replacing with "use-package:
#+BEGIN_SRC emacs-lisp
  ;; (require) your ELPA packages, configure them as normal

  ;; C-= to expand selection by semantic unit
  ;; https://github.com/magnars/expand-region.el
  (use-package expand-region
    :commands er/expand-region)

  ;; replaced below with the fantastic iedit-mode, much more powerful.
  ;;(use-package highlight-symbol )

  ;; essential for all html exports
  (use-package htmlize
    :commands (htmlize-region htmlize-buffer htmlize-file htmlize-many-files htmlize-many-files-dired))


  ;; I don't actually use this much
  ;; and it appears ot cause errors, so squashing for now!
  ;; (use-package markdown-mode )
  ;; multiple cursors extras
  ;; not using right now
  ;; (use-package mc-extras )


  ;; this has become super important -- allows me to go back to any previous state of buffer
  (use-package undo-tree
    :commands undo-tree-visualize)


  ;; modern replacement for flymake
  ;; flycheck is dependent on external tools. Not set up properly yet
  ;; http://www.flycheck.org/manual/latest/Quickstart.html#Quickstart
  ;; This really needs its own lesson, it's fantastic!
  (use-package flycheck
    :hook
    (after-init . global-flycheck-mode))
  ;; (add-hook 'after-init-hook #'global-flycheck-mode)



#+END_SRC

#+RESULTS:
macs
* Non-package defuns & settings from my old site-lisp directory      :review:
In my older system I had a ~~/.emacs.d/site-lisp~ directory containing lots of code that I didn't understand. I've now brought all of that code into my main config file, and sorted through it at least a little bit. Some of it I am no longer tangling; much of ot was inherited from an old version of magnar's [[https://github.com/magnars/.emacs.d][elaborate and amazing init system]].
** buffer-defuns   *NOT TANGLED*                                    :review:
There is a ton of cool stuff here.  I don't use much of it right now but here is a bit of a sampling -- just ru nthis code real quick:  
#+begin_src emacs-lisp :results value raw :tangle no

  (defun mwp-docstring-to-list (f)
    (interactive)
    (let ((ds
           (save-window-excursion
             (with-temp-buffer
               (let ((buf   (find-file f)))
                 (get-defun-info buf))))
           )
          (result ""))
      (message "%s" ds)
      (dolist (d ds)
        (message "%s" d)
        (let ((template (format "- %s :: %s \n" (symbol-name (car d)) (nth 2 d))))
          (setq result (concat  template result))
           )
        )
      result))

  (mwp-docstring-to-list "~/.emacs.d/defuns/misc-defuns.el")

  (save-window-excursion
    (let ((buf   (find-file "~/.emacs.d/defuns/misc-defuns.el")))
      (get-defun-info buf)))

  (get-defun-info (find-file "~/.emacs.d/defuns/misc-defuns.el"))
#+end_src

#+RESULTS:
- mode-keymap :: nil 
- create-scratch-buffer :: create a new scratch buffer to work in. (could be *scratch* - *scratchX*) 
- split-window-right-and-move-there-dammit :: nil 
- toggle-window-split :: nil 
- rotate-windows :: Rotate your windows 
- untabify-buffer :: nil 
- indent-buffer :: nil 
- cleanup-buffer :: Perform a bunch of operations on the whitespace content of a buffer.
                    Including indent-buffer, which should not be called automatically on save. This is kinda neat, I don't use it though
- file-name-with-one-directory :: nil 
- recentf--file-cons :: nil 

I don't use omost of these but I do use some; tangling turned back, but maybe not ofr long
#+begin_src emacs-lisp :tangle no
(require 'imenu)

(defvar buffer-local-mode nil)
(make-variable-buffer-local 'buffer-local-mode)

(defun mode-keymap (mode-sym)
  (symbol-value (intern (concat (symbol-name mode-sym) "-map"))))

(defun* buffer-local-set-key (key action)
  (when buffer-local-mode
    (define-key (mode-keymap buffer-local-mode)
      key action)
    (return-from set-key-buffer-local))
  (let* ((mode-name-loc (gensym "-blm")))
    (eval `(define-minor-mode ,mode-name-loc nil nil nil (make-sparse-keymap)))
    (setq buffer-local-mode mode-name-loc)
    (funcall mode-name-loc 1)
    (define-key (mode-keymap mode-name-loc) key action)))

(defun create-scratch-buffer nil
  "create a new scratch buffer to work in. (could be *scratch* - *scratchX*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (emacs-lisp-mode)
    ))

(defun split-window-right-and-move-there-dammit ()
  (interactive)
  (split-window-right)
  (windmove-right))

(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))


(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))

(defun file-name-with-one-directory (file-name)
  (concat (cadr (reverse (split-string file-name "/"))) "/"
          (file-name-nondirectory file-name)))

(require 's)

(defvar user-home-directory (concat (expand-file-name "~") "/"))

`(defun shorter-file-name (file-name)
  (s-chop-prefix user-home-directory file-name))

(defun recentf--file-cons (file-name)
  (cons (shorter-file-name file-name) file-name))
#+end_src
** ACTION Better Yanking
THis is some great stuff form magnar's ~editing-defuns~ (which I no longer load). Read the code for more info.  However... it's quite possible that this overrides or conflicts with other packages related to killing and yanking, like [[https://github.com/leoliu/easy-kill][easy-kill]]

However, it needs to be updated to the new advice-add syntax, and is caousing some problems!

I'm monitoring this and I think the issue is that the advice was being added before dash was byte-compiled, leading to an inability to understand the dash syntax.  I've wrapped all of this in a ~use-package dash~ block and now we should be good I hope.  

CF [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Byte-Compiling.html][the docs on byte-compiling]] and also [[https://github.com/bbatsov/projectile/issues/788#issuecomment-118393174][magnar's response to questions about a similar issue]]. 


#+begin_src emacs-lisp
  ;; automatically indenting yanked text if in programming-modes
  (use-package dash
    :config 
    (defvar yank-indent-modes '(prog-mode
                                sgml-mode
                                js2-mode)
      "Modes in which to indent regions that are yanked (or yank-popped)")

    (defvar yank-advised-indent-threshold 1000
      "Threshold (# chars) over which indentation does not automatically occur.")

    (defun yank-advised-indent-function (beg end)
      "Do indentation, as long as the region isn't too large."
      (if (<= (- end beg) yank-advised-indent-threshold)
          (indent-region beg end nil)))

    (defadvice yank (after yank-indent activate)
      "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
      (if (and (not (ad-get-arg 0))
               (--any? (derived-mode-p it) yank-indent-modes))
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function (region-beginning) (region-end)))))

    (defadvice yank-pop (after yank-pop-indent activate)
      "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
      (if (and (not (ad-get-arg 0))
               (member major-mode yank-indent-modes))
          (let ((transient-mark-mode nil))
            (yank-advised-indent-function (region-beginning) (region-end)))))

    (defun yank-unindented ()
      (interactive)
      (yank 1)))

#+end_src

#+RESULTS:
: t

** Better Killing
Again, read the code, which is still from ~editing-defuns.el~
#+begin_src emacs-lisp
;; kill region if active, otherwise kill backward word

(defun kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word 1)))

(defun kill-to-beginning-of-line ()
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

;; copy region if active
;; otherwise copy to end of current line
;;   * with prefix, copy N whole lines

(defun copy-to-end-of-line ()
  (interactive)
  (kill-ring-save (point)
                  (line-end-position))
  (message "Copied to end of line"))

(defun copy-whole-lines (arg)
  "Copy lines (as many as prefix argument) in the kill ring"
  (interactive "p")
  (kill-ring-save (line-beginning-position)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(defun copy-line (arg)
  "Copy to end of line, or as many lines as prefix argument"
  (interactive "P")
  (if (null arg)
      (copy-to-end-of-line)
    (copy-whole-lines (prefix-numeric-value arg))))

(defun save-region-or-current-line (arg)
  (interactive "P")
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (copy-line arg)))

(defun kill-and-retry-line ()
  "Kill the entire current line and reposition point at indentation"
  (interactive)
  (back-to-indentation)
  (kill-line))
#+end_src
** ACTION editing defuns tangled but need to look at them!
I don't use many of these, so not tangling them.
#+begin_src emacs-lisp :results value raw :tangle no  :var source="~/.emacs.d/defuns/editing-defuns.el"
  (mwp-docstring-to-list source)
#+end_src

#+RESULTS:
- open-line-below :: nil 
- open-line-above :: nil 
- new-line-in-between :: nil 
- new-line-dwim :: nil 
- duplicate-current-line-or-region :: Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. 
- replace-region-by :: nil 
- duplicate-region :: Duplicates the region bounded by START and END NUM times.
If no START and END is provided, the current region-beginning and
region-end is used. 
- duplicate-current-line :: Duplicate the current line NUM times. 
- current-quotes-char :: nil 
- move-point-forward-out-of-string :: nil 
- move-point-backward-out-of-string :: nil 
- alternate-quotes-char :: nil 
- toggle-quotes :: nil 
- camelize-buffer :: nil 
- comment-kill-all :: nil 
- incs :: nil 
- change-number-at-point :: nil 
- subtract-number-at-point :: nil 
- replace-next-underscore-with-camel :: nil 
- snakeify-current-word :: nil 
- transpose-params :: Presumes that params are in the form (p, p, p) or {p, p, p} or [p, p, p] 
- move-forward-out-of-param :: nil 
- move-backward-out-of-param :: nil 
- css-expand-statement :: nil 
- css-contract-statement :: nil 
matches the file name, and optionally, where CONTENT matches file contents.
Both PATTERN and CONTENTS are matched as regular expressions. 
- kmacro-edit-lossage :: Edit most recent 300 keystrokes as a keyboard macro. 

#+begin_src emacs-lisp
;;; editing-defuns.el --- Basic text editing defuns -*- lexical-binding: t; -*-

(defun open-line-below ()
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun new-line-in-between ()
  (interactive)
  (newline)
  (save-excursion
    (newline)
    (indent-for-tab-command))
  (indent-for-tab-command))

(defun new-line-dwim ()
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{" 1) (looking-at "}"))
                             (and (looking-back ">" 1) (looking-at "<"))
                             (and (looking-back "(" 1) (looking-at ")"))
                             (and (looking-back "\\[" 1) (looking-at "\\]")))))
    (newline)
    (when break-open-pair
      (save-excursion
        (newline)
        (indent-for-tab-command)))
    (indent-for-tab-command)))

(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated."
  (interactive "p")
  (if (region-active-p)
      (let ((beg (region-beginning))
            (end (region-end)))
        (duplicate-region arg beg end)
        (one-shot-keybinding "d" (lambda (duplicate-region 1 beg end))))
    (duplicate-current-line arg)
    (one-shot-keybinding "d" 'duplicate-current-line)))

(defun replace-region-by (fn)
  (let* ((beg (region-beginning))
         (end (region-end))
         (contents (buffer-substring beg end)))
    (delete-region beg end)
    (insert (funcall fn contents))))

(defun duplicate-region (&optional num start end)
  "Duplicates the region bounded by START and END NUM times.
If no START and END is provided, the current region-beginning and
region-end is used."
  (interactive "p")
  (save-excursion
   (let* ((start (or start (region-beginning)))
          (end (or end (region-end)))
          (region (buffer-substring start end)))
     (goto-char end)
     (dotimes (i num)
       (insert region)))))

(defun duplicate-current-line (&optional num)
  "Duplicate the current line NUM times."
  (interactive "p")
  (save-excursion
   (when (eq (point-at-eol) (point-max))
     (goto-char (point-max))
     (newline)
     (forward-char -1))
   (duplicate-region num (point-at-bol) (1+ (point-at-eol)))))

;; toggle quotes

(defun current-quotes-char ()
  (nth 3 (syntax-ppss)))

(defalias 'point-is-in-string-p 'current-quotes-char)

(defun move-point-forward-out-of-string ()
  (while (point-is-in-string-p) (forward-char)))

(defun move-point-backward-out-of-string ()
  (while (point-is-in-string-p) (backward-char)))

(defun alternate-quotes-char ()
  (if (eq ?' (current-quotes-char)) ?\" ?'))

(defun toggle-quotes ()
  (interactive)
  (if (point-is-in-string-p)
      (let ((old-quotes (char-to-string (current-quotes-char)))
            (new-quotes (char-to-string (alternate-quotes-char)))
            (start (make-marker))
            (end (make-marker)))
        (save-excursion
          (move-point-forward-out-of-string)
          (backward-delete-char 1)
          (set-marker end (point))
          (insert new-quotes)
          (move-point-backward-out-of-string)
          (delete-char 1)
          (insert new-quotes)
          (set-marker start (point))
          (replace-string new-quotes (concat "\\" new-quotes) nil start end)
          (replace-string (concat "\\" old-quotes) old-quotes nil start end)))
    (error "Point isn't in a string")))


(defun camelize-buffer ()
  (interactive)
  (goto-char 0)
  (ignore-errors
    (replace-next-underscore-with-camel 0))
  (goto-char 0))

;; kill all comments in buffer
(defun comment-kill-all ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (comment-kill (save-excursion
                    (goto-char (point-max))
                    (line-number-at-pos)))))

(require 's)

(defun incs (s &optional num)
  (let* ((inc (or num 1))
         (new-number (number-to-string (+ inc (string-to-number s))))
         (zero-padded? (s-starts-with? "0" s)))
    (if zero-padded?
        (s-pad-left (length s) "0" new-number)
      new-number)))

(defun change-number-at-point (arg)
  (interactive "p")
  (unless (or (looking-at "[0-9]")
              (looking-back "[0-9]"))
    (error "No number to change at point"))
  (save-excursion
    (while (looking-back "[0-9]")
      (forward-char -1))
    (re-search-forward "[0-9]+" nil)
    (replace-match (incs (match-string 0) arg) nil nil)))

(defun subtract-number-at-point (arg)
  (interactive "p")
  (change-number-at-point (- arg)))

(defun replace-next-underscore-with-camel (arg)
  (interactive "p")
  (if (> arg 0)
      (setq arg (1+ arg))) ; 1-based index to get eternal loop with 0
  (let ((case-fold-search nil))
    (while (not (= arg 1))
      (search-forward-regexp "\\b_[a-z]")
      (forward-char -2)
      (delete-char 1)
      (capitalize-word 1)
      (setq arg (1- arg)))))

(defun snakeify-current-word ()
  (interactive)
  (er/mark-word)
  (let* ((beg (region-beginning))
         (end (region-end))
         (current-word (buffer-substring-no-properties beg end))
         (snakified (snake-case current-word)))
    (replace-string current-word snakified nil beg end)))

(defun transpose-params ()
  "Presumes that params are in the form (p, p, p) or {p, p, p} or [p, p, p]"
  (interactive)
  (let* ((end-of-first (cond
                        ((looking-at ", ") (point))
                        ((and (looking-back ",") (looking-at " ")) (- (point) 1))
                        ((looking-back ", ") (- (point) 2))
                        (t (error "Place point between params to transpose."))))
         (start-of-first (save-excursion
                           (goto-char end-of-first)
                           (move-backward-out-of-param)
                           (point)))
         (start-of-last (+ end-of-first 2))
         (end-of-last (save-excursion
                        (goto-char start-of-last)
                        (move-forward-out-of-param)
                        (point))))
    (transpose-regions start-of-first end-of-first start-of-last end-of-last)))

(defun move-forward-out-of-param ()
  (while (not (looking-at ")\\|, \\| ?}\\| ?\\]"))
    (cond
     ((point-is-in-string-p) (move-point-forward-out-of-string))
     ((looking-at "(\\|{\\|\\[") (forward-list))
     (t (forward-char)))))

(defun move-backward-out-of-param ()
  (while (not (looking-back "(\\|, \\|{ ?\\|\\[ ?"))
    (cond
     ((point-is-in-string-p) (move-point-backward-out-of-string))
     ((looking-back ")\\|}\\|\\]") (backward-list))
     (t (backward-char)))))

(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.")

(defun css-expand-statement ()
  (interactive)
  (save-excursion
    (end-of-line)
    (search-backward "{")
    (forward-char 1)
    (let ((beg (point)))
      (newline)
      (er/mark-inside-pairs)
      (replace-regexp ";" ";\n" nil (region-beginning) (region-end))
      (indent-region beg (point)))))

(defun css-contract-statement ()
  (interactive)
  (end-of-line)
  (search-backward "{")
  (while (not (looking-at "}"))
    (join-line -1))
  (back-to-indentation))

#+end_src
** ACTION File Defuns - *NOT TANGLED*
These I don't use, but they look pretty neat.  untangling for now
#+begin_src emacs-lisp
;; Defuns for working with files

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defun copy-current-file-path ()
  "Add current file path to kill ring. Limits the filename to project root if possible."
  (interactive)
  (let ((filename (buffer-file-name)))
    (kill-new (if eproject-mode
                  (s-chop-prefix (eproject-root) filename)
                filename))))

(defun find-or-create-file-at-point ()
  "Guesses what parts of the buffer under point is a file name and opens it."
  (interactive)
  (find-file (file-name-at-point)))

(defun find-or-create-file-at-point-other-window ()
  "Guesses what parts of the buffer under point is a file name and opens it."
  (interactive)
  (find-file-other-window (file-name-at-point)))

(defun file-name-at-point ()
  (save-excursion
    (let* ((file-name-regexp "[./a-zA-Z0-9\-_~]")
           (start (progn
                    (while (looking-back file-name-regexp)
                      (forward-char -1))
                    (point)))
           (end (progn
                  (while (looking-at file-name-regexp)
                    (forward-char 1))
                  (point))))
      (buffer-substring start end))))

(defun touch-buffer-file ()
  (interactive)
  (insert " ")
  (backward-delete-char 1)
  (save-buffer))
#+end_src
** ACTION Magnar's JS2 mods & some other stuff *NOT TANGLED*
These are mostly specialized functions to support particular languages
#+begin_src emacs-lisp :results value raw  :var source="~/.emacs.d/defuns/js2r-defuns.el" :tangle no
  (mwp-docstring-to-list source)
#+end_src

#+RESULTS:
- jump-between-source-and-test-files :: nil 
- jump-between-source-and-test-files-other-window :: nil 
- js2r-duplicate-object-property-node :: nil 
- js2r--rename-file :: nil 
- also-rename-other :: nil 
- js2r-rename-current-buffer-file :: Renames current buffer and file it is visiting. 
- also-delete-other :: nil 
- js2r-delete-current-buffer-file :: Removes file connected to current buffer and kills buffer. 
- jump-to-source-file :: nil 
- possible-test-file-suffixes :: nil 
- looks-like-test-file-name :: nil 
- jump-to-source-file-other-window :: nil 
- guess-source-file :: nil 
- guess-source-file-name :: nil 
- guess-source-folder :: nil 
- jump-to-test-file :: nil 
- jump-to-test-file-other-window :: nil 
- guess-test-file :: nil 
- test-file-that-exists :: nil 
- test-file-name :: nil 
- test-file-name-stub :: nil 
- guess-test-folder :: nil 
- toggle-assert-refute :: nil 
- remove-js2-mark-overlay :: nil 

#+begin_src emacs-lisp :tangle no
(require 'cl)
(require 's)

(defvar js2r-path-to-tests "/test/"
  "Path to tests from a root shared with sources")

(defvar js2r-path-to-sources "/lib/"
  "Path to sources from a root shared with tests")

(defvar js2r-test-suffix "-test"
  "The suffix added to test files")

(make-variable-buffer-local 'js2r-path-to-tests)
(make-variable-buffer-local 'js2r-path-to-sources)
(make-variable-buffer-local 'js2r-test-suffix)

;; Toggle between source and test
(defun jump-between-source-and-test-files (arg)
  (interactive "P")
  (if (looks-like-test-file-name (buffer-file-name))
      (jump-to-source-file arg)
    (jump-to-test-file arg)))

(defun jump-between-source-and-test-files-other-window (arg)
  (interactive "P")
  (if (looks-like-test-file-name (buffer-file-name))
      (jump-to-source-file-other-window arg)
    (jump-to-test-file-other-window arg)))

;; Duplicate object property node

(defun js2r-duplicate-object-property-node ()
  (interactive)
  (js2r--guard)
  (let ((node (js2r--closest 'js2-object-prop-node-p)))
    (goto-char (js2-node-abs-pos node))
    (skip-syntax-backward " >")
    (insert (buffer-substring (point) (js2-node-abs-end node)) ",")
    (skip-syntax-forward " >")))

;; Rename tests and sources

(defun js2r--rename-file (old-name new-name)
  (let ((modified-p (buffer-modified-p)))
    (rename-file old-name new-name 1)
    (rename-buffer new-name)
    (set-visited-file-name new-name)
    (set-buffer-modified-p modified-p)))

(defun also-rename-other (old-name new-name)
  (let (old-other new-other)
    (condition-case nil
        (if (and (looks-like-test-file-name old-name)
                 (looks-like-test-file-name new-name))
            (setq old-other (guess-source-file old-name)
                  new-other (guess-source-file new-name))
          (setq old-other (guess-test-file old-name)
                new-other (guess-test-file new-name)))
      (error nil))

    (when (and old-other new-other
               (file-exists-p old-other)
               (not (file-exists-p new-other))
               (yes-or-no-p (format "Also rename %S to %S?" old-other new-other)))

      (let ((b (find-buffer-visiting old-other)))
        (if b
            (with-current-buffer b
              (js2r--rename-file old-other new-other))
          (rename-file old-other new-other 1))))))

(defun js2r-rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (js2r--rename-file filename new-name)
               (also-rename-other filename new-name)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

;; Delete tests and sources

(defun also-delete-other (file-name)
  (let (other-name)
    (condition-case nil
        (setq other-name
              (if (looks-like-test-file-name file-name)
                  (guess-source-file file-name)
                (guess-test-file file-name)))
      (error nil))

    (when (and other-name
               (file-exists-p other-name)
               (yes-or-no-p (format "Also delete %S?" other-name)))

      (let ((b (find-buffer-visiting other-name)))
        (when b (kill-buffer b)))

      (delete-file other-name))))

(defun js2r-delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (also-delete-other filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; Jump to source-file

(defun jump-to-source-file (arg)
  (interactive "P")
  (let ((file (guess-source-file (buffer-file-name))))
    (if (or (file-exists-p file) arg)
        (find-file file)
      (error "%s not found." file))))

(defun possible-test-file-suffixes ()
  (cons (concat js2r-test-suffix ".js")
        '("Test.js" "_test.js" "-test.js")))

(defun looks-like-test-file-name (file-name)
  (--any? (s-ends-with-p it file-name) (possible-test-file-suffixes)))

(defun jump-to-source-file-other-window (arg)
  (interactive "P")
  (let ((file (guess-source-file (buffer-file-name))))
    (if (or (file-exists-p file) arg)
        (find-file-other-window file)
      (error "%s not found." file))))

(defun guess-source-file (file-name)
  (unless (looks-like-test-file-name file-name)
    (error "This doesn't look like a test file."))
  (format "%s/%s.js" (s-chop-suffix "/" (guess-source-folder file-name)) (guess-source-file-name file-name)))

(defun guess-source-file-name (file-name)
  (s-chop-suffixes (possible-test-file-suffixes) (file-name-nondirectory file-name)))

(defun guess-source-folder (file-name)
  (let ((test-dir (file-name-directory file-name)))
    (when (not (string-match-p js2r-path-to-tests test-dir))
      (error "Unable to locate source folder. Set js2r-path-to-tests and -sources."))
    (let ((source-dir (replace-regexp-in-string
                       js2r-path-to-tests
                       js2r-path-to-sources
                       test-dir)))
      (if (file-exists-p source-dir)
          source-dir
        (error "Unable to locate source folder. Verify js2r-path-to-tests and -sources")))))


;; Jump to test-file

(defun jump-to-test-file (arg)
  (interactive "P")
  (let ((file (guess-test-file (buffer-file-name))))
    (if (or (file-exists-p file) arg)
        (find-file file)
      (error "%s not found." file))))

(defun jump-to-test-file-other-window (arg)
  (interactive "P")
  (let ((file (guess-test-file (buffer-file-name))))
    (if (or (file-exists-p file) arg)
        (find-file-other-window file)
      (error "%s not found." file))))

(defun guess-test-file (file-name)
  (when (looks-like-test-file-name file-name)
    (error "Looks like you're already in the test file."))
  (or (test-file-that-exists file-name "-test")
      (test-file-that-exists file-name "_test")
      (test-file-that-exists file-name "Test")
      (test-file-name file-name js2r-test-suffix)))

(defun test-file-that-exists (file-name suffix)
  (let ((file (test-file-name file-name suffix)))
    (if (file-exists-p file) file nil)))

(defun test-file-name (file-name suffix)
  (format "%s/%s%s.js" (s-chop-suffix "/" (guess-test-folder file-name)) (test-file-name-stub file-name) suffix))

(defun test-file-name-stub (file-name)
  (s-chop-suffix ".js" (file-name-nondirectory file-name)))

(defun guess-test-folder (file-name)
  (let ((source-dir (file-name-directory file-name)))
    (when (not (string-match-p js2r-path-to-sources source-dir))
      (error "Unable to locate test folder. Set js2r-path-to-tests and -sources."))
    (let ((test-dir (replace-regexp-in-string
                     js2r-path-to-sources
                     js2r-path-to-tests
                     source-dir)))
      (if (file-exists-p test-dir)
          test-dir
        (error "Unable to locate test folder. Verify js2r-path-to-tests")))))

;; Toggle assert/refute

(defun toggle-assert-refute ()
  (interactive)
  (save-excursion
    (end-of-line)
    (re-search-backward "\\(assert\\|refute\\)")
    (if (looking-at "assert")
        (progn
          (kill-word 1)
          (insert "refute"))
      (kill-word 1)
      (insert "assert"))))

;; Mark a js2-node in right window

(defun remove-js2-mark-overlay ()
  (interactive)
  (mapc #'(lambda (o)
            (when (eq (overlay-get o 'type) 'mark-js2-in-right-window)
              (delete-overlay o)))
        (overlays-in (point-min) (point-max))))

(defmacro mark-js2-in-right-window (func)
  `(progn
     (kill-comment nil)
     (windmove-right)
     (remove-js2-mark-overlay)
     (let* ((node ,func)
            (beg (js2-node-abs-pos node))
            (end (js2-node-abs-end node))
            (o (make-overlay beg end nil nil t)))
       (overlay-put o 'face 'region)
       (overlay-put o 'type 'mark-js2-in-right-window)
       (windmove-left)
       (save-excursion
         (insert (format " ;; %s" (js2-node-short-name node)))))))

;;(mark-js2-in-right-window
;;  (js2-node-at-point)) ;; js2-name-node

#+end_src


Here is one more lisp-specific function
#+begin_src emacs-lisp :tangle no
;; Lisp specific defuns

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

#+end_src
** ACTION Misc *NOT TANGLED*
this is a lot of funky shit -- some of it seems cool, but I don;t really use any of it. Not tangled!

#+begin_src emacs-lisp :results value raw  :var source="~/.emacs.d/defuns/misc-defuns.el" :tangle no
  (mwp-docstring-to-list source)
#+end_src

#+RESULTS:
- goto-line-with-feedback :: Show line numbers temporarily, while prompting for the line number input 
- open-line-and-indent :: nil 
- httpd-start-here :: nil 
- magit-gh-pulls-setup :: nil 
- inc-selective-display :: nil 
- dec-selective-display :: nil 
- clear-selective-display :: nil 
- create-temp-selective-display-keymap :: nil 
- isearch-yank-selection :: Put selection from buffer into search string. 
- region-as-string :: nil 
- isearch-forward-use-region :: nil 
- isearch-backward-use-region :: nil 
- view-url :: Open a new buffer containing the contents of URL. 
- linkify-region-from-kill-ring :: nil 
- buffer-to-html :: nil 
- sudo-edit :: nil 
- add-file-find-hook-with-pattern :: Add a find-file-hook that calls FN for files where PATTERN
matches the file name, and optionally, where CONTENT matches file contents.
Both PATTERN and CONTENTS are matched as regular expressions. 
- kmacro-edit-lossage :: Edit most recent 300 keystrokes as a keyboard macro. 


#+begin_src emacs-lisp :tangle no
;; Misc defuns go here
;; It wouldn't hurt to look for patterns and extract once in a while

(defmacro create-simple-keybinding-command (name key)
  `(defmacro ,name (&rest fns)
     (list 'global-set-key (kbd ,key) `(lambda ()
                                         (interactive)
                                         ,@fns))))

(create-simple-keybinding-command f2 "<f2>")
(create-simple-keybinding-command f5 "<f5>")
(create-simple-keybinding-command f6 "<f6>")
(create-simple-keybinding-command f7 "<f7>")
(create-simple-keybinding-command f8 "<f8>")
(create-simple-keybinding-command f9 "<f9>")
(create-simple-keybinding-command f10 "<f10>")
(create-simple-keybinding-command f11 "<f11>")
(create-simple-keybinding-command f12 "<f12>")

(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))

(defun open-line-and-indent ()
  (interactive)
  (newline-and-indent)
  (end-of-line 0)
  (indent-for-tab-command))

;; start a httpd-server in current directory
(defun httpd-start-here (directory port)
  (interactive (list (read-directory-name "Root directory: " default-directory nil t)
                     (read-number "Port: " 8017)))
  (setq httpd-root directory)
  (setq httpd-port port)
  (httpd-start)
  (browse-url (concat "http://localhost:" (number-to-string port) "/")))

;; shorthand for interactive lambdas
(defmacro λ (&rest body)
  `(lambda ()
     (interactive)
     ,@body))

(global-set-key (kbd "s-l") (λ (insert "\u03bb")))

;; command to help set up magit-gh-pulls
;; probably obsolete now that I use forge!!
(defun magit-gh-pulls-setup (repoid)
  (interactive "suser/repo: ")
  (shell-command "git config --add magit.extension gh-pulls")
  (shell-command (concat "git config magit.gh-pulls-repo " repoid)))

;; Increase/decrease selective display
(defun inc-selective-display (arg)
  (interactive "P")
  (if (numberp arg)
      (set-selective-display arg)
    (if (numberp selective-display)
        (set-selective-display (+ 2 selective-display))
      (set-selective-display 2)))
  (create-temp-selective-display-keymap))

(defun dec-selective-display ()
  (interactive)
  (when (and (numberp selective-display)
             (> selective-display 2))
    (set-selective-display (- selective-display 2)))
  (create-temp-selective-display-keymap))

(defun clear-selective-display ()
  (interactive)
  (when (numberp selective-display)
    (set-selective-display nil)))

(defun create-temp-selective-display-keymap ()
  (set-temporary-overlay-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "+") 'inc-selective-display)
     (define-key map (kbd "-") 'dec-selective-display)
     (define-key map (kbd "0") 'clear-selective-display)
     map))
  (message "Type + to reveal more, - for less, 0 to reset."))

;; Add spaces and proper formatting to linum-mode. It uses more room than
;; necessary, but that's not a problem since it's only in use when going to
;; lines.
(setq linum-format (lambda (line)
                     (propertize
                      (format (concat " %"
                                      (number-to-string
                                       (length (number-to-string
                                                (line-number-at-pos (point-max)))))
                                      "d ")
                              line)
                      'face 'linum)))

(defun isearch-yank-selection ()
  "Put selection from buffer into search string."
  (interactive)
  (when (region-active-p)
    (deactivate-mark))
  (isearch-yank-internal (lambda () (mark))))

(defun region-as-string ()
  (buffer-substring (region-beginning)
                    (region-end)))

(defun isearch-forward-use-region ()
  (interactive)
  (when (region-active-p)
    (add-to-history 'search-ring (region-as-string))
    (deactivate-mark))
  (call-interactively 'isearch-forward))

(defun isearch-backward-use-region ()
  (interactive)
  (when (region-active-p)
    (add-to-history 'search-ring (region-as-string))
    (deactivate-mark))
  (call-interactively 'isearch-backward))

(eval-after-load "multiple-cursors"
  '(progn
     (unsupported-cmd isearch-forward-use-region ".")
     (unsupported-cmd isearch-backward-use-region ".")))

(defun view-url ()
  "Open a new buffer containing the contents of URL."
  (interactive)
  (let* ((default (thing-at-point-url-at-point))
         (url (read-from-minibuffer "URL: " default)))
    (switch-to-buffer (url-retrieve-synchronously url))
    (rename-buffer url t)
    ;; TODO: switch to nxml/nxhtml mode
    (cond ((search-forward "<?xml" nil t) (xml-mode))
          ((search-forward "<html" nil t) (html-mode)))))

(defun linkify-region-from-kill-ring (start end)
  (interactive "r")
  (let ((text (buffer-substring start end)))
    (delete-region start end)
    (insert "<a href=\"")
    (yank)
    (insert (concat "\">" text "</a>"))))

(defun buffer-to-html (buffer)
  (with-current-buffer (htmlize-buffer buffer)
    (buffer-string)))

(defun sudo-edit (&optional arg)
  (interactive "p")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(defun add-file-find-hook-with-pattern (pattern fn &optional contents)
  "Add a find-file-hook that calls FN for files where PATTERN
matches the file name, and optionally, where CONTENT matches file contents.
Both PATTERN and CONTENTS are matched as regular expressions."
  (lexical-let ((re-pattern pattern)
                (fun fn)
                (re-content contents))
    (add-hook 'find-file-hook
              (lambda ()
                (if (and
                     (string-match re-pattern (buffer-file-name))
                     (or (null re-content)
                         (string-match re-content
                                       (buffer-substring (point-min) (point-max)))))
                    (apply fun ()))))))

;; Fix kmacro-edit-lossage, it's normal implementation
;; is bound tightly to C-h
(defun kmacro-edit-lossage ()
  "Edit most recent 300 keystrokes as a keyboard macro."
  (interactive)
  (kmacro-push-ring)
  (edit-kbd-macro 'view-lossage))

#+end_src
** ACTION Obsolete Snippet Helpers                                :notangle:
I don't use this stuff at all. Not sure what it does, frankly.  Not tangled.

#+begin_src emacs-lisp :results value raw  :var source="~/.emacs.d/defuns/editing-defuns.el" :tangle no
  (mwp-docstring-to-list source)
#+end_src

#+RESULTS:
- open-line-below :: nil 
- open-line-above :: nil 
- new-line-in-between :: nil 
- new-line-dwim :: nil 
- duplicate-current-line-or-region :: Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. 
- one-shot-keybinding :: nil 
- replace-region-by :: nil 
- duplicate-region :: Duplicates the region bounded by START and END NUM times.
If no START and END is provided, the current region-beginning and
region-end is used. 
- duplicate-current-line :: Duplicate the current line NUM times. 
- yank-advised-indent-function :: Do indentation, as long as the region isn't too large. 
- yank-unindented :: nil 
- current-quotes-char :: nil 
- move-point-forward-out-of-string :: nil 
- move-point-backward-out-of-string :: nil 
- alternate-quotes-char :: nil 
- toggle-quotes :: nil 
- kill-region-or-backward-word :: nil 
- kill-to-beginning-of-line :: nil 
- copy-to-end-of-line :: nil 
- copy-whole-lines :: Copy lines (as many as prefix argument) in the kill ring 
- copy-line :: Copy to end of line, or as many lines as prefix argument 
- save-region-or-current-line :: nil 
- kill-and-retry-line :: Kill the entire current line and reposition point at indentation 
- camelize-buffer :: nil 
- comment-kill-all :: nil 
- incs :: nil 
- change-number-at-point :: nil 
- subtract-number-at-point :: nil 
- replace-next-underscore-with-camel :: nil 
- snakeify-current-word :: nil 
- transpose-params :: Presumes that params are in the form (p, p, p) or {p, p, p} or [p, p, p] 
- move-forward-out-of-param :: nil 
- move-backward-out-of-param :: nil 
- css-expand-statement :: nil 
- css-contract-statement :: nil 

#+begin_src emacs-lisp :tangle no
;;; javascript

(defun js-method-p ()
  (save-excursion
    (word-search-backward "function")
    (looking-back ": ")))

(defun js-function-declaration-p ()
  (save-excursion
    (word-search-backward "function")
    (looking-back "^\\s *")))

(defun snippet--function-punctuation ()
  (if (js-method-p)
      (when (not (looking-at "[ \n\t\r]*[},]"))
        (insert ","))
    (unless (js-function-declaration-p)
      (if (looking-at "$") (insert ";")))))

(defun snippet--function-name ()
  (if (js-function-declaration-p) "name" ""))

;;; clojure

(defun snippet--clojure-namespace-from-buffer-file-name ()
  (replace-regexp-in-string "_" "-"
   (replace-regexp-in-string "/" "."
    (chop-prefix "test/"
    (chop-prefix "src/"
    (chop-suffix ".clj"
     (substring (buffer-file-name) (length eproject-root))))))))

(defun snippet--clojure-namespace-under-test ()
  (replace-regexp-in-string "-test" "" (snippet--clojure-namespace-from-buffer-file-name)))

;; snippet-helper-helpers

(defun chop-suffix (suffix s)
  "Remove string 'suffix' if it is at end of string 's'"
  (let ((pos (- (length suffix))))
    (if (and (>= (length s) (length suffix))
             (string= suffix (substring s pos)))
        (substring s 0 pos)
      s)))

(defun chop-prefix (prefix s)
  "Remove string 'prefix' if it is at start of string 's'"
  (let ((pos (length prefix)))
    (if (and (>= (length s) (length prefix))
             (string= prefix (substring s 0 pos)))
        (substring s pos)
      s)))
#+end_src
** Multiple cursors and delsel
All of the stuff from defuns-dir has been removed.  yay!
#+BEGIN_SRC emacs-lisp
  ;; more of magnar's defuns and modes

  ;; not using yet, too hard
  (use-package mc-extras
    :commands (mc/rect-rectangle-to-multiple-cursors multiple-cursors-mode)
    )
  ;; https://www.emacswiki.org/emacs/delsel.el
  ;; allows delete to be used to kill selection
  (use-package delsel
  :ensure t
  :config
  (delete-selection-mode 1))
#+END_SRC

#+RESULTS:
: t

dele
#+RESULTS:


** WAITING a few Utilities                                          :review:
+I do have "webstuff" factored out as a separate library above, I notice. But I would rather have everything here, so I will lazily put this one little thing here, stolen from+
http://blog.binchen.org/posts/code-completion-for-htmljscss-in-emacs.html 

Includes htmlize, expand-region, undo-tree, flycheck

My html setup is FUUUCCKED so I should revisit this when I can.  
#+BEGIN_SRC emacs-lisp
    ;; (require) your ELPA packages, configure them as normal

    ;; C-= to expand selection by semantic unit
    ;; https://github.com/magnars/expand-region.el
    (use-package expand-region
      :commands er/expand-region)

    ;; replaced below with the fantastic iedit-mode, much more powerful.
    ;;(use-package highlight-symbol )

    ;; essential for all html exports
    (use-package htmlize
      :commands (htmlize-region htmlize-buffer htmlize-file htmlize-many-files htmlize-many-files-dired))


    ;; I don't actually use this much
    ;; and it appears ot cause errors, so squashing for now!
    ;; (use-package markdown-mode )
    ;; multiple cursors extras
    ;; not using right now
    ;; (use-package mc-extras )



    ;; this has become super important -- allows me to go back to any previous state of buffer
    (use-package undo-tree
      :commands undo-tree-visualize)


    ;; modern replacement for flymake

    ;; flycheck is dependent on external tools. Not set up properly yet
    ;; http://www.flycheck.org/manual/latest/Quickstart.html#Quickstart
    ;; This really needs its own lesson, it's fantastic!
    (use-package flycheck
      :hook
      (after-init . global-flycheck-mode))
    ;; (add-hook 'after-init-hook #'global-flycheck-mode)

#+END_SRC



* Web Development 
This section is a pretty serious mess.  I need to figure out how and what I want to do with this stuff.

** Requirements
- code completion in js, html, and css
  - [X] html :: emmet mode does everything I need, though I am not always adept at using it.
  - [ ] css :: company has a built-in css completion mode which works ok.  [[https://www.reddit.com/r/emacs/comments/9bcgbt/good_css_autocompletion_setup/][reddit suggests]] using [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] with [[https://github.com/emacs-lsp/lsp-css][lsp-css]].  There are doubtless advantage to using this  in part b/c it would synchronize my experience with that of my students. There are also ac sources for bootstrap and similar framworks, though I havne't investigated them
  - javascript :: javascipt autocompletion is harder; using tern or tide probably make the most sense.  Here's [[https://emacs.cafe/emacs/javascript/setup/2017/05/09/emacs-setup-javascript-2.html#setting-up-tern--company-mode-for-auto-completion][an emacs cafe post about tern]].  Here are [[https://github.com/ananthakumaran/tide][instructions for using tide]]. another [[https://www.reddit.com/r/emacs/comments/7w0ox0/tide_or_tern/][reddit thread]] about these choices.
- linting/error-checking in all three is done with flycheck. I need to set up eslint!!
  - html ::
  - javascript  :: currently using jshint which is fine but needs to be configured, so might as well use eslint I guess.  *EDIT: I have this set up but my rules need some fixing!*
  - css :: probalby flychedk is good enough. 

- debugging/IDE stuff in javascript. There's a lot to this and I ugess as a shitty coder I don't know how many of these features are important to me.  
  - js2-refactor :: I have this installed but don't understand it. There's a lot to learn from that.
  - xref-js2 :: not using this at all, but a way to jump to definition in hjs files; cf [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][emacs cafe]]. Also it semes like tide certainly provides this also, and I think tern as well.  
  - company-tern :: thjis ocmpletion framework works ok for me. It also does ab8nch of hinting etc.  Upsteream is orphaned though & so tide may be a better long-term choice.
  - REPL and debugging :: Indium is the most featureful and works on browser-relevant code, as well as electorn apps or whatever.  nodejs-repl is simple and easy to set up.  Skewer is a bit of a mess.   

There are some nice setup sections [[https://github.com/CSRaghunandan/.emacs.d/blob/master/setup-files/setup-js.el][for js]] and [[https://github.com/CSRaghunandan/.emacs.d/blob/master/setup-files/setup-web-mode.el][for web mode]] here. THey use a combination of tide and lsp.
  
*** ACTION investigate eslint-fix modes 
- https://github.com/editorconfig/editorconfig-emacs
- https://github.com/aaronjensen/eslintd-fix
- https://github.com/mantoni/eslint_d.js
- https://github.com/codesuki/eslint-fix 

looks like eslint_d-fix wil loverride the js2 settings which is kinda nice.  

** General JS stuff 
#+BEGIN_SRC emacs-lisp
    ;;;; js2-mode
  ;; js stuff
  (use-package js2-mode
    :commands js2-mode
    :mode  "\\.js\\'"
    :config
    (use-package jquery-doc)
    (require 'js-doc)
    (add-hook 'js2-mode-hook
              #'(lambda ()
                  (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                  (define-key js2-mode-map "@" 'js-doc-insert-tag)))
                  (add-hook 'js2-mode-hook #'(lambda ()(flymake-mode -1
              
                  )))
    (define-key js2-mode-map (kbd "C-RET") 'js2-line-break)
    (setq js-doc-mail-address "matt.price@utoronto.ca")
    (setq  js-doc-author (format "Matt Price <%s>" js-doc-mail-address))
    (setq   js-doc-url "matt.hackinghistory.ca")
    (setq   js-doc-license "GPL 3.0")
    (add-hook 'js2-mode-hook
        (defun my-js2-mode-setup ()
          (flycheck-mode t)
          (when (executable-find "eslint")
            (flycheck-select-checker 'javascript-eslint))))
    (require 'eslintd-fix)
    (add-hook 'js2-mode-hook 'eslintd-fix-mode)
  )

  (use-package json-mode )
#+END_SRC

#+RESULTS:

* ACTION Javascript Code Completion
Here are some things related to javascript, including tern and then hopefully swewer, etc. 

- tern :: company-mode backend for tern also.  http://ternjs.net/ . Might want to move this tide instead.  a lot of stuff to learn though. both are here, tide is commented out. 

Some experimental code for javascript langserver, as described here: https://github.com/emacs-lsp/lsp-javascript -- this seems to work pretty well actually.  

- [[https://github.com/ananthakumaran/tide][tide ]] requires tsconfig.json or jsconfig.json, which I don't use. So... maybe don't use for now.. A lot of cool features though.
 
*** Tide and Term
#+BEGIN_SRC emacs-lisp
    ;; (use-package tide
    ;;   :ensure t
    ;;   :after (typescript-mode company flycheck)
    ;;   :hook ((typescript-mode . tide-setup)
    ;;          (js2-mode . tide-setup)
    ;;          (typescript-mode . tide-hl-identifier-mode)
    ;;          (before-save . tide-format-before-save)
    ;;          ))

    (use-package company-tern
      :ensure t
      :after company 
      :config
      (add-to-list 'company-backends 'company-tern)
      ;; (setq company-tern-property-marker " <p>")
      ;; (setq company-tern-meta-as-single-line t)
      ) 
#+END_SRC

#+RESULTS:
: t


*** ACTION LSP 
*TODO: <2019-02-13 Wed>* LSP-mode is really slow, try out eglot instead, figure out company-lsp etc. 

only for JS right now but should probably set up for HTML and CSS at least.  


there are similar lsp packages for other languages (html, css, others) that I have installed but not yet turned on!!

Also lots of options ,cf. [[https://github.com/emacs-lsp/lsp-mode][lower half of the lsp-mode rREADME]] and [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]]'s description of various config variables.    Also note the existence of an alternative project, [[https://github.com/joaotavora/eglot][eglot]], which shells outrather than doing stuff internally, and is maybe a little faster?

Many advanced features I do not understand, in particular "peeking" which seems like an incredibly useful tool.  

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :config
(require 'lsp-clients)
(setq lsp-auto-guess-root t)
;; (add-hook 'js2-mode-hook 'lsp) // to oslow in js, hoping to swtich to eglot soon
  )

(use-package lsp-ui :commands lsp-ui-mode)
(use-package company-lsp :commands company-lsp
:config
(push 'company-lsp company-backends))

#+end_src

#+RESULTS:


#+begin_src emacs-lisp
;; (use-package  lsp-javascript-typescript
;;   :config
;;   (defun my-company-transformer (candidates)
;;     (let ((completion-ignore-case t))
;;       (all-completions (company-grab-symbol) candidates)))

;;   (defun my-js-hook nil
;;     (make-local-variable 'company-transformers)
;;     (push 'my-company-transformer company-transformers))

;;   (add-hook 'js-mode-hook 'my-js-hook)
;;   (add-hook 'js2-mode-hook #'lsp-javascript-typescript-enable)
;;   (add-hook 'typescript-mode-hook #'lsp-javascript-typescript-enable) ;; for typescript support
;;   (add-hook 'js3-mode-hook #'lsp-javascript-typescript-enable) ;; for js3-mode support
;;   ;; (add-hook 'json-mode-hook #'lsp-javascript-typescript-disable) ;;this breaks json mode which is already so slow!!
;;   (add-hook 'rjsx-mode #'lsp-javascript-typescript-enable)) ;; for rjsx-mode support

#+end_src


Tried to do the same thing with html but ended up with 

#+begin_verse
Error from the Language Server: Unknown text document file:///home/matt/Dropbox/Work/History/DigitalHistory/Assignments/00-git/index.html (Unknown Error Code)

#+end_verse

sooo... maybe that'sn to gonna work. 


#+begin_src emacs-lisp
(use-package lsp-html
:config
(add-hook 'html-mode-hook #'lsp))
#+end_src
#+RESULTS:
: t


now try for css. This is also a little difficult, hard to tell if it's working. [[https://github.com/vscode-langservers/vscode-css-languageserver][here is the github repo]].  

this is now deprecated! [[https://github.com/emacs-lsp/lsp-css#deprecated][see the package docs]]
#+begin_src emacs-lisp
;; (use-package lsp-css
;;   :config
;;   (defun my-css-mode-setup ()
;;     (when (eq major-mode 'css-mode)
;;       ;; Only enable in strictly css-mode, not scss-mode (css-mode-hook
;;       ;; fires for scss-mode because scss-mode is derived from css-mode)
;;       (lsp-css-enable)))
;;   ;; (add-hook 'css-mode-hook #'my-css-mode-setup)
  ;; (add-hook 'less-mode-hook #'lsp-less-enable)
  ;; (add-hook 'sass-mode-hook #'lsp-scss-enable)
  ;; (add-hook 'scss-mode-hook #'lsp-scss-enable)
;;  )

(add-hook 'less-mode-hook #'lsp)
(add-hook 'sass-mode-hook #'lsp)
(add-hook 'scss-mode-hook #'lsp)
#+end_src

#+RESULTS:

*** Dealing with JSON and minimfied js/css 
THere's a well-documented and severe slowdown when Emacs loads files with very long lines.  There aren't any great solutionsyet, but here are a few pieces of solution:
- Emacs 27 now offers the option to load a file "literally", in fundamental mode. TThis should slow things up
- the buffer-local variable ~bidi-display-reordering~ checks for RTL text in a LTR language & vice-versa.  Disabling this by default means that it can be reordered just in the appropriate cases.
- loading files in fundamental mode can help with slowdown. this can be done with ~M-x~ ~find-file-literally~
- disabling "smooth=-scrolling mode" may help too; try adding this to ~so-long-minor-modes~?
- [[https://www.reddit.com/r/emacs/search?q=long+lines&restrict_sr=on&utm_source=reddit&utm_medium=usertext&utm_name=emacs&utm_content=t1_e8d5d5j][reddit search for long lines in emacs]]
- [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=13675][longstanding bug report]]
- dealing w/ long lines in term modes (which I don't use) [[https://www.reddit.com/r/emacs/comments/9v4w5w/a_workaround_for_long_lines_in_emacs_term_modes/]]
- [[https://lists.gnu.org/archive/html/emacs-devel/2018-10/msg00470.html][emacs-devel discussion about how to deal w/ this going forward]]
- [[https://lists.gnu.org/archive/html/emacs-devel/2018-10/msg00507.html][important note about this problem in org-mode buffers]]
- [[https://www.reddit.com/r/emacs/comments/33djht/navigating_large_json_documents/][navigation hints]] for json buffers; cf [[https://github.com/Sterlingg/json-snatcher][json-snatcher]]
- [[https://www.reddit.com/r/emacs/comments/7wezb4/how_can_i_make_line_rendering_faster/][disable line-move-visual]]
- [[https://github.com/m00natic/vlfi][view large files mode]] -- this is not really the common problem for me.
- [[https://stackoverflow.com/questions/18316665/how-to-improve-emacs-performance-when-view-large-file][complex over-optimized but cool solution]]
- [[https://github.com/bbatsov/crux][interesting pointer to crusxomode and crux-kill-other-buffers]]


THere are lots of discussions of this: 
- [[https://emacs.stackexchange.com/questions/5545/how-to-prevent-slow-down-when-an-inferior-processes-generates-long-lines][technical discussion of fixing this in comint buffers]]
- [[https://emacs.stackexchange.com/questions/598/how-do-i-prevent-extremely-long-lines-making-emacs-slow][piping json through python before loading]]
- [[https://old.reddit.com/r/emacs/comments/9qtpak/what_would_it_take_to_make_emacs_perform_well_on/][reddit flamage]]
- 
#+begin_src emacs-lisp
(setq-default bidi-display-reordering nil)
(use-package so-long
  ;; no config or anything yet, still getting used to this
  :load-path "~/src/solong"
  :pin manual)
(use-package bln-mode
  :after hydra
  :hook
  (so-long-mode . bln-mode)
  :config
  (defhydra hydra-bln ()      "Binary line navigation mode"
    ("j" bln-backward-half "Backward in line")
    ("k" bln-forward-half "Forward in line")
    ("u" bln-backward-half-v "Backward in window")
    ("i" bln-forward-half-v "Forward in window")
    ("h" bln-backward-half-b "Backward in buffer")
    ("l" bln-forward-half-b "Forward in buffer"))
  (define-key bln-mode-map (kbd "M-j") 'hydra-bln/body))


#+end_src

#+RESULTS:
| bln-mode |

** Node-repl, Indium, expec-path-from-shell, etc. 
I had a really tough time getting the exec path for indium, but this all seems to be settled now, which is great (!!!) :smile:. 

However, I still am not really able to use it very easily/effectively.  

SO here's an outline of what you do.  

[[https://indium.readthedocs.io/en/latest/code-evaluation.html][Indium docs]] are extensive but a little out of date.  Seems like here's what you do: 
- activate ~indium-iunteraction-mode~ (on by default)
- ~C-h m~ tesll you hou to do stuff but seems like mostly ~C-x C-e~ eva llast node, and ~C-M-x~ eval-defun are useful ,ass are ~C-c M-:~ and ~C-c M-i~, both for inspection.  Tehre's also a debugger but I don't quite understand it.  


[[https://github.com/abicky/nodejs-repl.el][nodejs-repl]] is a lot easier to get set up but doesn't provide as much functionality.  E.g., doesn't seem to be a debugger included.  NVM is maybe an issue here as elsewhere, too. Nodejs-repl is installed, but I havne't configured it yet (oops).   

Indium requires ~exec-path-from-shell~ in order to find the right node versions.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
:ensure t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (use-package indium
    :ensure t
    :config
    ;;(indium-launch-node)
(add-hook 'js-mode-hook #'indium-interaction-mode))

#+end_src

#+RESULTS:
: t

*** Nodejs-repl
Indium only sort of works for me and don't have time to explore it fully.  nodejs-repl is very straightforward.  using thissetup today <2019-02-04 Mon> but may revert to indium.  not tnagling this stuff yet.
#+begin_src emacs-lisp
(use-package nodejs-repl
:config
(add-hook 'js-mode-hook
          (lambda ()
          (define-key js-mode-map (kbd "C-x C-e") 'nodejs-repl-send-last-expression)
            (define-key js-mode-map (kbd "C-c C-j") 'nodejs-repl-send-line)
            (define-key js-mode-map (kbd "C-c C-r") 'nodejs-repl-send-region)
            (define-key js-mode-map (kbd "C-c C-l") 'nodejs-repl-load-file)
            (define-key js-mode-map (kbd "C-c C-z") 'nodejs-repl-switch-to-repl))))
#+end_src

#+RESULTS:
: t

** mocha
ds
trying to run tests inside of emacs. We'l lsee how it goes! 
#+begin_src emacs-lisp
(use-package mocha
:ensure t

)

(define-minor-mode mocha-mode
  "Tiny mode to add keybindings for running mocha"
  :group mocha-mode
  :global nil
  :lighter mocha
  ;; :after-hook () ;; add hook to turn on debugging function, see mocha docs
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "C-c m") 'mocha-test)
            (define-key map (kbd "C-c f") 'mocha-test)
            (define-key map (kbd "C-c C-m") 'mocha-test)
            map))

(define-key mocha-mode-map (kbd "C-c m") 'mocha-test-at-point)
(define-key mocha-mode-map (kbd "C-M-x") 'mocha-test-at-point)
(define-key mocha-mode-map (kbd "C-c C-m") 'mocha-test-at-point)


mocha-mode-map
#+end_src

#+RESULTS:

** Impatient Mode
Much better for live html previewing than skewer-mode, which is really for javascript.  Pretty simple to set it up, and starts up a process on https://localhost:8888 .

#+BEGIN_SRC emacs-lisp
    (use-package impatient-mode
      :commands impatient-mode
      :hook
      ((html-mode . impatient-mode)
       (css-mode . impatient-mode)
       (mhtml-mode . impatient-mode)
       (js2-mode . impatient-mode)
       (web-mode . impatient-mode)
       )
      :config
      (setq imp-default-user-filters
            '((html-mode . nil)
              (web-mode . nil)
              (mhtml-mode . nil)))
      (httpd-start)

      ;; (browse-url "http://localhost:8888/imp/")
)
#+END_SRC

#+RESULTS:
| emmet-mode | impatient-mode |

Then browse to the relevant buffer URL (which will be [[http://localhost:8080/imp/]] + file-name, and watch it live-update.  
** Emmet mode & Yasnippet
I've been having some trouble with emmet & yasnippet. I think parto f the reason is that something was resetting yas-snippet-dirs -- I don't know how that's happening  Trying this from [[http://emacs.stackexchange.com/questions/20716/conflict-between-emmet-mode-and-yasnippet-same-trigger-key][stackexchange]]:

There i a whole lot of stuff to think abouth ere!!!

Hippie expand is a mess, and completes with stupid html expansion that is a real drag. I'm not sure when it's ever useful so i'm going to get rid of it.  Note that this might fuck up my expansion order, so should check that out.

Not using yasnippet very much right now but unwilling to get rid of it.  has some uses in js e.g. for defining functions etc.  

Emmet is of course the bomb.      
#+BEGIN_SRC emacs-lisp
    (use-package emmet-mode
      :commands emmet-mode
      :init
      (add-hook 'css-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      :config
      (setq-default emmet-move-cursor-between-quote t)
      (unbind-key "<C-return>" emmet-mode-keymap)

      ;; (unbind-key "C-M-<left>" emmet-mode-keymap)
      ;; (unbind-key "C-M-<right>" emmet-mode-keymap)
      )

  ;; (use-package hippie-exp
  ;;   :ensure nil
  ;;   :defer t
  ;;   :bind ("<C-return>" . hippie-expand)
  ;;   :config
  ;;   (setq-default hippie-expand-try-functions-list
  ;;                 '(yas-hippie-try-expand emmet-expand-line)))
  (use-package yasnippet
    :defer t
    :init
    (add-hook 'js-mode-hook 'yas-minor-mode)
    (add-hook 'sgml-mode-hook 'yas-minor-mode)
    :config
    (setq-default yas-snippet-dirs '("~/.emacs.d/snippets"))
    (yas-reload-all)
    (define-key yas-minor-mode-map (kbd "C-c y") #'yas-expand)

    ;; (unbind-key "TAB" yas-minor-mode-map)
    ;; (unbind-key "<tab>" yas-minor-mode-map)
    )
#+END_SRC

#+RESULTS:
: t

** STARTED Web Utilities: web-beautify, web-mode,emmet-mode
All that stuff above is a bunch of other stufff! Now we have some web-related programming stuff here.  
Notice that Emmet mode has been set twice oops!


#+BEGIN_SRC emacs-lisp


    ;; don't use this much but it can be helpufl. Unfortunately it's not possible to set .jsbeautifyrc 
    ;; clobally so tthat restricts the value a bit.
    (use-package web-beautify
      :commands (web-beautify-html web-beautify-js web-beautify-css))
    ;; I seem to be using mhtml-mode now, so getting rid of this now

    ;; returning to web-mode for now. 
    (use-package web-mode

      :mode ("\\.html\\'" "\\.php\\'")
      :bind (:map web-mode-map ("C-c C-v" . browse-url-of-buffer
      ))
)


  (use-package emmet-mode
    :after web-mode
    :hook
    (web-mode . emmet-mode)
    (sgml-mode . emmet-mode)
    (css-mode . emmet-mode)
    (sass-mode . emmet-mode)
    )

    ;; (use-package company-web-html)                          ; load company mode html backend
    ;; (eval-after-load 'company-etags
    ;;   '(progn
    ;;      (add-to-list 'company-etags-modes 'js2-mode)
    ;;      (add-to-list 'company-etags-modes 'web-mode)))

#+END_SRC

#+RESULTS:
| emmet-mode | lsp-scss-enable |


** temp
Here is a new fund from the UofT Provost for new or existing Access programs:   

https://wp.provost.utoronto.ca/memos-provost-utoronto-ca/call-for-proposals-access-programs-university-fund-pdadc-34/?utm_source=wysija&utm_medium=email&utm_campaign=20181116_WeeklyDigest

 Fund Overview


The University of Toronto has a long-standing commitment to outreach and access – currently there are over 30 access programs across the institution. The University is committed to ensuring that students from communities that are underrepresented in universities see and experience U of T as a place where they belong and can thrive. The purpose of this fund is to provide financial resources to help local units develop new and enhance existing programs dedicated to providing opportunities and support for students who, without intervention, would not access or succeed in post-secondary education. https://wp.provost.utoronto.ca/memos-provost-utoronto-ca/call-for-proposals-access-programs-university-fund-pdadc-34/?utm_source=wysija&utm_medium=email&utm_campaign=20181116_WeeklyDigest 

Funding Streams


The Access Programs University Fund (APUF) supports two levels of grant activities: https://wp.provost.utoronto.ca/memos-provost-utoronto-ca/call-for-proposals-access-programs-university-fund-pdadc-34/?utm_source=wysija&utm_medium=email&utm_campaign=20181116_WeeklyDigest 

Seed ($5,000-$25,000) 
*	 Expand/Sustain/Build ($15,000-$100,000)

This two-tiered system is intended to provide opportunities for creating outreach opportunities and pathways to post-secondary education for underrepresented groups by either developing new projects or scaling existing projects. Grants in both tiers are provided for a maximum of 2 years. Timeline


The 2018-19 Call for Proposals is now available on the Office of the Vice-President  https://wp.provost.utoronto.ca/provost/awards-funding/apuf/ & Provost’s website. Applications for the two streams will be accepted as follows:

*	Seed Grants will be accepted on a rolling basis;
*	Expand/Sustain/Build Grants will be accepted until January 11, 2019.

* Completion, Expansion, Autocorrect, and similar automation
THis section loads & modifies various tools for completing, expanding, correcting, and otherwise easing user input.  THere are many tools for these purposes in theEmacs ecosystem, and sometimes they conflictwith each other. I've tired to collect the ones I use here, in this secion, to rationalize the process.  
** Completion and Autocorrect -- Company Mode
Completion & expansion are complicated subjects, with many options in Emacs! It can be very difficult to navigate, and I've installed a lot of versions of many packages etc.  So, I'm hoping to get my shit together now, by expunging earlier attempts and at least initiating things here.  

I've decided that the most actively-developed, featureful, yet still fairly stable completion framework is company-nmode.  That means I'm getting rid of ac-mode and it may mean that I stop using yanippet, though I'm not sure.  THere are a couple of places where getting all the backends to play nice is difficult; sometimes I think in org-mode, and also osmetimes in html.  So... we're going to see how this all goes.  

I also imagine there may be some complexity to configuring company-mode backends; I'm not dealing with much of that as I start today <2018-10-19 Fri>. Noting here this cool post about [[https://emacs.stackexchange.com/questions/21171/company-mode-completion-for-org-keywords][defining a simple backend for completion of org-mode keywords]]. 

Here's a listo f resources to use --for now I'm keeping things very simple. 

[[https://github.com/osv/company-web#only-use-company-mode-with-company-web-html-in-web-mode][this note from the docs to company-web-html]] suggests a way to reduce the company completions for various modes. I'm interested in figuring that out, but am not get sure how to do it!

Im also putting other forms of expansion here, like abbrev.  THese are the competing functions after all


Trying to deal with some use-package issues w/ company by moving stuff from hooks to config, and moving loading of company-emoji into the same place. 
#+begin_src emacs-lisp 
  (use-package company
    :ensure t
    :after emojify
        ;;:commands (global-company-mode company-mode)
        ;; :hook
        ;;(after-init . 'global-company-mode)
        :config
        (global-company-mode)
        ;; (setq company-tooltip-limit 20)                      ; bigger popup window
        ;; (setq company-tooltip-align-annotations 't)          ; align annotations to the right tooltip border
        ;; (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
        ;; (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing -- this scres me up, ocmmenging out
        ;;(global-set-key (kbd "C-c /") 'company-files)        ; Force complete file names on "C-c /" key
          (defun mwp-dont-insert-unicode-emoji ()
            (make-local-variable 'company-emoji-insert-unicode)
            (setq company-emoji-insert-unicode nil))
        ;;   :after (emojify company)
        ;;   :hook
          (add-hook 'org-mode-hook  'mwp-dont-insert-unicode-emoji)
          (add-hook 'markdown-mode-hook  'mwp-dont-insert-unicode-emoji)
          (add-hook 'gfm-mode-hook  'mwp-dont-insert-unicode-emoji)
          (add-hook 'git-commit-mode-hook  'mwp-dont-insert-unicode-emoji)
          (add-to-list 'company-backends 'company-emoji)
        ;;   (markdown-mode . mwp-dont-insert-unicode-emoji)
        ;;   (gfm-mode . mwp-dont-insert-unicode-emoji)
        ;;   (git-commit-mode . mwp-dont-insert-unicode-emoji)
        ;;   :config
        ;;   (add-to-list 'company-backends 'company-emoji)
            )

    (use-package company-quickhelp
          :ensure t
          :after company
          :init 

          :config
          (company-quickhelp-mode)
          :custom
          (company-quickhelp-color-background "#b0b0b0")
          (company-quickhelp-color-foreground "#232333")

    )
      ;; (use-package company-web-html
      ;;   :after company
      ;;   :bind
      ;;   (("C-'" . company-web-html)
      ;;   ("C-c C-/" . company-files)
      ;;   )
      ;;   :config
      ;;   ;; not sure I should keep these, which are taken from
      ;;   ;; https://github.com/osv/company-web and was written at least a year ago
      ;;   ;;  ;; (setq company-minimum-prefix-length 0)            ; WARNING, probably you will get perfomance issue if min len is 0!

      ;;   )
#+end_src

#+RESULTS:
: t

worki
#+TITLE: 

#+begin_src emacs-lisp :tangle no
(defun add-pcomplete-to-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))

(add-hook 'org-mode-hook #'add-pcomplete-to-capf)

;; (define-key org-mode-map (kbd "s-<return>") 'company-complete)
#+end_src
#+RESULTS:
| add-pcomplete-to-capf | (lambda nil (visual-line-mode -1)) | wrap-region-mode | toc-org-enable | (lambda nil (local-set-key \357 'mwp-send-subtree-with-attachments)) | #[0 \300\301\302\303\304$\207 [add-hook before-save-hook org-encrypt-entries nil t] 5] | #[0 \305\306	>\203 \307 |
 
wor

#+RESULTS:
: t

Now here is the old auto-complete code, *not tangled* for now:
#+begin_src emacs-lisp :tangle no
 ;;;; auto-complete

(use-package auto-complete-config
  :config
  (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")
  (ac-config-default)
  ;; Use dictionaries by default
  (setq-default ac-sources (add-to-list 'ac-sources 'ac-source-dictionary))
  (global-auto-complete-mode t)
  (setq ac-auto-start 2) ; Start auto-completion after 2 characters of a word
  (setq ac-ignore-case nil)) ; case sensitivity is important when finding matches
#+end_src

*** Backend Setup
I think some of the ompany backends are messing me up.  Comapany can do so much, but the modes shadow each other -- if one is running, others will not. Anyway one thought is to not use the backends I no longer want.  Here are a couple

- bbdb -- I don't use bbdb
- php-extrasocompany -- only use in php
- company-eclim -- i don't useeclipse at all so there's no point i nthis for me
- company-xcode -- again, I dont usehtis
- comany-cmake
- company-semantic -- this is about the [[http://cedet.sourceforge.net/semantic.shtml][CEDET project's semantic project, which I don't fully undertand, probbly keep. 
** Abbrev mode
I mostly use abbrev mode as a spellchecker. It works OK, and I'm used to it, and there doesn't seem to be a better option for emacs right now.  By default abbrev-mode replacement tables are major-mode-specific; this is sort of ok but actually I want the same table for all text modes, because I'm always writing in in English.  ~mwp-set-text-mode-abbrev-table~ does this for me. A more sophisticated approach would be to do osmething similar in comment regions of code buffers; and maybe to reset the abbrev-table within coe blocksi n org buffers; but so far I haven't tried to do anything like that. See also ~polymode~ for other approaches to mode mixing. 

#+begin_src emacs-lisp
    ;;;; auto spell correct! much better!
    ;; this has been a godsend
    (defun endless/ispell-word-then-abbrev (p)
      "Call `ispell-word'. Then create an abbrev for the correction made.
      With prefix P, create global abbrev. Otherwise it will be local."
      (interactive "P")
      (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
        (call-interactively 'ispell-word)
        (setq aft (downcase (or (thing-at-point 'word) "")))
        (unless (string= aft bef)
          (message "\"%s\" now expands to \"%s\" %sally "
                   bef aft (if p "glob" "loc" ))
          (define-abbrev
            (if p global-abbrev-table local-abbrev-table)
            bef aft)))
      (write-abbrev-file))
  ;;;; abbrev-mode
  (use-package abbrev-mode
    :init
    (setq-default abbrev-mode t)
    ;; a hook funtion that sets the abbrev-table to org-mode-abbrev-table
    ;; whenever the major mode is a text mode
    (defun mwp-set-text-mode-abbrev-table ()
      (if (derived-mode-p 'text-mode)
          (setq local-abbrev-table org-mode-abbrev-table)))
    (add-hook 'abbrev-mode-hook #'mwp-set-text-mode-abbrev-table)
   
    :commands abbrev-mode
    ;; :hook
    ;; (abbrev-mode . mwp-set-text-mode-abbrev-table)
    :config
    ;; (setq default-abbrev-mode t)
    (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
    (read-abbrev-file "~/.emacs.d/abbrev_defs")       ;; reads the abbreviations file on startup
    (setq save-abbrevs 'silently)              ;; now I won't be asked


    )


#+end_src

#+RESULTS:

helpme
*** org-tempo
old easy templates have been replaced by org-tempo, and then after *that* they wree sort of duplicated with a new workflow. I like the old one and for now I'm using it, but I'm reverting to the old alisst variable, which is used by both forntends.  I may eventually just sunset this in favour of a more generic completion framework, who knows.  
#+begin_src emacs-lisp
    (let ((org-tempo-keywords-alist nil))
    (use-package org-tempo
      :after (org)
      :load-path "/home/matt/src/org-mode/emacs/site-lisp/org"
      :preface 
      (setq org-tempo-keywords-alist nil)
      (customize-set-variable 'org-structure-template-alist '(("a" . "export ascii")
                                           ;; ("c" . "center")
                                           ("C" . "comment")
                                           ("E" . "example")
                                           ("e" . "src emacs-lisp")
                                           ("H" . "export html")
                                           ("l" . "export latex")
                                           ("q" . "quote")
                                           ("s" . "src")
                                           ("v" . "verse")
                                           ("i" . "index")
                                           ("j" . "src js")
                                           ("c" . "src css")
                                           ("n" . "notes")
                                           ("h" . "src html")))
      :init
      (setq org-tempo-keywords-alist nil)
  
      :config
      ;; (setq org-tempo-keywords-alist '(("L" . "latex")
      ;;                                  ("H" . "html")
      ;;                                  ("A" . "ascii")
      ;;                                  ("i" . "index")
      ;;                                  ("j" . "src js")
      ;;                                  ("c" . "src css")
      ;;                                  ("" . "src emacs-lisp")
      ;;                                  ("h" . "src html")))
      ))

    ;;
#+end_src

#+RESULTS:

** Paredit, smartparens, and other things                        :converted:
I've bene using paredit for some time; it is a great start at helping you to think more lisp-y when you're workingin a lisp-like language. There are many other modes that try to do similar things, including [[https://github.com/shaunlebron/parinfer][parinfer]] (experimental, amazing), [[https://github.com/abo-abo/lispy][lispy]] (vim-inspired, uses single keys to pbind paredit-like functions, looks amazing but also probably has a bit of a learning curve), [[https://github.com/Fuco1/smartparens/wiki/Paredit-and-smartparens][smartparens]] (I use this in non-lisp modes instead, again looks like a bit of a learning curve and some changes in behaviour from paredit).

<2019-02-04 Mon>
I'd like to switch to lispy, but putting that on hold.

Having trouble in org-mode with smartparens.  Trying a fix from [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg121129.html][here]].  

*** Paredit
For now I have paredit here, which I use in all lisp-like modes. So far so good. 

Update <2018-10-15 Mon>: converted ~:config~ hooks to ~:hook~ keywords
#+BEGIN_SRC emacs-lisp

  ;; paredit stuff.  belongs in setup-paredit, oh well
    ;; difficult but cool
  (use-package paredit
    :hook
    ((emacs-lisp-mode . enable-paredit-mode)
     (eval-expression-minibuffer-setup . enable-paredit-mode)
     (ielm-mode . enable-paredit-mode)
     (lisp-mode . enable-paredit-mode)
     (lisp-interaction-mode . enable-paredit-mode)
     (scheme-mode . enable-paredit-mode))
    :config
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    :bind
      (:map paredit-mode-map
      ("M-s" . nil)
      ("M-s s" . paredit-splice-sexp)))
#+END_SRC

#+RESULTS:
: paredit-splice-sexp

*** smartparens
located here: https://github.com/Fuco1/smartparens/blob/master/smartparens-config.el

for now, I'm trying to use paredit in lisp modes and smartparens in other modes. Since this is a little tricky... I am stealing some code form here: https://www.reddit.com/r/emacs/comments/4nvhu4/what_parenthese_package_do_you_use_and_why/ 

A few notes about smartparens, which I havne't used much of yet:

- hthere are also set-up files for [[https://github.com/Fuco1/smartparens/blob/master/smartparens-org.el][org]] and markdown, but I haven't used them yet. smartparens-config loads the relevant settings for smartparens, but *doesn't* enable the modes, which we still need to do separately.  I think I want it in text modes too, but it conflicts with org-mode bindings, so disabling for now, oh well, maybe I can use just electric-pair-mode, trying that for now.   


#+BEGIN_SRC emacs-lisp
  (defun paredit-or-smartparens ()
    "Enable either paredit or smartparens strict mode."
    (if (member major-mode '(emacs-lisp-mode
                             lisp-interaction-mode
                             lisp-mode
                             scheme-mode
                             eval-expression-minibuffer-setup))
        (enable-paredit-mode)
      (smartparens-mode)))

  (add-hook 'prog-mode-hook #'paredit-or-smartparens)
  ;; (add-hook 'text-mode-hook #'electric-pair-local-mode
 )
 ;;(add-hook 'org-mode-hook #'smartparens-mode)

(use-package elec-pair
  :config
  (defun mwp-org-mode-electric-inhibit (c)
    (and
     (or (eq ?\< c) (eq ?\[ c ))
     (eq major-mode 'org-mode)))
  (advice-add electric-pair-inhibit-predicate :before-until #'mwp-org-mode-electric-inhibit))




  ;;(remove-hook 'org-mode-hook (lambda () (electric-pair-local-mode -1)))
  (use-package smartparens
    :bind
    (:map smartparens-mode-map
    ("M-s" . nil)
    ("M-s s" . sp-splice-sexp))

    :config
    (require 'smartparens-config)
    (require 'smartparens-javascript)
    (require 'smartparens-org)
    (sp-use-paredit-bindings)
    ;; I don't quite understand this one
    ;; (sp-local-pair 'org-mode "[" nil :actions nil)
    (sp-local-pair 'org-mode "[" "]" :actions '(wrap autoskip navigate))
    (with-no-warnings
      (defun sp-paredit-like-close-round ()
        "If the next character is a closing character as according to smartparens skip it, otherwise insert `last-input-event'"
        (interactive)
        (let ((pt (point)))
          (if (and (< pt (point-max))
                   (sp--char-is-part-of-closing (buffer-substring-no-properties pt (1+ pt))))
              (forward-char 1)
            (call-interactively #'self-insert-command))))
      (define-key smartparens-mode-map (kbd ")") #'sp-paredit-like-close-round)))



#+END_SRC

#+RESULTS:
: sp-splice-sexp
#+begin_src emacs-lisp

#+end_src

Trying out skeleton mode for org: 
<2019-02-04 Mon> I'm not so happy with this, removing. 
#+begin_src emacs-lisp :tangle no
(require 'skeleton)
(setq skeleton-pair t)

(define-key org-mode-map (kbd "~") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "=") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "*") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "+") 'skeleton-pair-insert-maybe)

;;(define-key org-mode-map (kbd "[") 'skeleton-pair-insert-maybe) ;; don't use this one!!
(define-key org-mode-map (kbd "[") 'org-self-insert-command) ;; don't use this one!!
(define-key org-mode-map (kbd "{") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "(") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "\"") 'skeleton-pair-insert-maybe)
;; (define-key org-mode-map (kbd "'") 'skeleton-pair-insert-maybe)
(define-key org-mode-map (kbd "'") 'org-self-insert-command)


(define-key org-mode-map (kbd "~") 'org-self-insert-command)
(define-key org-mode-map (kbd "=") 'org-self-insert-command)
(define-key org-mode-map (kbd "*") 'org-self-insert-command)
(define-key org-mode-map (kbd "+") 'org-self-insert-command)

;;(define-key org-mode-map (kbd "[") 'skeleton-pair-insert-maybe) ;; don't use this one!!
(define-key org-mode-map (kbd "[") 'org-self-insert-command) ;; don't use this one!!
(define-key org-mode-map (kbd "{") 'org-self-insert-command)
(define-key org-mode-map (kbd "(") 'org-self-insert-command)
(define-key org-mode-map (kbd "\"") 'org-self-insert-command)
;; (define-key org-mode-map (kbd "'") 'org-self-insert-command)
(define-key org-mode-map (kbd "'") 'org-self-insert-command)


(defun mwp-remove-pairing () 
(electric-pair-local-mode -1 )


;; (add-hook 'org-mode-hook 'mwp-remove-pairing)
(remove-hook 'org-mode-hook 'mwp-remove-pairing)
#+end_src

#+RESULTS:
| mwp-dont-insert-unicode-emoji | toc-org-enable | (lambda nil (local-set-key \357 'mwp-send-subtree-with-attachments)) | #[0 \300\301\302\303\304$\207 [add-hook before-save-hook org-encrypt-entries nil t] 5] | #[0 \305\306	>\203 \307 |

* Helm stuff
#+begin_src emacs-lisp
  (use-package helm
    :config
    (setq helm-completing-read-handlers-alist
     '((describe-function . helm-completing-read-symbols)
       (describe-variable . helm-completing-read-symbols)
       (debug-on-entry . helm-completing-read-symbols)
       (find-function . helm-completing-read-symbols)
       (trace-function . helm-completing-read-symbols)
       (trace-function-foreground . helm-completing-read-symbols)
       (trace-function-background . helm-completing-read-symbols)
       (find-tag . helm-completing-read-with-cands-in-buffer)
       (ffap-alternate-file)
       (tmm-menubar) 
       (nil)
       (zotxt-completing-read . helm-comp-read))))

       ;; (use-package helm-firefox
       ;; :config 
       ;; (setq helm-firefox-default-directory "~/.mozilla/firefox/14pyoh5l.dev-edition-default/"))
(setq debug-on-quit nil)
#+end_src
* Help Systems
** Docstrings for functions, variables, keybindings, etc. 
The default Emacs help functions are fantastic, but there are a bunch of replacements that provide more information or a smoother UI.  Two that I have installedo n my system right now are 
- ~~counsel-describe-[function|variable]~ described in some detail [[https://oremacs.com/2015/06/08/describe-variable-tip/][in this 2015 post on oremacs]]
- the [[https://github.com/Wilfred/helpful][helpful]] package.  I have them both here & will try to make a choice between them soon.  

There here together so I can make the choice.

<2018-10-20 Sat> The Counsel-mode functions are dropped for now in the hopes of getting rid of counsel altogether, since I use helm a lot more. It is i nfact kind of awesome... 

#+BEGIN_SRC emacs-lisp
  ;; trying helpful for now, in the hopes of dropping counsel altogether, since I use helm more. 

  ;; (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  ;; (global-set-key (kbd "<f1> f") 'counsel-describe-function)

  (use-package helpful
    :bind
    ("C-h v" . helpful-variable)
    ("C-h f" . helpful-callable)
    ("C-h k" . helpful-key)
    ("C-c C-d" . helpful-at-point)
    ("C-h F" . helpful-function)
    ("C-h C" . helpful-command)
    ;; :config

    ;; ;; Note that the built-in `describe-function' includes both functions
    ;; ;; and macros. `helpful-function' is functions only, so we provide
    ;; ;; `helpful-callable' as a drop-in replacement.    (global-set-key (kbd "C-h f") #'helpful-callable)

    ;; (global-set-key (kbd "C-h v") #'helpful-variable)
    ;; (global-set-key (kbd "C-h k") #'helpful-key)

    ;; ;; Lookup the current symbol at point. C-c C-d is a common keybinding
    ;; ;; for this in lisp modes.
    ;; (global-set-key (kbd "C-c C-d") #'helpful-at-point)

    ;; ;; Look up *F*unctions (excludes macros).
    ;; ;;
    ;; ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
    ;; ;; already links to the manual, if a function is referenced there.
    ;; (global-set-key (kbd "C-h F") #'helpful-function)

    ;; ;; Look up *C*ommands.
    ;; ;;
    ;; ;; By default, C-h C is bound to describe `describe-coding-system'. I
    ;; ;; don't find this very useful, but it's frequently useful to only
    ;; ;; look at interactive functions.
    ;; (global-set-key (kbd "C-h C") #'helpful-command)
    )
#+END_SRC


#+RESULTS:
: helpful-command


** Guidekey                                                      :converted:
This has been helpful for when I'm forgetful. It pops up a help buffer showing possible completions of key maps. In this way it's a bit like hydra, which I havne't learned to use properly yet. 

<2018-10-15 Mon> Converted to use-package.  Doesn't feel quite finished!


#+BEGIN_SRC emacs-lisp
  ;; learn some more key bindings with guide-key
  ;; guide-key

  (use-package guide-key
    :after org
    :config
    (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x +"))
    (setq guide-key/recursive-key-sequence-flag t)
    (setq guide-key/popup-window-position 'bottom)
    (guide-key-mode 1)
    ;; add some stuff just for org-mode. Hence the :after above
    (defun guide-key/my-hook-function-for-org-mode ()
      (guide-key/add-local-guide-key-sequence "C-c")
      (guide-key/add-local-guide-key-sequence "C-c C-x")
      (guide-key/add-local-highlight-command-regexp "org-"))
    :hook
    (org-mode . guide-key/my-hook-function-for-org-mode)
    ;; (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)
    )

#+END_SRC

** ACTION function documentation
two functions to find function defns in python and elisp. 
Not sure I need to yuese these to be honest.  The latter one in particular is a little silly.

What is this "indent yanked code" doing here? belongs elsewhere!
#+BEGIN_SRC emacs-lisp

  ;;;; add eldoc for python
  (add-hook 'python-mode-hook
            '(lambda () (eldoc-mode 1)) t)
  ;;;;; indent yanked code
  ;; this replicates other functionality, let's just get rid of this to 
  ;; avoid problems
  ;; (dolist (command '(yank yank-pop))
  ;;   (eval `(defadvice ,command (after indent-region activate)
  ;;            (and (not current-prefix-arg)
  ;;                 (member major-mode '(emacs-lisp-mode lisp-mode
  ;;                                                      clojure-mode    scheme-mode
  ;;                                                      haskell-mode    ruby-mode
  ;;                                                      rspec-mode      python-mode
  ;;                                                      c-mode          c++-mode
  ;;                                                      objc-mode       latex-mode
  ;;                                                      plain-tex-mode))
  ;;                 (let ((mark-even-if-inactive transient-mark-mode))
  ;;                   (indent-region (region-beginning) (region-end) nil))))))

  ;;;; Find a Function Definition
  ;; A simple lambda function to search and find the definition of a function or variable.  Only works In Elisp.  Bound to C-c f.
  ;; not sure this makes much sense; I think use *helpful* instead.
  ;; (global-set-key (kbd "C-c f")
  ;;                 (lambda ()
  ;;                   (interactive)
  ;;                   (use-package finder)
  ;;                   (let ((thing (intern (thing-at-point 'symbol))))
  ;;                     (if (functionp thing)
  ;;                         (find-function thing)
  ;;                       (find-variable thing)))))
#+END_SRC

* Search

I use isearch quite a bit, but it has some limitations.  [[https://www.masteringemacs.org/article/searching-buffers-occur-mode][Emacs occur-mode]] finds all occurrences of a string or pattern in the current buffer. I use it a lot, and have just started using [[https://github.com/fourier/loccur][loccur]], which performs the same search but doesn't require navigation out of the buffer, simply narrowing to the matching lines & allowing you to navigate to the one you want, then start editing again with ~[Return]~. THere are other versions, like [[https://www.emacswiki.org/emacs/SearchBuffers][moccur]], etc., for searching multiple buffers & so forth. I believe I have some old modes loaded that work i nthis area, but I'm not sure what they are :-( and hopefully they aren't making any trouble for me. )

Anyway there is one annoying featuere in loccur which is that even though I have loccur-current bound to its own key, ~loccur~ still fills in a    
#+begin_src emacs-lisp
    (use-package loccur
      :ensure t
      :bind
      (("M-s l" . loccur-current)
       ("M-s L" . loccur)
       ("M-s M-l" . loccur-previous-match))
      :config
      (defvar loccur-fill-word t
        "whether or not to fill in the current word at prompt")
      (setq loccur-fill-word nil)
      (defun loccur-prompt ()
    "Return the default value of the prompt.

  Default value for prompt is a current word or active region(selection),
  if its size is 1 line"
    (let ((prompt
           (if (and transient-mark-mode
                    mark-active)
               (let ((pos1 (region-beginning))
                     (pos2 (region-end)))
                 ;; Check if the start and the end of an active region is on
                 ;; the same line
                 (when (save-excursion
                         (goto-char pos1)
                         (<= pos2 (line-end-position)))
                     (buffer-substring-no-properties pos1 pos2)))
             (if loccur-fill-word 
                 (current-word) nil))))
      prompt))
      )



#+end_src

#+RESULTS:
: loccur-previous-match

** Anzu
[[https://github.com/syohex/emacs-anzu][Anzu]] provides a nice visual cue to string matches during searches, as well as a hint in the modeline.  It's awesome.
#+BEGIN_SRC emacs-lisp
  ;; anzu -- pretty text replacement
  (use-package anzu
    :config
    (global-anzu-mode)
    (global-set-key (kbd "M-%") 'anzu-query-replace)
    (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
#+END_SRC
* User Experience
** Wrap-region

*NOTE <2019-02-04 Mon>*: this should actually be superseded by smartparens -- when I have time i should fix.  
this is supposed to make it possible to wrap regions...
#+BEGIN_SRC emacs-lisp
;; wrap-region
(use-package wrap-region
  :ensure t
  :config
  (wrap-region-add-wrappers
   '(("*" "*" nil org-mode)
     ("~" "~" nil org-mode)
     ("/" "/" nil org-mode)
     ("=" "=" nil org-mode)
     ("_" "_" nil org-mode)
     ("$" "$" nil (org-mode latex-mode))))
  ;;(wrap-region-remove-wrapper "[" 'org-mode)
  (add-hook 'org-mode-hook 'wrap-region-mode)
  (add-hook 'latex-mode-hook 'wrap-region-mode))
#+END_SRC
[
** Scrolling
this helps with scrolling, which IIRC doesn't work so great in vanilla emacs. 
#+BEGIN_SRC emacs-lisp

(scroll-bar-mode 1)           
  (set-scroll-bar-mode 'right)
(setq
 scroll-margin 0
 scroll-conservatively 100000
 scroll-preserve-screen-position 1)

#+END_SRC
** ACTION Backup and Autosave
:PROPERTIES:
:ID:       f9c8d6de-1a19-4777-af0c-6125a804c96f
:END:

Here we just set some variables related to backup frequency and location, and also load the ~saveplace~ package, which saves location in each buffer (this isa godsend). For backups we set the following
- enable backup of version-controlled files
- keep 5 versions
- keep 5 "old" versions as well
- 

The *ACTION* is: saveplace is not writing properly.  It's a drag!
#+BEGIN_SRC emacs-lisp
  ;;; backup and autosave
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (setq make-backup-files t)       ; enable backup file
  ;;;; put packups in ~/.backup
  (setq backup-directory-alist
        (cons (cons "\\.*$" (expand-file-name "~/.backup"))
              backup-directory-alist))

  (setq version-control t)     ; enable versions of backup
  (setq kept-new-versions 5)   ; how many keep new verisons
  (setq kept-old-versions 5)   ; how many keep old versions
  (setq delete-old-versions t) ; delete old version without asking
  (setq vc-make-backup-files t) ; still make a backup for version-controled files

  ;;;;; Autosave in .backup dir
  (setq auto-save-file-name-transforms
        '(("\\([^/]*/\\)*\\([^/]*\\)\\'" "~/.backup/\\2" t)))

  ;; make emacs remember where it is in the file you just closed
  (use-package saveplace 
    :init
    ;; (setq-default save-place t)
    (save-place-mode)
    ;; (setq save-place-file (expand-file-name "places" user-emacs-directory))
     :config
    (setq server-visit-hook (quote (save-place-find-file-hook)))
    (setq save-place-forget-unreadable-files nil)
    )

#+END_SRC

#+RESULTS:
: t

*** Persistent scratch                                          :converted:
I now use this a lot. Modified <2018-10-16 Tue> to start making backups.  cf. [[http://pragmaticemacs.com/emacs/a-persistent-scratch-buffer/][this blog pust]] as well as [[https://github.com/Fanael/persistent-scratch][the repo]]
#+BEGIN_SRC emacs-lisp
  ;; persistent-scratch
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default)
    (setq persistent-scratch-backup-directory "~/.backup/persistent-scratch"))
#+END_SRC

#+RESULTS:
: t

** WAITING iswitchp mode            *NOT TANGLED*                   :review:
I don't really use this, but I really liked the idea at one point so not deleting this.I'm untangling this for now, because there are a number of alternatives also here in the config files. 
#+BEGIN_SRC emacs-lisp  
;;;; iswitchb-mode
;; I want to be able to conmute between a split and a single window (sort of "C-x 1" for the one on focus)
(iswitchb-mode 1)
(defun my-iswitchb-select()
  "Jump to buffer without having to hit 'RET' key or C-j. The binding to C-2 is more ergonomic"
  (interactive)
  (if (window-minibuffer-p (selected-window))
      (iswitchb-select-buffer-text)))

(define-key global-map (kbd "C-2") 'my-iswitchb-select)


(defun my-iswitchb-close()
  "Open iswitchb or, if in minibuffer go to next match. Handy way to cycle through the ring."
  (interactive)
  (if (window-minibuffer-p (selected-window))
      (keyboard-escape-quit)))
#+END_SRC

#+RESULTS:
: my-iswitchb-close

** Tramp mode
THis is an essential piece of infrastructure.  Not configuring right now... 
#+BEGIN_SRC emacs-lisp
;;;; tramp mode
 (use-package tramp
   :defer)

#+END_SRC

** Kill this buffer, delete this frame 
:PROPERTIES:
:GRADE:    1
:END:
Excellent [[http://irreal.org/blog/?p=5585][summary on irreeal]] of another post that remaps ~C-x k~ to a command that actually just kills the darn buffer that you're currently in, which is what you pretty much always want to do (!).  A really nice,m if extremely simple, improvement. Thanks guys!
#+BEGIN_SRC emacs-lisp
    (defun jcs-kill-a-buffer (askp)
      (interactive "P")
      (if askp
          (call-interactively #'kill-buffer)
        (kill-buffer (current-buffer))))

    (global-set-key (kbd "C-x k") 'jcs-kill-a-buffer)
;;  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

#+RESULTS:
: jcs-kill-a-buffer

more from Pragmatic Emacs:

Following on from my post on using C-x k to kill the current buffer, why not bind C-x w to delete-frame in order close the current emacs window (remember, in Emacs-speak, a frame is what most other apps would call a window). This is way
better than the default C-x 5 0 

Just add the following to your emacs config file 
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x w") 'delete-frame)

#+END_SRC

#+RESULTS:
: delete-frame

** Make Parent Directory
Mbork discusses [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][this simple bit of code]] to automatically create parent directories when saving a file to a non-existent directory. I don't quite understand why the variables in the internal function call don't have to be passed in as parameters but maybe the hook mechanism always provides certain variables to the hook function.

Anyway, this has proved super-awsome over the years.
#+BEGIN_SRC emacs-lisp
(defun make-parent-directory ()
  "Make sure the directory of `buffer-file-name' exists."
  (make-directory (file-name-directory buffer-file-name) t))

(add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC

** One-line fix for disappearing clipboard entries 
OFten I copy something in Firefox and then go to emacs, but in between I kill some text. Then when I want to paste/yank in the ff text, it's gone and I have to recopy.  TThis one-line setting fixes that:

<2018-10-20 Sat> huh, this seems to be missing!
** Better case manipulation 
This seems ok.  I don't love love it, and I don't ues it much.
#+BEGIN_SRC emacs-lisp
(defun xah-toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.

URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
Version 2016-01-08"
  (interactive)
  (let (
        (deactivate-mark nil)
        -p1 -p2)
    (if (use-region-p)
        (setq -p1 (region-beginning)
              -p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alnum:]")
        (setq -p1 (point))
        (skip-chars-forward "[:alnum:]")
        (setq -p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region -p1 -p2)
      (put this-command 'state 1))
     ((equal 1  (get this-command 'state))
      (upcase-region -p1 -p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region -p1 -p2)
      (put this-command 'state 0)))))
      (global-set-key  (kbd "C-9") 'xah-toggle-letter-case)
#+END_SRC

#+RESULTS:
: xah-toggle-letter-case
* Function Definitions
THis stuff should maybe be moved into a minor mode that I can load or something? "Matt's random collection of functions? 
** moving and copying
~mwp-copy-whole-buffer~ marks the whole buffer and copies it to kill-ring. Bound to [f6].
~smarter-move-beginning-of-line~ is an awesome helper function to make movement easier. 
#+BEGIN_SRC emacs-lisp
  ;; here's a quick macro to select and copy a buffer
  ;; F6 copy whole buffer
  (defun mwp-copy-whole-buffer ()
    "Copy the whole buffer into the kill ring"
    (interactive)
    (mark-whole-buffer)
    (copy-region-as-kill(region-beginning) (region-end))
    )
  (global-set-key (quote [f6]) 'mwp-copy-whole-buffer)

#+END_SRC
** Moving to beginning of line
THis is something I tried hard to make work, but seems to be overwridden by visual-line-mode, so I'm commenting this out now. I have apackage to manage this now, though at the moment it doesn't seem to be working either.

I don't have this i nmy load path but [[https://github.com/alezost/mwim.el][move what i mean]] mode seems cool. 

So cool that I ust installed it!
#+begin_src emacs-lisp
  (use-package mwim 
    :ensure t
    :bind 
    (("C-a" . mwim-beginning)
     ("C-e" . mwim-end)))

#+end_src
   dkljfsa
#+RESULTS:
: mwim-end

#+BEGIN_SRC emacs-lisp :tangle no 
  ;; better C-a behaviour everywhere (http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/)
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil)) ; comment
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line

** prodigy 
I'm not using this yet, but it seems really neat: [[https://github.com/rejeep/prodigy.el][github]]
#+BEGIN_SRC emacs-lisp :tangle no 
  ;; prodigy looks really ocol,
  ;; https://github.com/rejeep/prodigy.el
  ;; but I am not using it at the moment ,so commented out
  ;; (use-package prodigy)
  ;; (global-set-key (kbd "C-x M-m") 'prodigy)
#+END_SRC
** Dash 
Essential infrastructure! [[https://github.com/magnars/dash.el][github]]. However, i don't have to actual load it so I add the use the ~:no-require~ keyword -- I'll I'm really doing is setting up for an eval-after-load hook, so that dash-ed functions get font-locked in elisp buffers.
#+BEGIN_SRC emacs-lisp
  ;; Font lock dash.el
  ;; dash.el is amazing, maybe to oadvanced for me
  (use-package dash
    :no-require t
    :config
    (dash-enable-font-lock))
#+END_SRC

* Server
In general, I want the server to start if Emacs isn't already running.  
#+BEGIN_SRC emacs-lisp
  ;; ;; Emacs server
  (use-package server
    :config
    (or (eq (server-running-p) t)
      (server-start))
    )

#+END_SRC

#+RESULTS:
: t

* Keybindings; Programming; More UI
** WAITING Magnars Keybindings  
This is very inspiring though I've commented a lot of it out.  Trying to reduce my dependenceon non-stnadard bindings.

#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; some stuff form magnars,
  ;; https://github.com/magnars/.emacs.d/blob/master/key-bindings.el
  ;; this should be moved to own file keybindings.el

  ;; this is old, and some of this gets written over later in the process.
  ;; (use-package misc)
  ;; (global-set-key (kbd "s-.") 'copy-from-above-command)

  ;; find function!  a must
  (global-set-key (kbd "C-h C-f") 'find-function)
  ;; M-i for back-to-indentation; may not be necessary anymore and I don't use it
  ;; (global-set-key (kbd "M-i") 'back-to-indentation)

  ;; Turn on the menu bar for exploring new modes ;; this is cool
  (global-set-key (kbd "C-<f10>") 'menu-bar-mode)

  ;; transposing -- these are neat
  ;; Transpose stuff with M-t
  (global-unset-key (kbd "M-t")) ;; which used to be transpose-words
  (global-set-key (kbd "M-t l") 'transpose-lines)
  (global-set-key (kbd "M-t w") 'transpose-words)
  (global-set-key (kbd "M-t s") 'transpose-sexps)
  (global-set-key (kbd "M-t p") 'transpose-params)

  ;; Killing text -- I don't use this, commenting out
  ;; (global-set-key (kbd "C-S-k") 'kill-and-retry-line)
  ;; (global-set-key (kbd "C-w") 'kill-region-or-backward-word)
  ;; (global-set-key (kbd "C-c C-w") 'kill-to-beginning-of-line)

  ;; Use M-w for copy-line if no active region
  (global-set-key (kbd "M-w") 'save-region-or-current-line)
  ;; (global-set-key (kbd "s-w") 'save-region-or-current-line)
  (global-set-key (kbd "M-W") (lambda (save-region-or-current-line 1)))

  ;; Make shell more convenient, and suspend-frame less
  (global-set-key (kbd "C-z") 'shell)

  (global-set-key (kbd "C-x M-z") 'suspend-frame)

  ;; Zap to char -- npt usoing right now so commenting out
  ;; (global-set-key (kbd "M-z") 'zap-up-to-char)
  ;; (global-set-key (kbd "s-z") (lambda (char) (interactive "cZap up to char backwards: ") (zap-up-to-char -1 char)))

  ;; (global-set-key (kbd "M-Z") (lambda (char) (interactive "cZap to char: ") (zap-to-char 1 char)))
  ;; (global-set-key (kbd "s-Z") (lambda (char) (interactive "cZap to char backwards: ") (zap-to-char -1 char)))

  ;; Jump to a definition in the current file. (This is awesome)
  ;; I'm using this keybinding for spell correcton though. Need to set to something else.

  ;; we don't use ido ever!
  ;; (global-set-key (kbd "C-x C-h") 'ido-imenu)

  ;; Perform general cleanup.
  (global-set-key (kbd "C-c n") 'cleanup-buffer)
  (global-set-key (kbd "C-c C-n") 'cleanup-buffer)
(global-unset-key (kbd "C-c C-n") ) ;; I do not ever use this stuff!!
  (global-set-key (kbd "C-c C-<return>") 'delete-blank-lines)

#+END_SRC

#+RESULTS:
: delete-blank-lines

** More UI and Misc
- turn on visual-line-mode 
- *DON'T* use auto-complete
- use abbrev-mode (spell correction mostly)
- word-count
- integrate abbrev and ispell
- windows
- *DON'T* use hippie expand
- anzu, which is a really neat feature.  
- make file name completion case insensitive (BIG usability improvement!)
- a function to add path of current buffer into kill ring, ~mwp-get-buff-path~
#+BEGIN_SRC emacs-lisp
  ;; add ful lpath of current buffer to kill ring
  (defun mwp-get-buf-path ()
    (interactive)
    (kill-new (buffer-file-name)))

  ;; modeline appearance
  ;; this enables smart-mode-line, which colorizes the modeline.
  ;; it's pretty helpful.  
  ;; (sml/setup)
  ;; (setq sml/no-confirm-load-theme t)

    ;;;; visual line mode
  ;; enable visual line mode for text modes
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
  (remove-hook 'org-mode-hook (lambda () (visual-line-mode -1)))

 
  ;;; use accents dammit!
  ;; this is a little imperfect but I still need it
  (use-package iso-transl)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
    ;;;; word counts
  ;; word counts
  (defun wc (&optional start end)
    "Prints number of lines, words and characters in region or whole buffer."
    (interactive)
    (let ((n 0)
          (start (if mark-active (region-beginning) (point-min)))
          (end (if mark-active (region-end) (point-max))))
      (save-excursion
        (goto-char start)
        (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
      (message "%3d %3d %3d" (count-lines start end) n (- end start))))

  ;; unfilling paras
    ;;; switching window configurations
  (defun toggle-windows-split()
    "Switch back and forth between one window and whatever split of windows we might have in the frame. The idea is to maximize the current buffer, while being able to go back to the previous split of windows in the frame simply by calling this command again."
    (interactive)
    (if (not(window-minibuffer-p (selected-window)))
        (progn
          (if (< 1 (count-windows))
              (progn
                (window-configuration-to-register ?u)
                (delete-other-windows))
            (jump-to-register ?u))))
    (my-iswitchb-close))

  ;; Then, the convenient key binding:
  (define-key global-map (kbd "C-`") 'toggle-windows-split)
  (define-key global-map (kbd "C-~") 'toggle-windows-split)
  (define-key global-map (kbd "C-|") 'toggle-windows-split) ; same key, on a spanish keyword mapping since I commute a lot between both

  (defun back-window ()
    (interactive)
    (other-window -1))
  (define-key global-map (kbd "C-x O") 'back-window)

    ;;;; unfill paragraph
  ;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
  (defun unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

    ;;;
  ;; hippie expand
  ;; (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+END_SRC

#+RESULTS:
: unfill-paragraph

** Copying buffer file location
from [[https://stackoverflow.com/questions/2416655/file-path-to-clipboard-in-emacs][stack overflow]]. 
#+BEGIN_SRC emacs-lisp
(defun mwp-copy-file-name-to-clipboard ()
  "Put the current file name on the clipboard"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (with-temp-buffer
        (insert filename)
        (clipboard-kill-region (point-min) (point-max)))
      (message filename))))
#+END_SRC

#+RESULTS:
: mwp-copy-file-name-to-clipboard
** making flycheck prettier
FLychec double arrow drives me crazy. Here's a bit of a fix:
#+BEGIN_SRC emacs-lisp
(define-fringe-bitmap 'flycheck-fringe-bitmap-ball
  (vector #b000000000
          #b000000000
          #b000000000
          #b000000000
          #b000111000
          #b001111100
          #b011111100
          #b111111111
          #b111111111
          #b111111111
          #b011111100
          #b001111000
          #b000110000
          #b000000000
          #b000000000
          #b000000000
          #b000000000
          #b000000000))

(define-fringe-bitmap 'flycheck-fringe-bitmap-ball
  (vector #b000000000000
          #b000000000000
          #b000001100000
          #b000111111000
          #b001111111100
          #b011111111110
          #b111111111111
          #b011111111110
          #b001111111100
          #b000111111000
          #b000011110000
          #b000001100000
          #b000000000000
          #b000000000000
          #b000000000000))

(flycheck-define-error-level 'error
  :severity 100
  :compilation-level 2
  :overlay-category 'flycheck-error-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-ball
  :fringe-face 'flycheck-fringe-error
  :error-list-face 'flycheck-error-list-error)

(flycheck-define-error-level 'warning
  :severity 10
  :compilation-level 1
  :overlay-category 'flycheck-warning-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-ball
  :fringe-face 'flycheck-fringe-warning
  :error-list-face 'flycheck-error-list-warning)

(flycheck-define-error-level 'info
  :severity -10
  :compilation-level 0
  :overlay-category 'flycheck-info-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-ball
  :fringe-face 'flycheck-fringe-info
  :error-list-face 'flycheck-error-list-info)

#+END_SRC

** some random, orphaned variable values.
print-length and file-name-completion-ignore-case
#+BEGIN_SRC emacs-lisp
  ;; this corrects an error I used to have. 
  (setq print-length 10000)


  ;; makes file name completion in the minibuffer case-insensitive
  (setq read-file-name-completion-ignore-case t)
#+END_SRC

#+RESULTS:
: t

This bit here comes from http://timothypratley.blogspot.ca/2015/07/seven-specialty-emacs-settings-with-big.html
Rainbow-delimiters for easily finding excess parens. Not sure I really need it.  [[https://github.com/Fanael/rainbow-delimiters][

github]]


#+BEGIN_SRC emacs-lisp

  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    ;;:config
    ;; 
    ;; (set-face-attribute 'rainbow-delimiters-unmatched-face nil
    ;;                     :foreground 'unspecified
    ;;                     :inherit 'error)
    )
#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode | beginend-prog-mode | paredit-or-smartparens |

*** Double Caps correction.
:PROPERTIES:
:EXPORT_FILE_NAME: double-caps-correction
:END:
The  the
Stolen from [[http://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type/13975#13975][here]] and also Elndless Parentheses
#+BEGIN_SRC emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (let ((words (if subword-mode 2 1))) (capitalize-word words))))))

;; (add-hook 'pre-abbrev-expand-hook #'dcaps-to-scaps nil 'local)
;; (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
;; (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (progn
        (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
        ;; (add-hook 'pre-abbrev-expand-hook #'dcaps-to-scaps nil 'local)
)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)
    ;; (remove-hook 'pre-abbrev-expand-hook #'dcaps-to-scaps 'local)
    ))

 (add-hook 'text-mode-hook #'dubcaps-mode)
    
#+END_SRC

#+RESULTS:
| dubcaps-mode | turn-on-visual-line-mode | electric-pair-local-mode | text-mode-hook-identify |

*** indent buffer!
stolen from [[http://emacsredux.com/blog/2013/03/27/indent-region-or-buffer/][Emacs Redux]]
I'd forgotten I had this.  Pretty sweet
#+BEGIN_SRC emacs-lisp
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (progn
          (indent-region (region-beginning) (region-end))
          (message "Indented selected region."))
      (progn
        (indent-buffer)
        (message "Indented buffer.")))))
(global-set-key (kbd "C-M-\\") 'indent-region-or-buffer)
#+END_SRC

#+RESULTS:
: indent-region-or-buffer

*** Easy-kill
I'm trying out the easy-kill package, which lets you cut or copy the current line just using the kill ring.  

I don't really do this.  It's cool though, so won't remove.
See [[http://pragmaticemacs.com/emacs/cut-or-copy-current-line-with-easy-kill/][this post]]. 
#+BEGIN_SRC emacs-lisp
(global-set-key [remap kill-ring-save] 'easy-kill)

#+END_SRC

#+RESULTS:
: easy-kill

** STARTED mode line improvements
Mostly this just laods the diminish package and adds some stuff to it
#+begin_src emacs-lisp
 ;; actually diminish is loaded above, just being configured here, osmewhat wierdly. 
  ;; these need to be moved to the appropriate other declarations. sigh. 
  (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
  (eval-after-load "eldoc" '(diminish 'eldoc-mode))
  (eval-after-load "paredit" '(diminish 'paredit-mode))
  (eval-after-load "tagedit" '(diminish 'tagedit-mode))
  (eval-after-load "elisp-slime-nav" '(diminish 'elisp-slime-nav-mode))
  (eval-after-load "skewer-mode" '(diminish 'skewer-mode))
  (eval-after-load "skewer-css" '(diminish 'skewer-css-mode))
  (eval-after-load "skewer-html" '(diminish 'skewer-html-mode))
  (eval-after-load "smartparens" '(diminish 'smartparens-mode))
  (eval-after-load "guide-key" '(diminish 'guide-key-mode))

  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))

  (rename-modeline "js2-mode" js2-mode "JS2")
  (rename-modeline "clojure-mode" clojure-mode "Clj")

#+end_src


** Working with Macros
#+BEGIN_SRC emacs-lisp
;;; macros
;;;; mwp/org-insert-example
(fset 'mwp/org-insert-example
   [?# ?+ ?B ?E ?G ?I ?N ?_ ?E ?X ?A ?M ?P ?L ?E return return ?# ?+ ?E ?N ?D ?_ ?E ?X ?A ?M ?P ?L ?E up])

(global-set-key (kbd "C-c M-2") 'mwp/org-insert-example)
;;;; mwp/org-insert-quote
(fset 'mwp/org-insert-quote
   [?# ?+ ?B ?E ?G ?I ?N ?_ ?Q ?U ?O ?T ?E return return ?# ?+ ?E ?N ?D ?_ ?Q ?U ?O ?T ?E up])

(global-set-key (kbd "C-c M-1") 'mwp/org-insert-quote)

;;;; mwp/org-insert-iframe
(fset 'mwp/org-insert-iframe
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([35 43 98 101 103 105 110 95 104 116 109 108 return 60 105 102 114 97 109 101 32 119 105 100 116 104 61 34 56 48 48 112 120 right 32 104 101 105 103 104 116 61 34 52 53 48 112 120 right 32 115 114 99 61 34 right 62 60 47 105 102 114 97 109 101 62 return 35 61 backspace 43 101 110 100 95 104 116 109 108 return up left left left left left left left left left left left left] 0 "%d")) arg)))

;; (global-set-key (kbd "C-c M-0") 'mwp/org-insert-iframe)
;;;; save a macro
;; keyboard macro function
(defun save-macro (name)                  
  "save a macro. Take a name as argument
     and save the last defined macro under 
     this name at the end of your .emacs"
  (interactive "SName of the macro :")  ; ask for the name of the macro    
  (kmacro-name-last-macro name)         ; use this name for the macro    
  (find-file "/home/matt/.emacs")                   ; open ~/.emacs or other user init file 
  (goto-char (point-max))               ; go to the end of the .emacs
  (newline)                             ; insert a newline
  (insert-kbd-macro name)               ; copy the macro 
  (newline)                             ; insert a newline
  (switch-to-buffer nil))               ; return to the initial buffer

;; Keyboard macro to insert quotes. not bound yet to anything
(fset 'insert_quote

      (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([35 43 66 69 71 73 78 95 81 85 79 84 69 return return 35 43 69 78 68 95 81 85 79 84 69 up] 0 "%d")) arg)))

(fset 'mwp/org-insert-js
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([35 43 66 69 71 73 78 95 83 82 67 32 108 97 110 103 117 97 103 101 61 106 97 118 97 115 99 114 105 112 116 return return 35 43 69 78 68 95 83 82 67 up] 0 "%d")) arg)))

(fset 'mwp/org-insert-html
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([35 43 66 69 71 73 78 95 83 82 67 32 104 116 109 108 13 13 35 43 69 78 68 95 83 82 67 up] 0 "%d")) arg)))

;;; fix html export xml declaration so OOo can read it
(setq org-export-html-xml-declaration
      '(("html" . "")
        ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\";
?>")))

(fset 'grading-template
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([42 42 32 return 124 32 79 114 103 97 110 105 122 97 116 105 111 110 32 124 32 124 32 backspace tab 67 108 97 114 105 116 121 32 111 102 32 84 104 101 115 105 115 tab tab 80 114 101 115 101 110 116 97 116 105 111 110 32 111 102 32 69 118 105 100 101 110 99 101 32 124 32 124 backspace backspace backspace backspace tab tab 71 114 97 109 109 97 114 32 97 110 100 32 83 112 101 108 108 105 110 103 tab tab 83 116 121 108 101 tab tab 67 105 116 97 116 105 111 110 115 tab tab 70 117 114 116 104 101 114 32 67 111 109 109 101 110 116 115 tab tab 71 114 97 100 101 tab up up up up up up up up 32] 0 "%d")) arg)))

#+END_SRC

#+RESULTS:
| lambda | (&optional arg) | Keyboard macro. | (interactive p) | (kmacro-exec-ring-item '([42 42 32 return 124 32 79 114 103 97 110 105 122 97 116 105 111 110 32 124 32 124 32 backspace tab 67 108 97 114 105 116 121 32 111 102 32 84 104 101 115 105 115 tab tab 80 114 101 115 101 110 116 97 116 105 111 110 32 111 102 32 69 118 105 100 101 110 99 101 32 124 32 124 backspace backspace backspace backspace tab tab 71 114 97 109 109 97 114 32 97 110 100 32 83 112 101 108 108 105 110 103 tab tab 83 116 121 108 101 tab tab 67 105 116 97 116 105 111 110 115 tab tab 70 117 114 116 104 101 114 32 67 111 109 109 101 110 116 115 tab tab 71 114 97 100 101 tab up up up up up up up up 32] 0 %d) arg) |

 
* Organize my life
The very extensive org-mode configuration.  whew.   
** STARTED Loading, hooks, minor modes
A couple of things to note here:
- pinned to manual, load-path set to the site of a "make-installed" git version
- uses Kaushal's org-version-select, from I think, ~setup-org.el~ in his init.el repo
- sets a large number of variables

*EDITED <2019-04-05 Fri>:* Add a custom org agenda to search current buffer only for *failing* marks - -this is for use in org-learning

#+BEGIN_SRC emacs-lisp
  (defvar modi/org-version-select 'dev
    "Variable to choose the version of Org to be loaded.
      Valid values are `dev', `elpa' and `emacs'.

      When set to `dev', the development version of Org built locally
      is loaded.
      When set to `elpa', Org is installed and loaded from Org Elpa.
      When set to `emacs', the Org version shipped with Emacs is used.

      The value is defaulted to `elpa' as few things in this config
      need Org version to be at least 9.x.")
  ;; Mark packages to *not* to be updated
  ;; http://emacs.stackexchange.com/a/9342/115
  (defvar modi/package-menu-dont-update-packages '(org)
    "List of packages for which the package manager should not look for updates.
      Example: '(org org-plus-contrib).")
  ;; Do not upgrade Org using the package manager if it's set to *not* use the
  ;; Elpa version of Org.
  (unless (eq modi/org-version-select 'elpa)
    (add-to-list 'modi/package-menu-dont-update-packages 'org-plus-contrib))



  (defun modi/package-menu-remove-excluded-packages (orig-fun &rest args)
    "Remove the packages listed in `modi/package-menu-dont-update-packages' from
      the `tabulated-list-entries' variable."
    (let ((included (-filter
                     (lambda (entry)
                       (let ((pkg-name (package-desc-name (car entry))))
                         (not (member pkg-name modi/package-menu-dont-update-packages))))
                     tabulated-list-entries)))
      (setq-local tabulated-list-entries included)
      (apply orig-fun args)))
  (advice-add 'package-menu--find-upgrades :around #'modi/package-menu-remove-excluded-packages)
  ;; (advice-remove 'package-menu--find-upgrades #'modi/package-menu-remove-excluded-packages)
  (defvar modi/default-lisp-directory "/usr/share/emacs/27.0.50/lisp/"
    "Directory containing lisp files for the Emacs installation.

      This value must match the path to the lisp/ directory of your
      Emacs installation.  If Emacs is installed using
      --prefix=\"${PREFIX_DIR}\" this value would typically be
      \"${PREFIX_DIR}/share/emacs/<VERSION>/lisp/\".")

  (defvar org-dev-lisp-directory "/home/matt/src/org-mode/emacs/site-lisp/org"
    "Directory containing lisp files for dev version of Org.

      This value must match the `lispdir' variable in the Org local.mk.
      By default the value is \"$prefix/emacs/site-lisp/org\", where
      `prefix' must match that in local.mk too.")

  (defvar org-dev-info-directory "/home/matt/src/org-mode/info"
    "Directory containing Info manual file for dev version of Org.
      This value must match the `infodir' variable in the Org local.mk.")

  (when (and org-dev-lisp-directory
             org-dev-info-directory)
    (with-eval-after-load 'package
      ;; If `modi/org-version-select' is *not* `emacs', remove the Emacs
      ;; version of Org from the `load-path'.
      (unless (eq modi/org-version-select 'emacs)
        ;; Remove Org that ships with Emacs from the `load-path'.
        (let ((default-org-path (expand-file-name "org" modi/default-lisp-directory)))
          (setq load-path (delete default-org-path load-path))))

      ;; If `modi/org-version-select' is *not* `elpa', remove the Elpa
      ;; version of Org from the `load-path'.

      (unless (eq modi/org-version-select 'elpa)
        (dolist (org-elpa-install-path (directory-files-recursively
                                        package-user-dir
                                        "\\`org\\(-plus-contrib\\)*-[0-9.]+\\'"
                                        :include-directories))
          (setq load-path (delete org-elpa-install-path load-path))
          ;; Also ensure that the associated path is removed from Info
          ;; search list.
          (setq Info-directory-list (delete org-elpa-install-path Info-directory-list))))

      (let ((dev-org-path (directory-file-name org-dev-lisp-directory))
            (dev-org-info (directory-file-name org-dev-info-directory)))
        (if (eq modi/org-version-select 'dev)
            (progn
              (add-to-list 'load-path dev-org-path)
              ;; It's possible that `org-dev-info-directory' is set to an
              ;; unconventional value, in which case, it will not be
              ;; automatically added to `Info-directory-alist'. So to ensure
              ;; that the correct Org Info is used, add it to
              ;; `Info-directory-alist' manually.
              (add-to-list 'Info-directory-list dev-org-info))
          ;; If `modi/org-version-select' is *not* `dev', remove the
          ;; development version of Org from the `load-path'.
          (setq load-path (delete dev-org-path load-path))
          (with-eval-after-load 'info
            ;; Also ensure that the associated path is removed from Info search
            ;; list.
            (setq Info-directory-list (delete dev-org-info Info-directory-list)))))))


  (use-package org
    :ensure t
    :load-path "/home/matt/src/org-mode/emacs/site-lisp/org"
    :pin manual
    ;; :load-path (org-lisp org-contrib)
    :preface
    (setq org-tempo-keywords-alist nil)
    ;;:init
    ;;(setq org-export-backends '(ascii beamer html hugo icalendar md gfm reveal latex odt org))
    :hook
    ((org-mode . (lambda () (flyspell-mode 1)))
     (org-mode . turn-off-auto-fill))
    :mode ("\\.org" . org-mode)
    :bind 
    (("C-c l" . 'org-store-link)
     ("C-c a" . 'org-agenda))
    :commands (org-mode org-capture org-agenda )
    :config
    (message "at the beginning of config section oforg-mode use-package")
    (display-warning 'org-mode "at the beginning of config section oforg-mode use-package" :debug)

    ;; Targets include this file and any file contributing to the agenda - up to 5 levels deep
    (setq org-refile-targets
          (quote ((org-agenda-files :maxlevel . 5) (nil :maxlevel . 5)
                  ("/home/matt/org/.org2blog.el" :maxlevel . 1)
                  ("/home/matt/Dropbox/Work/History/HackingHistory/Grades.org" :maxlevel . 5))))

    (defun add-pcomplete-to-capf ()
      (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))

    (add-hook 'org-mode-hook #'add-pcomplete-to-capf)
    ;; Targets start with the file name - allows creating level 1 tasks
    (setq org-refile-use-outline-path (quote file))

    ;; Targets complete in steps so we start with filename, TAB shows the next level of targets etc
    (setq org-outline-path-complete-in-steps t)

    ;; Allow refile to create parent tasks with confirmation
    (setq org-refile-allow-creating-parent-nodes (quote confirm))
    (require 'ox)
    (load  "~/src/org-mode/emacs/site-lisp/org/ox-md")
    (with-eval-after-load "ox-md" 
      (require 'ox-gfm)
      (add-to-list 'org-export-backends 'md)
      (add-to-list 'org-export-backends 'gfm)
      (load "~/src/ox-slack/ox-slack.el") ;; (use-package ox-slack
           ;; :load-path "~/src/ox-slack"
           ;; :pin manual
           ;; :defer nil
           ;; ;; :preface
           ;; ;; (require 'ox-md)
           ;; ;; (require 'ox-gfm)
           ;; ;; :after (org )
           ;; ;; :bind
           ;; ;; ("C-c W s" . org-slack-export-to-clibpoard-as-slack)
           ;; )
)

    )
  ;; agenda config
  (use-package org-agenda
    :after org
    :config
    ;; agenda diary stuff
    (setq org-agenda-diary-file "~/Dropbox/GTD/diary.org")
    (setq org-agenda-include-diary t)

    (setq org-agenda-custom-commands
          '(("g" . "GTD contexts")
            ("ge" "email" tags-todo "email/+ACTION")
            ("gc" "Computer" tags-todo "computer/+ACTION")
            ("go" "Office" tags-todo "office/+ACTION")
            ("gp" "Phone" tags-todo "phone/+ACTION")
            ("gh" "Home" tags-todo "home/+ACTION")
            ("gr" "Errands" tags-todo "errand/+ACTION")
            ("E" "EDGI Tasks" tags "edgi")
            ("f" "Failing Students" tags "+GRADE=0")
            ("G" "GTD Block Agenda"
             ((tags-todo "phone/+ACTION")
              (tags-todo "office/+ACTION")
              (tags-todo "email/+ACTION")
              (tags-todo "computer/+ACTION")
              (tags-todo "home/+ACTION")
              (tags-todo "errand/+ACTION")
              (tags-todo "-phone-office-email-computer-home-office/+ACTION"))
             nil                      ;; i.e., no local settings
             ("~/next-actions.html")) ;; exports block to this file with C-c a e
            ;; ("T" "Teaching Block Agenda"
            ;;  ((tags-todo "phone+teaching/+ACTION")
            ;;   (tags-todo "office+teaching/+ACTION")
            ;;   (tags-todo "email+teaching/+ACTION")
            ;;   (tags-todo "computer+teaching/+ACTION")
            ;;   (tags-todo "home+teaching/+ACTION")
            ;;   (tags-todo "errand+teaching/+ACTION")
            ;;   (tags-todo "-phone-office-email-computer-home-office+teaching/+ACTION"))
            ;;  nil                      ;; i.e., no local settings
            ;;  ("~/next-actions.html"))
            ;; exports block to this file with C-c a e
            ("H" "GTD Block Agenda"
             ((tags-todo "+history+phone/+ACTION|BLOCKED")
              (tags-todo "+history+office/+ACTION|BLOCKED")
              (tags-todo "+history+email/+ACTION|BLOCKED")
              (tags-todo "+history+computer/+ACTION|BLOCKED")
              (tags-todo "+history+home/+ACTION+|BLOCKED")
              (tags-todo "+history+errand/+ACTION|BLOCKED")
              (tags-todo "+history-phone-office-email-computer-home-office/+ACTION|BLOCKED"))
             nil                              ;; i.e., no local settings
             ("~/history-next-actions.html")) ;; exports block to this file with C-c a e
            ("W" "WAITING block Agenda"
             ((tags-todo "phone/+WAITING")
              (tags-todo "email/+WAITING")
              (tags-todo "computer/+WAITING")
              (tags-todo "office/+WAITING")
              (tags-todo "home/+WAITING")
              (tags-todo "errand/+WAITING"))
             nil                      ;; i.e., no local settings
             ("~/next-actions.html")) ;; exports block to this file with C-c a e
            ;; ..other commands here
            ;; ("t" agenda "Teaching Agenda"
            ;;  (( org-agenda-filter-preset '("+teaching") )  ) )
            ("p" "Projects" todo "PROJECT")
            )))


      ;;;; Org-mode hooks
  ;; (add-hook 'org-mode-hook
  ;;   (lambda()
  ;;     (flyspell-mode 1)))
  ;; (add-to-list 'auto-mode-alist '("\\.org" . org-mode))

  ;; still need to load org2blog
  (use-package xml-rpc
    :load-path "~/src/xml-rpc"
    :no-require)
  (use-package org2blog
    :after (:all xml-rpc (:any org org-plus-contrib))
    :load-path  ("/home/matt/src/org2blog" "/home/matt/src/xml-rpc"))

  (use-package org2blog-autoloads
    :after org2blog
    )
  ;; this should turhn auto-fill off?
  ;; (add-hook 'org-mode-hook 'turn-off-auto-fill)
  ;;org-mouse.el -- an extra
  (use-package org-mouse
    :after (:any org org-plus-contrib))

  (use-package ox-odt
    :after (:any org org-plus-contrib)
    :defer 10
    :config
    (setq org-odt-styles-dir "/home/matt/src/org-mode/etc/styles/")
    ;; (setq org-odt-schema-dir "/home/matt/.emacs.d/Templates/")
    (setq org-odt-styles-file "/home/matt/.emacs.d/Templates/New113Syllabus.odt")
    ;; this needs to be set here, but the fn definition is actually below
    (add-to-list 'org-export-filter-timestamp-functions 'matt-org-export-filter-timestamp-function)
    )
#+END_SRC

#+RESULTS:


separate the exports block to try to ifgure out what the hell.  
#+BEGIN_SRC emacs-lisp
      ;; (use-package ox
      ;;   :ensure t
      ;;   :load-path "/home/matt/src/org-mode/emacs/site-lisp/org/ox.el"
      ;;   :pin manual
      ;;   )


      ;;     ;;;; markdown export
      ;; (use-package ox-md
      ;;   :after (org)
      ;;   ;;:defer 7
      ;;   :config
      ;;   (add-to-list 'org-export-backends 'md))
      ;; ;;(setq org-export-backends '(ascii beamer html hugo icalendar md gfm reveal latex odt org)))
      ;; ;; (use-package ox-gfm :after (:any org org-plus-contrib))


      ;; (use-package ox-gfm
      ;;   :after (org)
      ;;   ;;:defer 9
      ;;   (add-to-list 'org-export-backends 'gfm))

    ;; (require 'ox-md)
    ;; ;;( org-export-register-backend 'md)
    ;; (use-package ox-md
    ;; :load-path "~/src/org-mode/emacs/site-lisp/org"
    ;; :defer nil
    ;; :after org
    ;; :config

    ;; )

    ;; (use-package ox-gfm
    ;; :ensure t
    ;; :defer nil
    ;; :after org
    ;; :config
    ;; ( org-export-register-backend 'gfm)
    ;; )

#+END_SRC

#+RESULTS:
: ox-gfm

** DONE Using custom id's 
We want to use custom_id properties in all headlines if poss b/c it's just way better.
Here's a partial solution, stolen from [[https://writequit.org/articles/emacs-org-mode-generate-ids.html#the-solution][writequit.org]] and not really fully satisfying to me since the id's are opaque:

#+BEGIN_SRC emacs-lisp
(use-package org-id
  :after org
  :config
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (defun eos/org-custom-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
    (interactive)
    (org-with-point-at pom
      (let* ((id (org-entry-get nil "CUSTOM_ID"))
             (hinit (org-get-heading t t))
             (headline (downcase
                       (replace-regexp-in-string "[\"\*\/\!]" ""
                                                 (replace-regexp-in-string " " "-"
                                                                           (if (and (> (length hinit) 9) (string= "COMMENT " (substring hinit 0 8))) 
                                                                             (substring hinit  8 nil)
                                                                             (org-get-heading)))))))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (concat headline "-" (substring (org-id-new 'none) 0 4)))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
          id)))))

  (defun eos/org-add-ids-to-headlines-in-file ()
    "Add CUSTOM_ID properties to all headlines in the
   current file which do not already have one."
    (interactive)
    (org-map-entries (lambda () (eos/org-custom-id-get (point) 'create)))))
#+END_SRC

#+RESULTS:
: eos/org-add-ids-to-headlines-in-file
** Workflow, agenda, refiling, tasks
:PROPERTIES:
:ID:       7a35857a-8676-46d6-a243-4634c9676dea
:END:
Added <2016-10-25 Tue>: new capture template for email

Added <2016-10-27 Thu>: Custom colors for intermediate ("started" or "In progress" states);. See [[http://orgmode.org/manual/Faces-for-TODO-keywords.html][the manual]].  

Added <2016-11-15 Tue> org-protocol-capture-html

Added <2017-01-11 Wed> capture template for appointments in google-calendar

Changed <2018-10-16 Tue> incorporate capture templates into ~use-package~ invocation for ~org-protocol-capture-html~. 

#+BEGIN_SRC emacs-lisp
  (use-package org-protocol
    :after (:any org org-plus-contrib))
  (use-package org-protocol-capture-html
    :after org-protocol
    :load-path  "/home/matt/src/org-protocol-capture-html"

    :config
    (setq org-capture-templates 
          '(
            ("t" "Todo Items" )
            ("tt" "Teaching Todo with Schedule & Tags set" entry (file+olp "~/Dropbox/GTD/gtd.org" "Tasks" "Teaching") "* ACTION %^{Description}  %^G:teaching:\nSCHEDULED:%(org-insert-time-stamp (org-read-date nil t \".+1d\"))%?")
            ("tx" "Other Todo entries" entry (file+headline "~/Dropbox/GTD/gtd.org" "Tasks") "* ACTION %^{Description}  %^G\nSCHEDULED:%(org-insert-time-stamp (org-read-date nil t \".+1d\"))%? \n %i \n %l") 
            ("th" "History" entry (file+olp "~/Dropbox/GTD/gtd.org" "Tasks" "History Dept") "* ACTION %^{Description}  %^G\nSCHEDULED:%(org-insert-time-stamp (org-read-date nil t \".+1d\"))%?")     
            ("p" "Password" entry (file "~/GTD/Keep-it-safe.org.gpg") "* %^{Description} \n SITE: %^{URL} \n USER:%^{USER} \n PASS:%^{PASS}\n%? \n")
            ("j" "Journal" entry (file+datetree "~/Dropbox/GTD/Reference.org") "* %?
                    Entered on %U
                    %i
                    %a")
            ("m" "mail-todo" entry (file+headline "~/Dropbox/GTD/Reference.org" "Tasks")
             "* ACTION Reply to  %:fromname %? about %a :email:\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")
            ("a" "Appointment" entry (file  "~/Dropbox/GTD/gcal.org" ) "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
            ("w" "Web site" entry
             (file+headline  "~/Dropbox/GTD/Reference.org" "Web")
             "* %a :website:\n\n%U %?\n\n%:initial")
            ))
        ;;;; add some workflow states
    (setq org-todo-keywords
          '((sequence "ACTION(a)" "WAITING(w)" "IN PROGRESS(p)" "BLOCKED(b)" "|" "DONE(d)" "WON'T DO(o)")
            (sequence "PROJECT(p)" "SOMEDAY(s)" "MAYBE(m)" "|" "COMPLETE(c)")))

      ;;;; recolor someo f those states
    (setq org-todo-keyword-faces
          '(("ACTION" . org-warning) ("IN PROGRESS" . "dark orange") ("WAITING" . "dark orange")
            ))
  )
      (define-key global-map "\C-cc" 'org-capture)
    ;;(add-to-list 'load-path "/home/matt/src/org-protocol-capture-html")
    ;;(require 'org-protocol-capture-html)


      ;;; REFILING
      ;; Use IDO for target completion
      ;; (setq org-completion-use-ido t)
      ;; stuff from http://www.jboecker.de/2010/04/14/general-reference-filing-with-org-mode.html#sec-1 
      ;; for org-mode remember integration


      ;;; still more agenda
      (defadvice org-agenda-add-entry-to-org-agenda-diary-file
          (after add-to-google-calendar)
        "Add a new Google calendar entry that mirrors the diary entry just created by
      org-mode."
        (let ((type (ad-get-arg 0))
              (text (ad-get-arg 1))
              (d1 (ad-get-arg 2))
              (year1 (nth 2 d1))
              (month1 (car d1))
              (day1 (nth 1 d1))
              (d2 (ad-get-arg 3))
              entry dates)
          (if (or (not (eq type 'block)) (not d2))
              (setq dates (format "%d-%02d-%02d" year1 month1 day1))
            (let ((year2 (nth 2 d2)) (month2 (car d2)) (day2 (nth 1 d2)) (repeats (-
                                                                                   (calendar-absolute-from-gregorian d1)

                                                                                   (calendar-absolute-from-gregorian d2))))
              (if (> repeats 0)
                  (setq dates (format "%d-%02d-%02d every day for %d days" year1
                                      month1 day1 (abs repeats)))
                (setq dates (format "%d-%02d-%02d every day for %d days" year1 month1
                                    day1 (abs repeats))))
              ))
          (setq entry (format "/usr/bin/google calendar add --cal org \"%s on %s\"" text dates))
          (message entry)
          (if (not (string= "MYLAPTOPCOMPUTER" mail-host-address))
              (shell-command entry)
            (let ((offline "~/tmp/org2google-offline-entries"))
              (find-file offline)
              (goto-char (point-max))
              (insert (concat entry "\n"))
              (save-buffer)
              (kill-buffer (current-buffer))
              (message "Plain text written to %s" offline)))))
      (ad-activate 'org-agenda-add-entry-to-org-agenda-diary-file)

#+END_SRC

#+RESULTS:

** Exporting and Publishing
*** General
Some general options and fixes
#+BEGIN_SRC emacs-lisp
  ;;;; export options for org-mode
(setq org-export-with-section-numbers nil
      org-export-with-toc nil
      org-export-preserve-breaks nil
      org-export-email-info nil
      )
  ;;;; Timestamps in Exports
;; removing annoying brackets from timestamp on html export
;; with org-mode set to defer, this has to be added to the use-package :config declaration above 
;; (add-to-list 'org-export-filter-timestamp-functions 'matt-org-export-filter-timestamp-function)
(defun matt-org-export-filter-timestamp-function (timestamp backend info)
  "removes relevant brackets from a timestamp"
    (if (org-export-derived-backend-p backend 'html 'odt )
      (replace-regexp-in-string "&[lg]t;" "" timestamp)
    (replace-regexp-in-string "&[lg]t;\\|[<>]" "" timestamp))
  ;; (pcase backend
  ;;   ((or 'html 'wp 'odt 'reveal 'latex 'hugo 'huveal 'blackfriday 'md 'gfm )
  ;;    )

  ;;   )
  )


(defun org-export-filter-timestamp-remove-brackets (timestamp backend info)
  "removes relevant brackets from a timestamp"
  (cond
   ((org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string "[<>]\\|[][]" "" timestamp))
   ((or (org-export-derived-backend-p backend 'html) (org-export-derived-backend-p backend 'odt))
    (replace-regexp-in-string "&[lg]t;\\|[][]" "" timestamp))))

(eval-after-load 'ox '(add-to-list
                       'org-export-filter-timestamp-functions
                       'org-export-filter-timestamp-remove-brackets))
;; (when (or  (org-export-derived-backend-p backend 'html)(org-export-derived-backend-p backend 'odt)) 
;;   ;; unfortunatley I can't make emacs regexps work yet.  sigh.  
;;   ;; (replace-regexp-in-string "[][]" "" timestamp)
;;   (replace-regexp-in-string "&[lg]t;\\|[][]" "" timestamp)
;;   ;; (replace-regexp-in-string "&lt;" "" timestamp))


;; removing annoying brackets from timestamp on html export
;; (add-to-list 'org-export-filter-paragraph-functions 'matt-org-export-filter-paragraph-function)
;; (defun matt-org-export-filter-paragraph-function (paragraph backend info)
;;   "removes comments from export"
;;   (when (org-export-derived-backend-p backend 'html) 
;;     ;; unfortunatley I can't make emacs regexps work yet.  sigh.  
;;     (replace-regexp-in-string "^#\+.*$" "" paragraph)
;;     ;; (replace-regexp-in-string "&lt;" "" paragraph)
;; ))


#+END_SRC

#+RESULTS:
| matt-org-export-filter-timestamp-function | org-export-filter-timestamp-remove-brackets |

*** Creating and Publishing Presentations with Org-reveal
:PROPERTIES:
:ID:       o2b:cef9afbb-5bec-4b01-a32a-783315ffc727
:POST_DATE: [2015-07-11 Sat 10:20]
:POSTID:   13
:CATEGORY: emacs
:BLOG:     matt
:END:
For several years, I've been using Org-mode to compose slides for my lectures.  This method is great, because I get to work in plain-text and focus on the content of my lectures rather than animations; but it's meant that when I want to share my presentations with others, there's a certain amount of work involved as I move from a local copy on my computer to a web-based version. (This has largely been an issue because I sometimes /compose/ my lectures sitting in a café with lousy Internet, and I sometimes /give/ my lectures in a horrible classroom at U of T with terrible Internet reception.)  I've now largely solved this problem, though there is hopefully an improvement coming down the pipe which will make it even easier.  

Org-mode has the capacity to export to a number of slide-like formats, including the [[http://orgmode.org/worg/exporters/beamer/beamer-dual-format.html][LaTeX-based Beamer format]], which also makes good PDF presentations, a couple of Emacs-based presentation tools, and a number of HTML5 formats.  Since I teach about the web all the time, the HTML5 formats have always been the most appealing to me.  
**** Org-Reveal Setup
I have used and still very much like [[https://github.com/imakewebthings/deck.js/wiki][deck.js]] ([[https://github.com/cybercode/org-slides][exporter here]]), but have recently switched to [[https://github.com/yjwen/org-reveal][org-reveal]], which I really like a lot.  It's not part of the official org distribution, so installation and setup are a little more involved, but not difficult.  I just cloned the org-reveal and reveal.js repositories:
#+BEGIN_SRC sh :tangle no
cd ~/src
git clone https://github.com/hakimel/reveal.js.git
git clone https://github.com/yjwen/org-reveal.git
#+END_SRC

and put this in my ~emacs-init.el~:
#+BEGIN_SRC emacs-lisp
;; org-reveal
(use-package ox-reveal
  :after ox
  :load-path "~/src/org-reveal"
  :defer 12
  ;;:config
  :custom
 (org-reveal-center nil)
 (org-reveal-external-plugins '((klipse . "{src: '%splugin/klipse_reveal.js'}")))
 (org-reveal-extra-css "file:///home/matt/src/org-reveal/local.css")
 (org-reveal-history t)
 (org-reveal-klipse-css
  "https://sandbox.hackinghistory.ca/vendor/klipse/codemirror.css")
 (org-reveal-klipse-js
  "https://sandbox.hackinghistory.ca/vendor/klipse/klipse_plugin.min.js")
 (org-reveal-klipsify-src t)
 (org-reveal-margin "0.1")
 (org-reveal-mathjax t)
 (org-reveal-max-scale "1")
 (org-reveal-plugins '(classList markdown highlight zoom notes))
 (org-reveal-postamble nil)
 ;; (org-reveal-root "http://sandbox.hackinghistory.ca/Tools/reveal.js")
 (org-reveal-root "file:///home/matt/src/reveal.js")
 (org-reveal-theme "matt")
 (org-reveal-title-slide-template
   "<h1>%t</h1>
<h2>%a</h2>
<h2>%d</h2>
<p class=\"title-theme-choice\">(view this presentation in another theme: 
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/black.css')); return false;\">Black (default)</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/white.css')); return false;\">White</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/league.css')); return false;\">League</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/sky.css')); return false;\">Sky</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/beige.css')); return false;\">Beige</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/simple.css')); return false;\">Simple</a> 
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/serif.css')); return false;\">Serif</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/blood.css')); return false;\">Blood</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/night.css')); return false;\">Night</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/moon.css')); return false;\">Moon</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/solarized.css')); return false;\">Solarized</a>
				)	</p>
")
 (org-reveal-width "100%")
 (org-reveal-height "100%")

  )
;; (add-to-list 'load-path "~/src/org-reveal")
;; (require 'ox-reveal)
;; set local root

(use-package org-re-reveal
  :after ox
  ;;:load-path "~/src/org-re-reveal"
  :defer 12
  ;;:config
  :custom
 (org-re-reveal-center nil)
 (org-re-reveal-external-plugins '((klipse . "{src: '%splugin/klipse_reveal.js'}")))
 (org-re-reveal-extra-css "file:///home/matt/src/org-reveal/local.css")
 (org-re-reveal-history t)
 (org-re-reveal-klipse-css
  "https://sandbox.hackinghistory.ca/vendor/klipse/codemirror.css")
 (org-re-reveal-klipse-js
  "https://sandbox.hackinghistory.ca/vendor/klipse/klipse_plugin.min.js")
 (org-re-reveal-klipsify-src t)
 (org-re-reveal-margin "0.1")
 (org-re-reveal-mathjax t)
 (org-re-reveal-min-scale "1")
 (org-re-reveal-max-scale "1")
 (org-re-reveal-plugins '(classList markdown highlight zoom notes))
 (org-re-reveal-postamble nil)
 ;; (org-re-reveal-root "http://sandbox.hackinghistory.ca/Tools/reveal.js")
 (org-re-reveal-root "file:///home/matt/src/reveal.js")
 (org-re-reveal-theme "matt")
 (org-re-reveal-title-slide-template
   "<h1>%t</h1>
<h2>%a</h2>
<h2>%d</h2>
<p class=\"title-theme-choice\">(view this presentation in another theme: 
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/black.css')); return false;\">Black (default)</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/white.css')); return false;\">White</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/league.css')); return false;\">League</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/sky.css')); return false;\">Sky</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/beige.css')); return false;\">Beige</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/simple.css')); return false;\">Simple</a> 
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/serif.css')); return false;\">Serif</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/blood.css')); return false;\">Blood</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/night.css')); return false;\">Night</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/moon.css')); return false;\">Moon</a> -
<a href=\"#\" onclick=\"document.getElementById('theme').setAttribute('href',document.getElementById('theme').getAttribute('href').replace(/\\/[a-zA-Z]+\\.css/g,'/solarized.css')); return false;\">Solarized</a>
				)	</p>
")
 (org-re-reveal-width "100%")
 (org-re-reveal-height "100%")

  )
#+END_SRC

#+RESULTS:

That's all that's needed to get export working! I find it's really fast to prepare lectures.
**** ACTION Publishing

That's great for /giving/ lectures, and is all I really need at 9:55 when I'm trying to type my lecture and walk to class at the same time. But after lecture I want to put my slides somewhere my students can see them.  Even if I wanted to, it would be impossible for me to post to Blackboard, which turns these files into garbage.  What I want to do is publish them to the web; but I need to make sure that all the JS and CSS links are pointing to the web-based libraries and not my local copies, which of course no one but me can see.  To do this I had to make one small change to ~org-reveal.el~, which I have submitted as a [[https://github.com/yjwen/org-reveal/pull/125/files][pull request]].  This creates a new variable, ~org-reveal-extra-css~, which I can refer to in my own functions.  

Then I use org-mode's fantastic built-in [[http://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][Publishing functions]] to push my slides to a public website.  Publishing allows you to perform an export on many files, and customize the output in powerful ways that are mostly beyond me, actually.  Still, I have a setup that I like a lot. 

First, my ~org-publish-project-alist~, which defines the publishing targets.  Note especially the top part, which defines "meta-projects": for instance, I can publish all the slides and source files for all my classes with one command, ~M-x org-publish-projects [RET] courses~.  

*NOTE* this is totally not finished! check out [[http://emacs.stackexchange.com/questions/2259/how-to-export-top-level-headings-of-org-mode-buffer-to-separate-files][this stackexchange question about exporting top-level headings]] and [[http://emacs.stackexchange.com/questions/18324/publishing-a-single-file-via-org-publish][this simple but very helpful stackexchange about publsihing single files]]. Now it should be easy to set this up.  Would be nice to *also* check to see if anything has changed before exporting.. but that seems hard to manage.  

The next step is to modify publish-all to set new values for the relevant variables (single file, or whatever)

*EDIT <2017-06-24 Sat>:* adding publication for course websites base don Hugo.  Is currently an experiment.

*EDIT <2018-10-23 Tue> Somethings not working here, oops!*   
#+BEGIN_SRC emacs-lisp :tangle no

  (use-package ox-reveal
    :load-path "~/src/org-reveal"
    :config
    (setq org-publish-project-alist
          '(
            ("courses"
             :components ("dh" "rlg231" "inf1501"))
            ("rlg231"
             :components ("rlg231-lecture-slides" "rlg231-lecture-source"))
            ("dh"
             :components ("digital-history-lecture-slides" "digital-history-lecture-source"))
            ("inf1501"
             :components ("inf1501-lecture-slides" "inf1501-lecture-source"))

            ("rlg231-lecture-slides"
             :base-directory "~/RLG231/Lectures/"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/RLG231/Lectures/Slides"
             :recursive nil
             ;;:publishing-function org-export-all-for-publication
             :publishing-function mwp-org-reveal-publish-to-html
             :headline-levels 4     ; Just the default for this project.
             :exclude "AllLectures.org"
             :exclude-tags ("note" "noexport")
             ;; :include ["AllLectures.org"]
             :auto-preamble t)

            ("rlg231-lecture-source"
             :base-directory "~/RLG231/Lectures/"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/RLG231/Lectures/Source"
             :recursive nil
             ;; :publishing-function org-org-publish-to-org
             :publishing-function org-publish-attachment
             :preparation-function nil
             :completion-function nil
             :headline-levels 4     ; Just the default for this project.
             :exclude "AllLectures.org"
             ;;:include "AllLectures.org"
             ;; :exclude "LectureOutlines.org"
             :exclude-tags ("note" "noexport")
             :auto-preamble t)

            ("digital-history-lecture-source"
             :base-directory "~/DH/Lectures"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/DigitalHistory/Lectures/Source"
             :recursive nil
             :publishing-function org-publish-attachment
             :preparation-function 
             :completion-function 
             :headline-levels 4     ; Just the default for this project.
             ;; :exclude "LecturePlans.org"
             :exclude "LectureOutlines.org"
             ;;:include "LectureOutlines.org"
             :exclude-tags ("note" "noexport")
             :auto-preamble t)

            ("digital-history-lecture-slides"
             :base-directory "~/DH/Lectures"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/DigitalHistory/Lectures/Slides"
             :recursive nil
             :publishing-function mwp-org-reveal-publish-to-html
             :preparation-function 
             :completion-function 
             :headline-levels 4     ; Just the default for this project.
             ;; :exclude "LecturePlans.org"
             :exclude "LectureOutlines.org"
             ;;:include "LectureOutlines.org"
             :exclude-tags ("note" "noexport")
             :auto-preamble t)

            ("inf1501-lecture-slides"
             :base-directory "~/INF1501/Lectures/"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/INF1501/Lectures/Slides"
             :recursive t
             :publishing-function mwp-org-reveal-publish-to-html
             :headline-levels 4     ; Just the default for this project.
             :exclude "LectureOutlines.org"
             :exclude-tags ("note" "noexport")
             :auto-preamble t)

            ("inf1501-lecture-source"
             :base-directory "~/INF1501/Lectures/"
             :base-extension "org"
             :publishing-directory "/ssh:matt@shimano:/var/www/sandbox/INF1501/Lectures/Source"
             :recursive t
             :publishing-function org-org-publish-to-org
             :preparation-function nil
             :completion-function nil
             :headline-levels 4     ; Just the default for this project.
             :exclude "LecturePlans.org"
             ;; :exclude "LectureOutlines.org"
             :exclude-tags ("note" "noexport")
             :auto-preamble t)

            ("hacking-history-most"
             ;; Path to org files
             :base-directory "~/HackingHistory/"
             :base-extension "org"

             ;; Path to hugo project
             :publishing-directory "~/HackingHistory/hh-hugo/content/article"
             :recursive nil
             :include "dot-experiment.org"
             :publishing-function mwp-org-gfm-publish-to-md
             ;;:publishing-function org-
             )

            ("ww-slides"
             :base-directory "~/Wildwater/"
             :base-extension "org"
             :publishing-directory "~/Wildwater/ww-site/static/slides/"
             :recursive nil
             ;;:publishing-function org-export-all-for-publication
             ;; need to rewrite mwp-org-export-all-to-org for reveal
             ;; should be easy to figure out
             :publishing-function mwp-org-reveal-publish-to-html
             :headline-levels 4     ; Just the default for this project.
             :exclude ".*"
             :exclude-tags ("note" "noexport")
             :include ["Slides-and-notes.org"]
             :auto-preamble t)

            ("hugo-test"
             ;; Path to org files
             :base-directory "~/src/hugo-org/"
             :base-extension "org"

             ;; Path to hugo project
             :publishing-directory "~/src/hugo-content/"
             :recursive t
             :exclude "dot-experiment.org"
             :publishing-function mwp-org-publish-subtrees-to-gfm
             )

            ("hh-hugo-syl"
             :base-directory "~/HackingHistory/"
             :base-extension "org"
             :publishing-function org-hugo-publish-to-md
             :exclude "*"
             :include "His455Outline.org")
            ))

    ;; (defun org-export-all (backend)
    ;;     "Export all subtrees that are *not* tagged with :noexport: to
    ;;   seperate files.

    ;;   Subtrees that do not have the :EXPORT_FILE_NAME: property set
    ;;   are exported to a filename derived from the headline text."
    ;;     (interactive "sEnter backend: ")
    ;;     (let ((fn (cond ((equal backend "html") 'org-html-export-to-html)
    ;;                     ((equal backend "latex") 'org-latex-export-to-latex)
    ;;                     ((equal backend "org") 'org-org-export-to-org)
    ;;                     ((equal backend "reveal") 'org-reveal-export-to-html)
    ;;                     ((equal backend "pdf") 'org-latex-export-to-pdf)))
    ;;           (modifiedp (buffer-modified-p)))
    ;;       (save-excursion
    ;;         (set-mark (point-min))
    ;;         (goto-char (point-max))
    ;;         (org-map-entries
    ;;          (lambda ()
    ;;            (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
    ;;              (unless export-file
    ;;                (org-set-property
    ;;                 "EXPORT_FILE_NAME"
    ;;                 (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))

    ;;              (funcall fn nil t)
    ;;              (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
    ;;              (set-buffer-modified-p modifiedp)))
    ;;          "-noexport" 'region-start-level))))


    (defun mwp-publish-hh-site ()
      (interactive)
      (let* ((src-dir "~/HackingHistory/")
             (subtree-files '("Assignments.org" "Labs.org"))
             (single-items '("His455Outline.org"))
             )
        (dolist (single single-items)
          (save-window-excursion
            (find-file (concat src-dir single))`
            (org-hugo-export-to-md nil)))
        (dolist (sub subtree-files)
          (save-window-excursion
            (find-file (concat src-dir sub))
            (org-hugo-publish-subtree t)))
        (shell-command (format "%s %s" "hugo" "-s ~/HackingHistory/hugoplayground -t hh-courseware"))
        (shell-command (format "%s %s" "rsync" "-azvbP ~/HackingHistory/hugoplayground/public/ shimano:/var/www/2017.hackinghistory.ca"))))


    (defun mwp-publish-ww-site ()
      (interactive)
      (let* ((src-dir "~/WildWater/")
             (subtree-files '("Assignments.org"))
             (single-items '("Syllabus.org"))
             )
        (dolist (single single-items)
          (save-window-excursion
            (find-file (concat src-dir single))
            (org-hugo-export-to-md nil)))
        (dolist (sub subtree-files)
          (save-window-excursion
            (find-file (concat src-dir sub))
            (org-hugo-publish-subtree t)))
        (shell-command (format "%s %s" "hugo" "-s ~/WildWater/hugo-site -t hh-courseware"))
        (shell-command (format "%s %s" "rsync" "-azvbP ~/WildWater/hugo-site/public/ shimano:/var/www/2017.hackinghistory.ca"))))


    (defun org-html-publish-all-to-reveal (plist filename pub-dir)
      "Publish an org file to HTML.

        FILENAME is the filename of the Org file to be published.  PLIST
        is the property list for the given project.  PUB-DIR is the
        publishing directory.

        Return output file name."
      (org-publish-org-to 'reveal filename
                          (concat "." (or (plist-get plist :html-extension)
                                          org-html-extension
                                          "html"))
                          plist pub-dir))

    (defun mwp-org-export-all-to-org ()
      (interactive)
      (org-element-map (org-element-parse-buffer)'headline
        (lambda (headline)
          (let ((begin (org-element-property :begin headline))
                (level (org-element-property :level headline))
                (commentedp (org-element-property :commentedp headline))
                (tags (org-element-property :tags headline)))
            (unless (or (> level 1)
                        commentedp
                        (member "noexport" tags)
                        ;; I would prefer to get the exclude-tags dynamically but
                        ;; I'm not sure how to do it properly -- need to access exclude-tags somehow
                        ;; (cl-loop for k in (plist-get options :exclude-tags)
                        ;;          thereis (member k  tags))
                        )
              (save-excursion
                (goto-char begin)
                (org-org-export-to-org nil t )))))))

    (defun mwp-export-rlg231 ()
      "open alllectures.org and export/publish all files"
      (interactive)
      (save-excursion
        (find-file "~/RLG231/Lectures/AllLectures.org")
        (mwp-org-export-all-to-org)
        (org-publish "rlg231")
        ))

    (defun mwp-export-dh ()
      "open alllectures.org and export/publish all files"
      (interactive)
      (save-excursion
        (find-file "~/DH/Lectures/LectureOutlines.org")
        (mwp-org-export-all-to-org)
        (org-publish "dh")
        ))
    (defun org-export-all (backend)
      "Export all subtrees that are *not* tagged with :noexport: to
        separate files.

        Subtrees that do not have the :EXPORT_FILE_NAME: property set
        are exported to a filename derived from the headline text."
      (interactive "sEnter backend: ")
      (let ((fn (cond ((equal backend "html") 'org-html-export-to-html)
                      ((equal backend "latex") 'org-latex-export-to-latex)
                      ((equal backend "org") 'org-org-export-to-org)
                      ((equal backend "reveal") 'org-reveal-export-to-html)
                      ((equal backend "pdf") 'org-latex-export-to-pdf)))
            (modifiedp (buffer-modified-p)))
        (save-excursion
          (set-mark (point-min))
          (goto-char (point-max))
          (org-map-entries
           (lambda ()
             (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
               (unless export-file
                 (org-set-property
                  "EXPORT_FILE_NAME"
                  (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
               (funcall fn nil t)
               (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
               (set-buffer-modified-p modifiedp)))
           "-noexport" 'region-start-level))))
    )
#+END_SRC

#+RESULTS:
: org-export-all-for-publication

#+END_SRC

Notice the publishing function, which is set to ~mwp-org-deck-publish-to-html~. This is a simple function that resets the base url and ~extra-css~ values to web-based ones before publication, so that the presentations work when online. Notice I've also reset the ~deck.js~ base url, in case I ever decide to change back to deck.  

#+BEGIN_SRC emacs-lisp

    (defun mwp-org-reveal-publish-to-html (plist filename pub-dir)
      "Publish an org file to reveal.js HTML Presentation.
    FILENAME is the filename of the Org file to be published.  PLIST
    is the property list for the given project.  PUB-DIR is the
    publishing directory. Returns output file name."
      (let (
            ;;(org-deck-base-url "http://sandbox.hackinghistory.ca/Tools/deck.js/")
            ;;(org-reveal-root "http://sandbox.hackinghistory.ca/Tools/reveal.js/")
            ;;(org-reveal-extra-css "http://sandbox.hackinghistory.ca/Tools/reveal.js/css/local.css")
            (org-reveal-single-file t)
          )   
    
        (org-publish-org-to 'reveal filename ".html" plist pub-dir))
      )
#+END_SRC

#+RESULTS:
: mwp-org-reveal-publish-to-html

And that's it, magic!
**** Still to do
I like this a lot, but there are a couple of pieces I'd still like to implement.
- Fix all local file URL's :: I'd like to write a function to take a final pass through all the links and change ~file:///~ links to *HTML relative links*. That will take some work though.
- Export as standalone :: There is work underway to allow presentations to be generated as stand-alone files that can be, e.g, sent by email.  I like this idea a lot.  [[https://github.com/yjwen/org-reveal/issues/121][See this Github issue]].
- Standardize notes, fragments :: Every time I switch from one presentation framework to another, I have to learn a whole different syntax for things like fragments (bits of content that don't appear on the slide immediately, but are instead stepped through) and speaker notes (that don't appear on the slide that your viewers see, but are only visible to you in some kind of preview mode).  It would be great if the various slide modes could work towards a common syntax for these things.  If I have time, energy, and skills, I would like to help develop this a little.
**** See my slides
If you want to see some examples of the end product, [[http://sandbox.hackinghistory.ca/DigitalHistory/Lectures/][here is a link to my Digital History lecture archive]] (still being built!). Many of my course materials are also [[https://github.com/titaniumbones?tab=repositories][online at Github]].  
*** BLOCKED Modifying Reveal *NOT TANGLED*
This never actually worked, but here it is in case it's somehow doing something at hteo moment...
#+BEGIN_SRC emacs-lisp :tangle no
  ;; (defun org-reveal-scripts (info)
  ;;   "Return the necessary scripts for initializing reveal.js using
  ;; custom variable `org-reveal-root'."
  ;;   (let* ((root-path (file-name-as-directory (plist-get info :reveal-root))))
  ;;     (concat
  ;;      ;; reveal.js/lib/js/head.min.js
  ;;      ;; reveal.js/js/reveal.js
  ;;      (format "
  ;; <script src=\"%slib/js/head.min.js\"></script>
  ;; <script src=\"%sjs/reveal.js\"></script>
  ;; "
  ;;              root-path root-path)
  ;;      ;; plugin headings
  ;;      "
  ;; <script>
  ;; // Full list of configuration options available here:
  ;; // https://github.com/hakimel/reveal.js#configuration
  ;; Reveal.initialize({
  ;; "
  ;;      (format "
  ;; controls: %s,
  ;; progress: %s,
  ;; history: %s,
  ;; center: %s,
  ;; slideNumber: %s,
  ;; rollingLinks: %s,
  ;; keyboard: %s,
  ;; overview: %s,
  ;; "
  ;;              (if (plist-get info :reveal-control) "true" "false")
  ;;              (if (plist-get info :reveal-progress) "true" "false")
  ;;              (if (plist-get info :reveal-history) "true" "false")
  ;;              (if (plist-get info :reveal-center) "true" "false")
  ;;              (if (plist-get info :reveal-slide-number) "true" "false")
  ;;              (if (plist-get info :reveal-rolling-links) "true" "false")
  ;;              (if (plist-get info :reveal-keyboard) "true" "false")
  ;;              (if (plist-get info :reveal-overview) "true" "false"))

  ;;      ;; slide width
  ;;      (let ((width (plist-get info :reveal-width)))
  ;;        (if (> width 0) (format "width: %d,\n" width) ""))

  ;;      ;; slide height
  ;;      (let ((height (plist-get info :reveal-height)))
  ;;        (if (> height 0) (format "height: %d,\n" height) ""))

  ;;      ;; slide margin
  ;;      (let ((margin (string-to-number (plist-get info :reveal-margin))))
  ;;        (if (>= margin 0) (format "margin: %.2f,\n" margin) ""))

       ;; slide minimum scaling factor
       (let ((min-scale (string-to-number (plist-get info :reveal-min-scale))))
         (if (> min-scale 0) (format "minScale: %.2f,\n" min-scale) ""))

       ;; slide maximux scaling factor
       (let ((max-scale (string-to-number (plist-get info :reveal-max-scale))))
         (if (> max-scale 0) (format "maxScale: %.2f,\n" max-scale) ""))

       ;; thems and transitions
       (format "
  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || '%s', // default/cube/page/concave/zoom/linear/fade/none
  transitionSpeed: '%s',\n"
               (plist-get info :reveal-trans)
               (plist-get info :reveal-speed))

       ;; multiplexing - depends on defvar 'client-multiplex'
       (when (plist-get info :reveal-multiplex-id)
         (format
          "multiplex: {
      secret: %s, // null if client
      id: '%s', // id, obtained from socket.io server
      url: '%s' // Location of socket.io server
  },\n"
          (if (eq client-multiplex nil)
              (format "'%s'" (plist-get info :reveal-multiplex-secret))
            (format "null"))
          (plist-get info :reveal-multiplex-id)
          (plist-get info :reveal-multiplex-url)))

       ;; optional JS library heading
       "
  // Optional libraries used to extend on reveal.js
  dependencies: [
  "
       ;; JS libraries
       (let* ((builtins
               '(classList (format " { src: '%slib/js/classList.js', condition: function() { return !document.body.classList; } }" root-path)
                           markdown (format " { src: '%splugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
   { src: '%splugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }" root-path root-path)
                           highlight (format " { src: '%splugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }" root-path)
                           zoom (format " { src: '%splugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                           notes (format " { src: '%splugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                           search (format " { src: '%splugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                           remotes (format " { src: '%splugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                           multiplex (format " { src: '%s', async: true },\n%s"
                                             (plist-get info :reveal-multiplex-socketio-url)
                                          ; following ensures that either client.js or master.js is included depending on defva client-multiplex value state
                                             (if (not client-multiplex)
                                                 (progn
                                                   (if (plist-get info :reveal-multiplex-secret)
                                                       (setq client-multiplex t))
                                                   (format " { src: '%splugin/multiplex/master.js', async: true }" root-path))

                                               (format " { src: '%splugin/multiplex/client.js', async: true }" root-path)))))
              (builtin-codes
               (mapcar
                (lambda (p)
                  (eval (plist-get builtins p)))
                (let ((buffer-plugins (plist-get info :reveal-plugins)))
                  (cond
                   ((string= buffer-plugins "") ())
                   (buffer-plugins (car (read-from-string buffer-plugins)))
                   (t org-reveal-plugins)))))
              (extra-codes (plist-get info :reveal-extra-js))
              (total-codes
               (if (string= "" extra-codes) builtin-codes
                 (append (list extra-codes) builtin-codes))))
         (mapconcat 'identity total-codes ",\n"))
       "
  ]
  });
  </script>\n")))

#+END_SRC
*** ACTION Org2Blog
:PROPERTIES:
:POST_DATE: [2015-07-11 Sat 12:28]
:ID:       3ac2a7c3-b4f5-4318-9477-5081fb955d21
:POSTID:
:END:
I have used org2blog for years, first to blog on my own, then when I stopped that, to post pretty much all my course content to websites for [[http://www.hackinghistory.ca/][Hacking History]] and other courses such as [[http://digital.hackinghistory.ca][Digital History]]. 

Org2blog wil ltake a buffer or subtree and post it to any blog of your choosing, as long as the xmlrpc interface on that blog is open.  You can start a new post with ~M-x org2blog/wp-new-entry~, or call ~org2blog/wp~post[buffer|subtree][-as-page][-and-publish]~ from an existing buffer/subtree.  

This section defines my blogs (there are 4 right now, sometimes there are more, sometimes fewer), and has a couple of little defuns that make it easier to type some of the relevant functions.  It also adds a hook to change some keybindings.  

There's way more info at [[https://github.com/punchagan/org2blog/][the Github repository page]].

THisi s sort of obsolete now, trying to trnasition the last blogs away ASAP  
#+BEGIN_SRC emacs-lisp
  ;;; Org2blog

  (setq org2blog/wp-blog-alist
        '(("hh"
           :url "http://2016.hackinghistory.ca/xmlrpc.php"
           :username "matt"
           :default-title "Title"
           :default-categories (nil)
           :tags-as-categories nil)
          ("sik"
           :url "http://sikkim.hackinghistory.ca/xmlrpc.php"
           :username "matt"
           :default-title "Title"
           :default-categories (nil)
           :tags-as-categories nil)
          ("rel"
           :url "http://relsci.hackinghistory.ca/xmlrpc.php"
           :username "matt"
           :default-title "Title"
           :default-categories (nil)
           :tags-as-categories nil)
          ("dig"
           :url "http://digital.hackinghistory.ca/xmlrpc.php"
           :username "matt"
           :default-title "Title"
           :default-categories (nil)
           :tags-as-categories nil)
           ("matt"
           :url "http://matt.hackinghistory.ca/xmlrpc.php"
           :username "matt"
           :default-title ""
           :default-categories (nil)
           :tags-as-categories nil)
          ))


  (defun o2bnew ()
    (interactive)
    (org2blog/wp-new-entry))
  (defun o2blin ()
    (interactive)
    (org2blog/wp-login))


  ;;; Org2blog
  ;; starting org2blog a little more easily
  ;; example of binding keys only when html-mode is active

  ;;;; O2B kebybindings
  (defun matt-org-mode-keys ()
    "Modify keymaps used by `org-mode'."
    (local-set-key (kbd "C-c <f1>") 'org2blog/wp-mode)
    (local-set-key "\C-c\C-r" 'org-decrypt-entry)
    ;; (local-set-key (kbd "RET") 'org-return-indent)
    ;; insert a NOTES drawer with C-c C-x n
  ;;  (local-set-key (kbd "C-c C-x n") (org-insert-drawer "NOTE"))

    ;; (local-set-key (kbd "C-c C-p") nil) ; remove a key

    )

  ;; add to org-mode-hook
  ;; should configure but 
  (add-hook 'org-mode-hook 'matt-org-mode-keys)

#+END_SRC

Here's a little treat from [[http://emacs.stackexchange.com/questions/2206/i-want-to-have-the-kbd-tags-for-my-blog-written-in-org-mode][Stack Exchange]].  This function and accompanying keybinding let me insert a <kbd> tag very easily.
#+BEGIN_SRC emacs-lisp

  ;; (define-key org-mode-map "\C-ck" #'endless/insert-key)
  (defun endless/insert-key (key)
    "Ask for a key then insert its description.
  Will work on both org-mode and any mode that accepts plain html."
    (interactive "kType key sequence: ")
    (let* ((is-org-mode (derived-mode-p 'org-mode))
           (tag (if is-org-mode
                    "@@html:<kbd>%s</kbd>@@"
                  "<kbd>%s</kbd>")))
      (if (null (equal key "\r"))
          (insert
           (format tag (help-key-description key nil)))
        (insert (format tag ""))
        (forward-char (if is-org-mode -8 -6)))))
#+END_SRC
*** Exporting org-files to a temporary location
:PROPERTIES:
:ID:       o2b:30e0ee49-9842-4cee-aff6-55283f9043c8
:POST_DATE: [2015-07-11 Sat 12:25]
:POSTID:   18
:BLOG:     matt
:END:
I have a private journal, which lives in an encrypted file in a Dropbox-backed-up directory.  I use html export to examine the contents sometimes -- there are some big old tables that are hard to read in org-mode -- but I don't want the html file to end up in Dropbox.  

So I just copied the definition of org-export-html-as-html and made trivial modifications.  There's probably a better way to do this.  
#+BEGIN_SRC emacs-lisp
  ;; export html to tmp dir
  (defun mwp-org-html-to-tmp
      (&optional async subtreep visible-only body-only ext-plist)
    "Export current buffer to a HTML file in the tmp directory.

  If narrowing is active in the current buffer, only export its
  narrowed part.

  If a region is active, export that region.

  A non-nil optional argument ASYNC means the process should happen
  asynchronously.  The resulting file should be accessible through
  the `org-export-stack' interface.

  When optional argument SUBTREEP is non-nil, export the sub-tree
  at point, extracting information from the headline properties
  first.

  When optional argument VISIBLE-ONLY is non-nil, don't export
  contents of hidden elements.

  When optional argument BODY-ONLY is non-nil, only write code
  between \"<body>\" and \"</body>\" tags.


  EXT-PLIST, when provided, is a property list with external
  parameters overriding Org default settings, but still inferior to
  file-local settings.

  Return output file's name."
    (interactive)
    (let* ((extension (concat "." (or (plist-get ext-plist :html-extension)
                                      org-html-extension
                                      "html")))
  ;; this is the code I've changed from the original function. 
           (file (org-export-output-file-name extension subtreep "/home/matt/tmp/"))
         
           (org-export-coding-system org-html-coding-system))
      (org-export-to-file 'html file
        async subtreep visible-only body-only ext-plist)
      (org-open-file file)))

  ;; (org-defkey org-mode-map
  ;;             (kbd "C-c 0") 'mwp-org-html-to-tmp)

#+END_SRC

*** Writer's Room
This is an idea I've had for a couple of years, which hasn't yet come to fruition. If I figure it out, I'll put something in this section!

*** org-present
This uses org-present to do presentations inside emacs itself!
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-present"
    '(progn
       (add-hook 'org-present-mode-hook
                 (lambda ()
                   (org-present-big)
                   (org-display-inline-images)
                   (org-present-hide-cursor)
                   (org-present-read-only)))
       (add-hook 'org-present-mode-quit-hook
                 (lambda ()
                   (org-present-small)
                   (org-remove-inline-images)
                   (org-present-show-cursor)
                   (org-present-read-write)))))
#+END_SRC

*** Hugo Workflow for Courses
Wordpress is great, but it has become a bit of a drag to maintain dozens of Wordpress sites from year to year, especially as the goals of interactivity have gradually been sloughed off to other (non-free) platforms that have come to dominate that slice of our attention. (I'm thinking in particular of Slack and Disqus.)  In reality, pretty much everything I compose is created in Emacs in org-mode. 

With this in mind, I've now started using Kaushal Modi's [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]] to generate my course websites.  You can see the results at http://2017.hackinghistory.ca/ and http://wildwater.hackinghistory.ca/.  (The theme is based on the old hugo docs theme -- unfortunately I haven't had time to figure out the new, much more beautiful and cool docs theme to which Hugo has recently moved. That theme uses PostCSS instead of Bootstrap -- cool, but I don't think I have time to learn yet another framework right now!)

I'll just quickly describe my setup here in case anyone else finds it useful

*<2019-02-13 Wed> update:* add ox-huveal here b/c notworking in the other invocation
#+BEGIN_SRC emacs-lisp
  ;; ox-hugo isn't currently on MELPA and also hasn't been incorporated into org-mode. 
  ;; so for now you'll need to git clone git@github.com:kaushalmodi/ox-hugo.git and add the 
  ;; location to your load-path

  ;; (add-to-list 'load-path "~/src/kaushal-ox-hugo/")
  (use-package ox-hugo
    :load-path "~/src/kaushal-ox-hugo/"
    :after (:any org org-plus-contrib)
    :config
    (use-package ox-huveal
    :load-path "~/src/ox-huveal" ))



#+END_SRC

#+RESULTS:


**** Huveal
I have this silly little exporter that exports files as reveal to the hugo directory.  Get it this way. But ignore it for now while debugging org-mime!
#+begin_src emacs-lisp :tangle no
(use-package ox-huveal 
  :load-path "~/src/ox-huveal"
  :after (:all org-mode ox-hugo ox-reveal)
  :config
  (add-to-list 'org-export-backends 'huveal)
  )
#+end_src

#+RESULTS:

*** "do what I mean" (dwim) scopes for easily exporting to other formats
Kaushal's ~ox-hugo~ (above) makes use of a "do what I mean" scope for exporting.  It tried to determine how far up the heading tree you want to jump before choosing the export heading level.  I like it a lot, especially when combined with auto-saving, which is another neat feature.  

I need to be able to do this especially with lecture slides, which I export to Reveal; and slightly less frequently, I export them to my hugo/reveal hybrid, "huveal". So here are a couple of functions to help with that.  

#+begin_src emacs-lisp :tangle no
  (defun org-reveal-export-wim-to-html (&optional all-subtrees async visible-only noerror)
    "Export the current subtree/all subtrees/current file to a reveal slideshow.

  This is an Export \"What I Mean\" function:

  - If the current subtree has the \"EXPORT_FILE_NAME\" property, export
    that subtree.
  - If the current subtree doesn't have that property, but one of its
    parent subtrees has, then export from that subtree's scope.
  - If none of the subtrees have that property (or if there are no Org
    subtrees at all), but the Org #+title keyword is present,
    export the whole Org file as a post with that title (calls
    `org-reveal-export-to-html' with its SUBTREEP argument set to nil).

  - If ALL-SUBTREES is non-nil, export all valid Huveal post subtrees
    \(that have the \"EXPORT_FILE_NAME\" property) in the current file
    to multiple Markdown posts.
  - If ALL-SUBTREES is non-nil, and again if none of the subtrees have
    that property (or if there are no Org subtrees), but the Org #+title
    keyword is present, export the whole Org file.

  - If the file neither has valid Huveal post subtrees, nor has the
    ,#+title present, throw a user error.  If NOERROR is non-nil, use
    `message' to display the error message instead of signaling a user
    error.

  A non-nil optional argument ASYNC means the process should happen
  asynchronously.  The resulting file should be accessible through
  the `org-export-stack' interface.

  When optional argument VISIBLE-ONLY is non-nil, don't export
  contents of hidden elements.

  If ALL-SUBTREES is nil, return output file's name.
  If ALL-SUBTREES is non-nil, and valid subtrees are found, return
  a list of output files.
  If ALL-SUBTREES is non-nil, and valid subtrees are not found,
  return the output file's name (exported using file-based
  approach)."
    (interactive "P")
    (let ((f-or-b-name (if (buffer-file-name)
                           (file-name-nondirectory (buffer-file-name))
                         (buffer-name))))
      (save-window-excursion
        (save-restriction
          (widen)
          (save-excursion
            (if all-subtrees
                (let (ret)
                  (setq org-reveal--subtree-count 0)
                  (setq ret (org-map-entries
                             (lambda ()
                               (org-reveal-export-wim-to-html nil async visible-only noerror))
                             ;; Export only the subtrees where
                             ;; EXPORT_FILE_NAME property is not
                             ;; empty.
                             "EXPORT_FILE_NAME<>\"\""))
                  (if ret
                      (message "[ox-reveal] Exported %d subtree%s from %s"
                               org-reveal--subtree-count
                               (if (= 1 org-reveal--subtree-count) "" "s")
                               f-or-b-name)
                    ;; If `ret' is nil, no valid Reveal subtree was found.
                    ;; So call `org-reveal-export-wim-to-html' directly.  In
                    ;; that function, it will be checked if the whole
                    ;; Org file can be exported.
                    (setq ret (org-reveal-export-wim-to-html nil async visible-only noerror)))
                  (setq org-reveal--subtree-count nil) ;Reset the variable
                  ret)
              ;; Publish only the current subtree
              (ignore-errors
                (org-back-to-heading :invisible-ok))
              (let ((subtree (org-hugo--get-valid-subtree))
                    is-commented is-excluded matched-exclude-tag do-export)
                (if subtree
                    (progn
                      ;; If subtree is a valid Reveal post subtree, proceed ..
                      (setq is-commented (org-element-property :commentedp subtree))

                      (let ((all-tags (let ((org-use-tag-inheritance t))
                                        (org-hugo--get-tags))))
                        (when all-tags
                          (dolist (exclude-tag org-export-exclude-tags)
                            (when (member exclude-tag all-tags)
                              (setq matched-exclude-tag exclude-tag)
                              (setq is-excluded t)))))

                      ;; (message "[current subtree DBG] subtree: %S" subtree)
                      ;; (message "[current subtree DBG] is-commented:%S, tags:%S, is-excluded:%S"
                      ;;          is-commented tags is-excluded)
                      (let ((title (org-element-property :title subtree)))
                        (cond
                         (is-commented
                          (message "[ox-reveal] `%s' was not exported as that subtree is commented"
                                   title))
                         (is-excluded
                          (message "[ox-reveal] `%s' was not exported as it is tagged with an exclude tag `%s'"
                                   title matched-exclude-tag))
                         (t (setq org-reveal--subtree-count 0)
                          (if (numberp org-reveal--subtree-count)
                              (progn
                                (setq org-reveal--subtree-count (1+ org-reveal--subtree-count))
                                (message "[ox-reveal] %d/ Exporting `%s' .." org-reveal--subtree-count title))
                            (message "[ox-reveal] Exporting `%s' .." title))
                          ;; Get the current subtree coordinates for
                          ;; auto-calculation of menu item weight, page
                          ;; or taxonomy weights.

                          ;; none of this is relevant for reveal os skipping
                          ;; (when (or
                          ;;        ;; Check if the menu front-matter is specified.
                          ;;        (or
                          ;;         (org-entry-get nil "EXPORT_REVEAL_MENU" :inherit)
                          ;;         (save-excursion
                          ;;           (goto-char (point-min))
                          ;;           (let ((case-fold-search t))
                          ;;             (re-search-forward "^#\\+reveal_menu:.*:menu" nil :noerror))))
                          ;;        ;; Check if auto-calculation is needed
                          ;;        ;; for page or taxonomy weights.
                          ;;        (or
                          ;;         (let ((page-or-taxonomy-weight (org-entry-get nil "EXPORT_REVEAL_WEIGHT" :inherit)))
                          ;;           (and (stringp page-or-taxonomy-weight)
                          ;;                (string-match-p "auto" page-or-taxonomy-weight)))
                          ;;         (save-excursion
                          ;;           (goto-char (point-min))
                          ;;           (let ((case-fold-search t))
                          ;;             (re-search-forward "^#\\+reveal_weight:.*auto" nil :noerror)))))
                          ;;   (setq org-reveal--subtree-coord
                          ;;         (org-reveal--get-post-subtree-coordinates subtree)))
                          ;; Get the current subtree section name if any.
                          (setq org-reveal--section (org-entry-get nil "EXPORT_REVEAL_SECTION" :inherit))
                          ;; Get the current subtree bundle name if any.
                          (setq org-reveal--bundle (org-entry-get nil "EXPORT_REVEAL_BUNDLE" :inherit))
                          (setq do-export t)))))
                  ;; If not in a valid subtree, check if the Org file is
                  ;; supposed to be exported as a whole, in which case
                  ;; #+title has to be defined *and* there shouldn't be
                  ;; any valid Reveal post subtree present.
                  (setq org-reveal--subtree-count nil) ;Also reset the subtree count
                  (let ((valid-subtree-found
                         (catch 'break
                           (org-map-entries
                            (lambda ()
                              (throw 'break t))
                            ;; Only map through subtrees where
                            ;; EXPORT_FILE_NAME property is not
                            ;; empty.
                            "EXPORT_FILE_NAME<>\"\"")))
                        err msg)
                    (if valid-subtree-found
                        (setq msg "Point is not in a valid Reveal post subtree; move to one and try again")
                      (let ((title (save-excursion
                                     (goto-char (point-min))
                                     (let ((case-fold-search t))
                                       (re-search-forward "^#\\+title:" nil :noerror)))))
                        (if title
                            (setq do-export t)
                          (setq err t)
                          (setq msg (concat "The file neither contains a valid Reveal post subtree, "
                                            "nor has the #+title keyword")))))
                    (unless do-export
                      (let ((error-fn (if (or (not err)
                                              noerror)
                                          #'message
                                        #'user-error)))
                        (apply error-fn
                               (list
                                (format "%s: %s" f-or-b-name msg)))))))
                (when do-export
                  (org-reveal-export-to-html async subtree visible-only)))))))))

  (defun org-huveal-export-wim-to-html (&optional all-subtrees async visible-only noerror)
    "Export the current subtree/all subtrees/current file to a Huveal post.

  This is an Export \"What I Mean\" function:

  - If the current subtree has the \"EXPORT_FILE_NAME\" property, export
    that subtree.
  - If the current subtree doesn't have that property, but one of its
    parent subtrees has, then export from that subtree's scope.
  - If none of the subtrees have that property (or if there are no Org
    subtrees at all), but the Org #+title keyword is present,
    export the whole Org file as a post with that title (calls
    `org-huveal-export-to-md' with its SUBTREEP argument set to nil).

  - If ALL-SUBTREES is non-nil, export all valid Huveal post subtrees
    \(that have the \"EXPORT_FILE_NAME\" property) in the current file
    to multiple Markdown posts.
  - If ALL-SUBTREES is non-nil, and again if none of the subtrees have
    that property (or if there are no Org subtrees), but the Org #+title
    keyword is present, export the whole Org file.

  - If the file neither has valid Huveal post subtrees, nor has the
    ,#+title present, throw a user error.  If NOERROR is non-nil, use
    `message' to display the error message instead of signaling a user
    error.

  A non-nil optional argument ASYNC means the process should happen
  asynchronously.  The resulting file should be accessible through
  the `org-export-stack' interface.

  When optional argument VISIBLE-ONLY is non-nil, don't export
  contents of hidden elements.

  If ALL-SUBTREES is nil, return output file's name.
  If ALL-SUBTREES is non-nil, and valid subtrees are found, return
  a list of output files.
  If ALL-SUBTREES is non-nil, and valid subtrees are not found,
  return the output file's name (exported using file-based
  approach)."
    (interactive "P")
    (let ((f-or-b-name (if (buffer-file-name)
                           (file-name-nondirectory (buffer-file-name))
                         (buffer-name))))
      (save-window-excursion
        (save-restriction
          (widen)
          (save-excursion
            (if all-subtrees
                (let (ret)
                  (setq org-huveal--subtree-count 0)
                  (setq ret (org-map-entries
                             (lambda ()
                               (org-huveal-export-wim-to-html nil async visible-only noerror))
                             ;; Export only the subtrees where
                             ;; EXPORT_FILE_NAME property is not
                             ;; empty.
                             "EXPORT_FILE_NAME<>\"\""))
                  (if ret
                      (message "[ox-huveal] Exported %d subtree%s from %s"
                               org-huveal--subtree-count
                               (if (= 1 org-huveal--subtree-count) "" "s")
                               f-or-b-name)
                    ;; If `ret' is nil, no valid Huveal subtree was found.
                    ;; So call `org-huveal-export-wim-to-html' directly.  In
                    ;; that function, it will be checked if the whole
                    ;; Org file can be exported.
                    (setq ret (org-huveal-export-wim-to-html nil async visible-only noerror)))
                  (setq org-huveal--subtree-count nil) ;Reset the variable
                  ret)
              ;; Publish only the current subtree
              (ignore-errors
                (org-back-to-heading :invisible-ok))
              (let ((subtree (org-hugo--get-valid-subtree))
                    is-commented is-excluded matched-exclude-tag do-export)
                (if subtree
                    (progn
                      ;; If subtree is a valid Huveal post subtree, proceed ..
                      (setq is-commented (org-element-property :commentedp subtree))

                      (let ((all-tags (let ((org-use-tag-inheritance t))
                                        (org-hugo--get-tags))))
                        (when all-tags
                          (dolist (exclude-tag org-export-exclude-tags)
                            (when (member exclude-tag all-tags)
                              (setq matched-exclude-tag exclude-tag)
                              (setq is-excluded t)))))

                      ;; (message "[current subtree DBG] subtree: %S" subtree)
                      ;; (message "[current subtree DBG] is-commented:%S, tags:%S, is-excluded:%S"
                      ;;          is-commented tags is-excluded)
                      (let ((title (org-element-property :title subtree)))
                        (cond
                         (is-commented
                          (message "[ox-huveal] `%s' was not exported as that subtree is commented"
                                   title))
                         (is-excluded
                          (message "[ox-huveal] `%s' was not exported as it is tagged with an exclude tag `%s'"
                                   title matched-exclude-tag))
                         (t (setq org-huveal--subtree-count 0)
                          (if (numberp org-huveal--subtree-count)
                              (progn
                                (setq org-huveal--subtree-count (1+ org-huveal--subtree-count))
                                (message "[ox-huveal] %d/ Exporting `%s' .." org-huveal--subtree-count title))
                            (message "[ox-huveal] Exporting `%s' .." title))
                          ;; Get the current subtree coordinates for
                          ;; auto-calculation of menu item weight, page
                          ;; or taxonomy weights.

                          ;; none of this is relevant for huveal os skipping
                          (when (or
                                 ;; Check if the menu front-matter is specified.
                                 (or
                                  (org-entry-get nil "EXPORT_HUVEAL_MENU" :inherit)
                                  (save-excursion
                                    (goto-char (point-min))
                                    (let ((case-fold-search t))
                                      (re-search-forward "^#\\+huveal_menu:.*:menu" nil :noerror))))
                                 ;; Check if auto-calculation is needed
                                 ;; for page or taxonomy weights.
                                 (or
                                  (let ((page-or-taxonomy-weight (org-entry-get nil "EXPORT_HUVEAL_WEIGHT" :inherit)))
                                    (and (stringp page-or-taxonomy-weight)
                                         (string-match-p "auto" page-or-taxonomy-weight)))
                                  (save-excursion
                                    (goto-char (point-min))
                                    (let ((case-fold-search t))
                                      (re-search-forward "^#\\+huveal_weight:.*auto" nil :noerror)))))
                            (setq org-huveal--subtree-coord
                                  (org-huveal--get-post-subtree-coordinates subtree)))
                          ;; Get the current subtree section name if any.
                          (setq org-huveal--section (org-entry-get nil "EXPORT_HUVEAL_SECTION" :inherit))
                          ;; Get the current subtree bundle name if any.
                          (setq org-huveal--bundle (org-entry-get nil "EXPORT_HUVEAL_BUNDLE" :inherit))
                          (setq do-export t)))))
                  ;; If not in a valid subtree, check if the Org file is
                  ;; supposed to be exported as a whole, in which case
                  ;; #+title has to be defined *and* there shouldn't be
                  ;; any valid Huveal post subtree present.
                  (setq org-huveal--subtree-count nil) ;Also reset the subtree count
                  (let ((valid-subtree-found
                         (catch 'break
                           (org-map-entries
                            (lambda ()
                              (throw 'break t))
                            ;; Only map through subtrees where
                            ;; EXPORT_FILE_NAME property is not
                            ;; empty.
                            "EXPORT_FILE_NAME<>\"\"")))
                        err msg)
                    (if valid-subtree-found
                        (setq msg "Point is not in a valid Huveal post subtree; move to one and try again")
                      (let ((title (save-excursion
                                     (goto-char (point-min))
                                     (let ((case-fold-search t))
                                       (re-search-forward "^#\\+title:" nil :noerror)))))
                        (if title
                            (setq do-export t)
                          (setq err t)
                          (setq msg (concat "The file neither contains a valid Huveal post subtree, "
                                            "nor has the #+title keyword")))))
                    (unless do-export
                      (let ((error-fn (if (or (not err)
                                              noerror)
                                          #'message
                                        #'user-error)))
                        (apply error-fn
                               (list
                                (format "%s: %s" f-or-b-name msg)))))))
                (when do-export
                  (org-huveal-export-to-html async subtree visible-only)))))))))

#+end_src

*** Auto Export
ox-hugo comes with an auto-export functionality which is described [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][here]]. I love it and have copied it for org-reveal.  

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/src/kaushal-ox-hugo/")
    (use-package ox-hugo-auto-export
      :after ox-hugo
      :defer t)
  (use-package ox-reveal-auto-export
    :after ox-reveal
    :defer t)
#+end_src

#+RESULTS:

** BLOCKED Transclusion
From John Kitchin

Doesn't really work for me yet so I'm commenting all this out;
otherwise, with use-package, I would need to defer this till org-mode had already been loaded
#+BEGIN_SRC emacs-lisp :results silent
  (defvar *transclude* t "Put overlays on or not")
  (setq *transclude* t)

  ;; (org-link-set-parameters
  ;;  "transclude"
  ;;  :face '(:background "gray80")
  ;;  :follow (lambda (path)
  ;;            (org-open-link-from-string path))
  ;;  :keymap (let ((map (copy-keymap org-mouse-map)))
  ;;            (define-key map [C-mouse-1] (lambda ()
  ;;                                          (interactive)
  ;;                                          (setq *transclude* (not *transclude*))
  ;;                                          (unless *transclude*
  ;;                                            (ov-clear 'transclude))
  ;;                                          (font-lock-fontify-buffer)))
  ;;            map)
  ;;  :help-echo "Transcluded element. Click to open source. C-mouse-1 to toggle overlay."
  ;;  :activate-func (lambda (start end path bracketp)
  ;;                   (if *transclude*
  ;;                       (let ((ov (make-overlay start end))
  ;;                             el disp)
  ;;                         (ov-put ov 'transclude t)
  ;;                         (save-window-excursion
  ;;                           (with-temp-buffer
  ;;                             (insert path)
  ;;                             (org-open-file
  ;;                              (org-element-property
  ;;                               :path
  ;;                               (org-element-context))
  ;;                              nil nil
  ;;                              (org-element-property
  ;;                               :search-option
  ;;                               (org-element-context)))

  ;;                             (setq el (org-element-context))
  ;;                             (setq disp (buffer-substring
  ;;                                         (org-element-property :begin el)
  ;;                                         (- (org-element-property :end el)
  ;;                                            (or (org-element-property :post-blank el) 0)))))
  ;;                           (message-box "%s" disp)

  ;;                           (ov-put ov 'display disp)))
  ;;                     (ov-clear 'transclude 'any start end))))
#+END_SRC

** ACTION Zotero!
One of the few weaknesses that I see in Org compared to other platforms is citation handling, which until recently I really had no way of doing. But recently things have started to really get better, thanks to Erik Hetzner's ~org-zotxt~.  I'll blog more about this soon, because it's so awesome.  Not quite finished yet though!

This still hasn't been setup. Should livenear org-ref & those should be done together.
#+BEGIN_SRC emacs-lisp

  (use-package org-zotxt
    :after (:any org org-plus-contrib)
    :config
    ;; zotxt
    (org-add-link-type "zotero"
                       (lambda (rest)
                         (zotxt-select-key (substring rest 15)))
                       (lambda (path desc format)
                         (if (string-match "^@\\(.*\\)$" desc)
                             (cond ((eq format 'latex)
                                    (format "\\cite{%s}" (match-string 1 desc)))
                                   ((eq format 'md)
                                    desc)
                                   ((eq format 'html)
                                    (deferred:$
                                      (zotxt-get-item-bibliography-deferred `(:key , (substring path 15)))
                                      (deferred:nextc it
                                        (lambda (item)
                                          (plist-get item :citation-html)))
                                      (deferred:sync! it)))
                                   ((eq format 'odt)
                                    (xml-escape-string (deferred:$
                                                         (zotxt-get-item-deferred `(:key , (substring path 15)) :248bebf1-46ab-4067-9f93-ec3d2960d0cd)
                                                         (deferred:nextc it
                                                           (lambda (item)
                                                             (plist-get item :248bebf1-46ab-4067-9f93-ec3d2960d0cd)))
                                                         (deferred:sync! it))))
                                   (t nil)
                                   nil)))))



  ;; a helper function to parse html to org syntax:
  (use-package pcase
    :after org-zotxt
    :config
  

    (defun org-zotxt-parse-htmlstring (html)
      (with-temp-buffer
        (insert html)
        (libxml-parse-html-region (point-min) (point-max))))
    (defun org-zotxt-htmlstring2org (html)
      (org-zotxt-htmltree2org (org-zotxt-parse-htmlstring html)))

    (defun org-zotxt-htmltree2org (html)
      (pcase html
        ((pred (stringp)) html)
        (`(a ,attrs . ,children)
         (format "[[%s][%s]]" (cdr (assq 'href attrs))
                 (org-zotxt-htmltree2org children)))
        (`(i ,attrs . ,children)
         (format "/%s/" (org-zotxt-htmltree2org children)))
        (`(b ,attrs . ,children)
         (format "*%s*" (org-zotxt-htmltree2org children)))
        (`(p ,attrs . ,children)
         (format "%s\n\n" (org-zotxt-htmltree2org children)))
        (`(span ,attrs . ,children)
         (pcase (cdr (assq 'style attrs))
           ("font-style:italic;"
            (format "/%s/" (org-zotxt-htmltree2org children)))
           ("font-variant:small-caps;"
            ;; no way?
            (org-zotxt-htmltree2org children))
           (_ (org-zotxt-htmltree2org children))))
        ((or `(html ,attrs . ,children)
             `(body ,attrs . ,children))
         (org-zotxt-htmltree2org children))
        ((pred (lambda (h) (and (listp h)
                                (or (stringp (car h))
                                    (and (listp (car h))
                                         (symbolp (car (car h))))))))
         ;; list of strings or elements
         (mapconcat #'org-zotxt-htmltree2org html "")))))

#+END_SRC

#+RESULTS:
: org-zotxt-htmltree2org

** ACTION org-ref
Trying to get [[https://github.com/jkitchin/org-ref][org-ref]] working. Having trouble getting stuff formatted to my satisfaction. 

there's a bug somewhere which leads to this getting loaded before org-element has been loaded. Not sure how to manage that, but as I'm not using org-ref, untangling for now.
#+BEGIN_SRC emacs-lisp :tangle no

  (use-package org-ref
    :after org
    :config
    ;; see org-ref for use of these variables
    (setq org-ref-bibliography-notes "~/Bibliography/notes.org"
          org-ref-default-bibliography '("~/Bibliography/Bibliography.bib")
          org-ref-pdf-directory "~/Bibliography/files/")

    (setq bibtex-completion-bibliography "~/Bibliography/Bibliography.bib"
          bibtex-completion-library-path "~/Bibliography/files"
          )

    ;; open pdf with system pdf viewer (works on mac)
    (setq bibtex-completion-pdf-open-function
          (lambda (fpath)
            (start-process "xdg-open" "*xdg-open*" "xdg-open" fpath)))
    ;; alternative
    ;; (setq bibtex-completion-pdf-open-function 'org-open-file)

    (setq org-ref-formatted-citation-backend "org")
    (setq org-ref-completion-library 'org-ref-helm-bibtex)
    )
#+END_SRC

#+RESULTS:
** ACTION First part                                                :review:

More random ocnfig crap, hard to mange. 
#+BEGIN_SRC emacs-lisp

    ;; ;;; Thisi s essential for code blocks, etc. 
     ;;(setq org-use-speed-commands (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))
  (setq org-use-speed-commands t)

    ;;; Extract Links
    (defun my-org-extract-link ()
      "Extract the link location at point and put it on the killring."
      (interactive)
      (when (org-in-regexp org-bracket-link-regexp 1)
        (kill-new (org-link-unescape (org-match-string-no-properties 1)))))

    ;; incude htmlize.el
    ;;; babel
    (org-babel-do-load-languages
     'org-babel-load-languages
      '( (perl . t)         
         (ruby . t)
         (shell . t)
         (dot . t)
         (python . t)
         (js . t) 
         (emacs-lisp . t)
       )))


    ;; (require 'flymake-php)
    ;; (add-hook 'php-mode-hook 'flymake-php-load)

    ;; some expand-region stuff


    (defun er/mark-org-heading (level)
      "Marks a heading 0 or more levels up from current subheading"
      (interactive "n" )
      (while (> level 0)
        (org-up-element)
        (setq level (- level 1))
        )
      (org-mark-subtree))

    (defun er/mark-org-parent ()
      "Marks a heading 1 level up from current subheading"
      (interactive  )
      (org-up-element)
      (org-mark-subtree))

    (defun er/mark-org-heading-2 ()
      "Marks a heading 0 or more levels up from current subheading"
      (interactive "n" )
      (let (level 2)
        (while (> level 0)
          (org-up-element)
          (setq level (- level 1))
          ))
      (org-mark-subtree))



    (defun mwp-no-write ()
      (interactive)
      (save-excursion
        (beginning-of-line)
        (when (looking-at org-property-re)
          (let ((myre (match-data) )
                (beg (match-beginning 1))
                (end (match-end 1)))
            (message "actually running")
            (print myre)
            (print beg)
            (print end)
            (put-text-property beg end 'read-only t) ))))
    (defun mwp-write ( )
      (interactive )
      (save-excursion
        (beginning-of-line)
        (when (looking-at org-property-re)
          (let ((myre (match-data) )
                (beg (match-beginning 1))
                (end (match-end 1))
                (inhibit-read-only t))
            (message "actually running")
            (print myre)
            (print beg)
            (print end)
            (remove-text-properties beg end '(read-only)) )))
      )


    ;; open things properly in org-mode
    ;;(setcdr (assq 'system org-file-apps-defaults-gnu ) "xdg-open %s")

#+END_SRC

** Encryption
I'm not sure which of these solutions I use more. Do I actually use both 
#+BEGIN_SRC emacs-lisp
  ;; encryption with easypg
  (use-package epa-file
    :config
    (epa-file-enable)
    (setq epa-file-inhibit-auto-save t)
)


  (use-package org-crypt
    :config
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritance (quote ("crypt")))
    ;; GPG key to use for encryption
    ;; Either the Key ID or set to nil to use symmetric encryption.
    (setq org-crypt-key nil))
#+END_SRC
** ACTION Org timestamp defuns
:PROPERTIES:
:GRADE:    1
:END:

I am currently using ~get-ts+7-inc=ov~, which is ocmpatible with my macro previwing code, below. However... a much more rational way to do this would be to just initalize a variable with 2 or 3 dates and count forwards from there. It's actually a far preferable and more robust system, and way way way way simpler than what I've written.  But mine works for now so leaving in palce.  

These are a bit of a mess, need to be rationalized & perhaps packaged. 
#+BEGIN_SRC emacs-lisp

  ;; add a new timestamp one week later than the previous
  (defun mwp/one-week-later (n)
  )
  ;;; changing timestamps    
  (defun update-org-days (n)
    "Change all org-mode timestamps in the current buffer by N days."
    (interactive "nChange days: ")
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "[[<]" nil t)
        (when (org-at-timestamp-p t)
          (org-timestamp-change n 'day)))))


    (defun mwp-change-dates ()
      (interactive)
      (progn
        (save-excursion
          (setq ts-regex org-element--timestamp-regexp)
          ;; go to timestamp
          (re-search-forward ts-regex)
          (setq mwp-test-value (match-beginning 0))
          (message (number-to-string  (match-beginning 0)))
          (let ((base-date (match-string 1)) ;; this is the timestamp
                (seven-days (seconds-to-time (* 7 24 60 60)))
                (new-ts)
                (week-num 0))
            (message base-date)
            (message "in let!")
            (while (< week-num 12)
              (message "in while!")
              (let ((add-value (seconds-to-time (* week-num 50 24 60 60))))
                (message "in second let")
                (setq new-ts (format-time-string "** <%Y-%m-%d %a>"
                                                 (time-add (date-to-time base-date) add-value)))
                (message new-ts)
                (re-search-forward ts-regex)

                (message (number-to-string  (match-beginning 0)))
                (message (number-to-string  (match-end 0)))
                ;; now we kill the old time stamp, and insert the new one
                (set-mark (match-beginning 0))

                ;; (beginning-of-line)
                (delete-region (match-beginning 0) (match-end 0))
                (insert new-ts)
                (setq week-num (1+ week-num))
                (re-search-forward ts-regex)))
            ))))

    (defun insert-ts+1w ()
      "Insert a timestamp at point that is one week later than the
    last timestamp found in the buffer."
      (interactive)
      (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
                                  (lambda (timestamp)
                                    (org-element-property :raw-value timestamp)))))))
        (insert last-ts)
        (backward-char 2)
        (org-timestamp-change +7 'day)
        (forward-char 2)
        ))
  (defun insert-ts+7 ()
    (interactive)
    (insert
     (concat ""
             (save-excursion
               (re-search-backward
                (org-re-timestamp 'all))
               (match-string 0)))
     "")
    (org-timestamp-change 7 'day))


;; this is the one I'm currently using
(defun get-ts+7 ()
"returns a string of the form <%Y-%m-d %a> where the date elements are 7 days later
than the previous timestamp in the buffer. No error checking or anything yet."
    (interactive)
    (let ((base-date (save-excursion
                 (re-search-backward
                  (org-re-timestamp 'all))
                 (match-string 0)))
          (result nil))

      (format-time-string "<%Y-%m-%d %a>"
                          (time-add
                           (date-to-time base-date) (days-to-time (1+ 7)))) ))



(defun get-ts+7 (&optional weekly-times)
  "Return a string of the form <%Y-%m-d %a> where the date
elements are 7 days later than the (n - WEEKLY-TIMES timestamp)
in the buffer. That is, if WEEKLY-TIMES is nil or 1, return a
date one week later than the *PREVIOUS* timestamp. If
WEEKLY-TIMES is 2, return a time one week later than the
,*SECOND-TO-LAST* timestamp above the previous location.

If there are not enough timestamps, right now it returns the last
found timestamp. "
  (interactive)
  (setq weekly-times (or weekly-times 1))
  (defun ts-search ()
    (save-match-data 
      (goto-char (re-search-backward
                  (org-re-timestamp 'all) nil t))
      (let ((thismatch  (match-string 0)))
        (message "match: %s" thismatch)
        thismatch)))
  (let* (r
         (base-date (save-excursion
                     (cl-dotimes (time weekly-times r)
                       (condition-case nil
                           (progn (setq  r (or (ts-search) r))
                                  (message "r is %s" r))
                         (error
                          (message "Drat, there were %s timestamps, using the last one I found."
                                   (if (= 0 time) "no" time))
                          (return r))))))

        (result nil))
    (message "base-time is %s" base-date)
    (if base-date
        (format-time-string "<%Y-%m-%d %a>"
                            (time-add
                             (date-to-time base-date) (days-to-time (1+ 7))))
      "NO PREVIOUS TIMESTAMP") ))

(defun ts-search-both ()
  (save-match-data
    (let* ((bufts
            (save-match-data
              (set-match-data nil)
              (save-excursion 
                (re-search-backward
                 (org-re-timestamp 'all) nil t)
                (if (match-beginning 0)
                    `(,(match-beginning 0) ,(match-string 0))
                  nil))))
           (ovts (save-match-data (save-excursion  (ts-search-ov)))))
      (cond
       ((and bufts ovts)
        (if (> (car bufts) (car ovts))
            (goto-char (car bufts))
            (cadr bufts)
          (cadr ovts)))
       (bufts
        (goto-char (car bufts))
        (cadr bufts))
       (ovts
        (goto-char (car ovts))
        (cadr ovts))
       (t
        (goto-char (point-min)) nil)
       )
      )))

(defun ts-search-ov ()
  (let* ((ovend   (previous-single-char-property-change (point) 'macro-ov-p))
         (ovs (overlays-at ovend))
         (m  (cl-loop for o in ovs
                      if (string-match (org-re-timestamp 'all) (overlay-get o 'before-string))
                      ;;(goto-char (overlay-start o))
                      return (match-string 0 (overlay-get o 'before-string)))))
    (cond
     (m `(,(point) ,m))
     ((>= (point-min) ovend )
      (goto-char ovend)
      nil)
     (t
      (goto-char ovend)
      (ts-search-ov))
      )))

(defun get-ts+7-inc-ov (&optional weekly-times)
  "Return a string of the form <%Y-%m-d %a> where the date
elements are 7 days later than the (n - WEEKLY-TIMES timestamp)
in the buffer. That is, if WEEKLY-TIMES is nil or 1, return a
date one week later than the *PREVIOUS* timestamp. If
WEEKLY-TIMES is 2, return a time one week later than the
,*SECOND-TO-LAST* timestamp above the previous location.

If there are not enough timestamps, right now it returns the last
found timestamp. "
  (interactive)
  (setq weekly-times (or weekly-times 1))
  
  (let* (r
         (base-date (save-excursion
                     (cl-dotimes (time weekly-times r)
                       (condition-case nil
                           (let ((s (ts-search-both)))
                             (if s
                                 (setq r s)
                               (message "Drat, there were %s timestamps, using the last one I found."
                                        (if (= 0 time) "no" time))
                               (return r)))
                         
                         ;; (error
                         ;;  (message "Drat, there were %s timestamps, using the last one I found."
                         ;;           (if (= 0 time) "no" time))
                         ;;  (return r))
                         ))))

        (result nil))
    (message "base-time is %s" base-date)
    (if base-date
        (format-time-string "<%Y-%m-%d %a>"
                            (time-add
                             (date-to-time base-date) (days-to-time (1+ 7))))
      "NO PREVIOUS TIMESTAMP") ))
#+END_SRC

#+RESULTS:
: get-ts+7-inc-ov


here's another version:

#+begin_src emacs-lisp
(defun update-org-days (n)
  "Change all org-mode timestamps in the current buffer by N days."
  (interactive "nChange days: ")
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "[[<]" nil t)
      (when (org-at-timestamp-p t)
        (org-timestamp-change n 'day)))))
;; (update-org-days 200)
#+end_src

#+RESULTS:
: update-org-days

#+BEGIN_SRC emacs-lisp
(defun insert-ts+1w ()
  "Insert a timestamp at point that is one week later than the
last timestamp found in the buffer."
  (interactive)
  (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
                              (lambda (timestamp)
                                (org-element-property :raw-value timestamp)))))))
    (insert last-ts)
    (backward-char 2)
    (org-timestamp-change +7 'day)
    ))

#+END_SRC
*** Improved version using stored list value
This nees to go i n the #loca_variables section at the bottom of a file though
#+begin_src emacs-lisp

(defun mwp-get-ts+7 (initial-list-symbol &optional weekly-times)
  "Return a timestamp 7 days later than the WEEKLY-TIMES-th element of INITIAL-LIST-SYMBOL.
Then add that new date to the value of the list."
  (setq weekly-times (or weekly-times 1))
  (let* ((initial-list (symbol-value initial-list-symbol))
         (base-date (nth (1- weekly-times) initial-list) )
         (new-date (format-time-string  "<%Y-%m-%d %a>" ;; "<%b. %d>"    ;; 
                                       (time-add
                                        (date-to-time base-date) (days-to-time (1+ 7))))))
    (add-to-list initial-list-symbol  new-date )
    ;;(format-time-string "%b . %d" new-date)
    new-date
    ;; (if base-date
    ;;     (format-time-string "<%Y-%m-%d %a>"
    ;;                         (time-add
    ;;                          (date-to-time base-date) (days-to-time (1+ 7))))
    ;;   "NO PREVIOUS TIMESTAMP")
    ))
#+end_src

#+RESULTS:
: mwp-get-ts+7

** Evaluate export macros and show results in buffer

Someimtes I really want to see the results of an export macro while I'm working. This makes that possible.  

#+begin_src emacs-lisp

(defun mwp-show-macros ()
  (interactive)
  (remove-overlays (point-min) (point-max) 'macro-ov-p t)
  (hack-local-variables)
  ;; (message "mwp-classtimes-calibrate: %s" mwp-classtimes-calibrate)
  ;; (message "file-local vars: %s" file-local-variables-alist)
  (save-excursion
    (goto-char (point-min))
    ;; keeping this properties/keywordsstuff b/c I don't quite understand it
    (let* ((keywords nil)
           (properties-regexp (format "\\`EXPORT_%s\\+?\\'"
				      (regexp-opt keywords)))
	   record)
      (while (re-search-forward "{{{[-A-Za-z0-9_]" nil t)
        (unless (save-match-data (org-in-commented-heading-p))
          (let* ((datum (save-match-data (org-element-context)))
	         (type (org-element-type datum))
	         (macro
	          (cond
		   ((eq type 'macro) datum)
		   ;; In parsed keywords and associated node
		   ;; properties, force macro recognition.
		   ((or (and (eq type 'keyword)
			     (member (org-element-property :key datum) keywords))
		        (and (eq type 'node-property)
			     (string-match-p properties-regexp
					     (org-element-property :key datum))))
		    (save-excursion
		      (goto-char (match-beginning 0))
		      (org-element-macro-parser))))))
	    (when macro
	      (let* ((key (org-element-property :key macro))
		     (value (org-macro-expand macro org-macro-templates))
                     (value-ts (ignore-errors
                                 (apply 'encode-time (org-fix-decoded-time
                                                      (org-parse-time-string value)))))
		     (begin (org-element-property :begin macro))
                     (end (save-excursion
                            (goto-char (org-element-property :end macro))
		            (skip-chars-backward " \t")
		            (point)))
		     (signature (list begin
				      macro
				      (org-element-property :args macro))))
	        ;; Avoid circular dependencies by checking if the same
	        ;; macro with the same arguments is expanded at the
	        ;; same position twice.
                (when value-ts
                  (setq value (format-time-string
                               (substring (car org-time-stamp-custom-formats) 1 -1) value-ts)))
	        (cond ((member signature record)
		       (error "Circular macro expansion: %s" key))
		      (value
		       (push signature record)
		       (let ((ov (make-overlay begin end)))
                         (overlay-put ov 'invisible t)
                         (overlay-put ov 'evaporate t)
                         (overlay-put ov 'macro-ov-p t)
		         (overlay-put ov 'before-string value )))
		      ;; Special "results" macro: if it is not defined,
		      ;; simply leave it as-is.  It will be expanded in
		      ;; a second phase.
		      ((equal key "results"))
		      (t
		       ;; (error "Undefined Org macro: %s; aborting"
		       ;;        (org-element-property :key macro))
                       )))))))))
  (org-macro--counter-initialize)
  (setq-local mwp-macro-overlays t)
  (hack-local-variables)
  ;;(run-hooks 'mwp-show-macros-final-hook)
  
  )


(defvar-local mwp-show-macros-final-hook nil )

(defun mwp-hide-macros ()
  (interactive)
  (remove-overlays (point-min) (point-max) 'macro-ov-p t)
  (setq-local mwp-macro-overlays nil)
  )

(defun mwp-toggle-macros ()
  (interactive)
  (if mwp-macro-overlays
      (mwp-hide-macros)
    (mwp-show-macros)) )

(defvar-local mwp-macro-overlays nil)

(defun mwp-macro-advice (&optional a b c d e f &rest g)
  "If hsowing macros, update after doing some things."
  (when mwp-macro-overlays
    (mwp-show-macros)
    ))

;; (advice-add 'org-move-subtree-down :after mwp-macro-advice)

(advice-add 'org-move-subtree-down :after  'mwp-macro-advice)
(advice-add 'org-insert-heading :after  'mwp-macro-advice)
;; (advice-remove 'org-insert-heading   'mwp-macro-advice)
;; (advice-remove 'org-clean-visibility-after-subtree-move  'mwp-macro-advice)
#+end_src

#+RESULTS:

#+RESULTS:
| quote | hack-local-variables |

** Helm and Org
Not sure what I wanted here. There's a whole bunch of stuff here about helm..
which I don't remember having done myself.

#+BEGIN_SRC emacs-lisp
    ;; helm-bibtex
    (use-package helm

    )
    (use-package helm-org
      :defer 3
      :bind
      (:map org-mode-map ("C-c h o" . helm-org-in-buffer-headings))
  )   
    (use-package helm-config
      :after (helm org)
      :config
          (helm-mode 1)

      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to do persistent action
      (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
      (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

      (helm-autoresize-mode t)
      (setq helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match    t)
      (global-set-key (kbd "M-x") 'helm-M-x)
      (global-set-key (kbd "M-y") 'helm-show-kill-ring)
      (global-set-key (kbd "C-x C-f") 'helm-find-files)
      (global-set-key (kbd "C-x b") 'helm-mini)

      ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
      ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
      ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
      (global-set-key (kbd "C-c h") 'helm-command-prefix)
      (global-unset-key (kbd "C-x c"))


      (when (executable-find "curl")
        (setq helm-google-suggest-use-curl-p nil))

      (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
            helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
            helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
            helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
            helm-ff-file-name-history-use-recentf t)

      (setq helm-grep-ag-command "ag --line-numbers -S --hidden --color --color-match '31;43' --nogroup %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--color-match '31;43'"))
    
      ;; (when (executable-find "ack-grep")
      ;;   (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
      ;;         helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))
      (global-set-key (kbd "C-c h c") 'helm-occur)

      (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
      (global-set-key (kbd "C-c h g") 'helm-google-suggest)
      (add-to-list 'helm-completing-read-handlers-alist '(zotxt-completing-read . helm-comp-read )))
    (use-package helm-bibtex
      :after helm-config
      :config
  
      (defun helm-bibtex-format-pandoc-citation (keys)
        (concat "[" (mapconcat (lambda (key) (concat "@" key)) keys "; ") "]"))

      ;; inform helm-bibtex how to format the citation in org-mode
      ;; (setf (cdr (assoc 'org-mode helm-bibtex-format-citation-functions))
      ;;       'helm-bibtex-format-pandoc-citation)
      (setf (cdr (assoc 'org-mode helm-bibtex-format-citation-functions))
            'helm-bibtex-format-citation-ebib))


#+END_SRC

#+RESULTS:
: t

** WAITING Search
I need to figure out all the search options -- recoll, swish-e, etc.  I need something I can do from emacs
http://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.SEARCH.COMMANDLINE.html
https://www.google.com/search?q=org-mode+search+filesrecoll&ie=utf-8&oe=utf-8&client=firefox-b-ab
http://irreal.org/blog/?p=5844
http://kitchingroup.cheme.cmu.edu/blog/2017/01/03/Find-stuff-in-org-mode-anywhere/
have also installed helm-org-rifle which is pretty cool too, though not quite the same:
https://github.com/alphapapa/helm-org-rifle

*** Helm-swish-e
An indexer for forg-mode files.  from: http://kitchingroup.cheme.cmu.edu/blog/2015/06/25/Integrating-swish-e-and-Emacs/

A much cooler version is described here:
http://kitchingroup.cheme.cmu.edu/blog/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results/

But requires some setup first.  
#+BEGIN_SRC emacs-lisp
  (defun helm-swish-e-candidates (query)
    "Generate a list of cons cells (swish-e result . path)."
    (let* ((result (shell-command-to-string
                    (format "swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"
                            (shell-quote-argument query))))
           (lines (s-split "\n" result t))
           (candidates '()))
      (loop for line in lines
            unless (or  (s-starts-with? "#" line)
                        (s-starts-with? "." line))
            collect (cons line (cdr (s-split "\t" line))))))


  (defun helm-swish-e (query)
    "Run a swish-e query and provide helm selection buffer of the results."
    (interactive "sQuery: ")
    (helm :sources `(((name . ,(format "swish-e: %s" query))
                      (candidates . ,(helm-swish-e-candidates query))
                      (action . (("open" . (lambda (f)
                                             (find-file (car f)))))))
                     ((name . "New search")
                      (dummy)
                      (action . (("search" . (lambda (f)
                                               (helm-swish-e helm-pattern)))))))))
#+END_SRC

second try from jmax
#+BEGIN_SRC emacs-lisp
  ;;; swish-e.el --- Interface to swish-e

  ;;; Commentary:
  ;;

  ;; This is the configuration file I used.
  ;; # Example configuration file

  ;; # where to save the index
  ;; IndexFile /Users/jkitchin/.swish-e/index-org.swish-e

  ;; PropertyNames swish-position

  ;; # Save descriptions for context on search results.
  ;; StoreDescription XML <desc> 500
  ;; StoreDescription XML* <desc> 500

  ;; # index all tags for searching
  ;; UndefinedMetaTags auto
  ;; UndefinedXMLAttributes auto

  ;; Run the index command as:
  ;; swish-e -c ~/.swish-e/swish-org.conf -S prog -i ~/bin/swish-org-documents.el

  ;;; Code:

  (defvar swish-e-index
    "~/.swish-e/index-org.swish-e"
    "Path to the index for searching.")


  (defun helm-swish-e-candidates (query)
    "Generate a list of cons cells (swish-e result . path)."
    (let* ((result (shell-command-to-string
		    (format "swish-e -f %s -x \"<swishrank>\t<swishdocpath>\t<swish-position>\t<swishtitle>\t<swishdescription>\n\" -w %s"
			    swish-e-index
			    (shell-quote-argument query))))
	   (lines (s-split "\n" result t))
	   (candidates '()))
      (loop for line in lines
	    unless (or  (s-starts-with? "#" line)
		        (s-starts-with? "." line))
	    collect  (let* ((fields (s-split "\t" line))
			    (rank (nth 0 fields))
			    (docpath (nth 1 fields))
			    (position (nth 2 fields))
			    (title (nth 3 fields))
			    (description (nth 4 fields)))
		       (cons (format "%4s %s%s\n%s\n"
				     rank title (if (not (string= "" position))
						    (concat  "::" position)
						  "")
				     description)
			     docpath)))))


  (defun helm-swish-e (query)
    "Run a swish-e query and provide helm selection buffer of the results.
  Example queries:
  paragraph=foo
  src-block.language=python
  not foo
  foo near5 bar
  see http://swish-e.org/docs/swish-search.html
  "
    (interactive "sQuery: ")
    (helm :sources `(((name . ,(format "swish-e: %s" query))
		      (multiline)
		      (candidates . ,(helm-swish-e-candidates query))
		      (action . (("open" . (lambda (f)
					     (org-open-link-from-string f))))))
		     ((name . "New search")
		      (dummy)
		      (action . (("search" . (lambda (f)
					       (helm-swish-e helm-pattern)))))))))

  (defun swish-e-todo ()
    (interactive)
    (helm-swish-e "todo-keyword=TODO"))

  (provide 'swish-e)

  ;;; swish-e.el ends here
#+END_SRC

** Org-mode html/slack copy
This code from John Kitchen & abo-abo makes it a lot easier to copy text directly from org to other programs:
- [[https://github.com/abo-abo/oremacs/commit/6c86696c0a1f66bf690e1a934683f85f04c6f34d#diff-ecff87135600df0cafffb47c303ae9c6][abo-abo's code from oremacs]]
- [[http://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/#comment-2735698988][john's original post]]
expanding this to use additional options; could just be gneeralized, though relaly only html copy needs the elaborate copying to a tmp file.   

#+begin_src emacs-lisp
(use-package ox-slack
      :load-path "~/src/ox-slack"
      :pin manual
      :defer nil
      ;; :preface
      ;; (require 'ox-md)
      ;; (require 'ox-gfm)
      ;; :after (org )
      ;; :bind
      ;; ("C-c W s" . org-slack-export-to-clibpoard-as-slack)
      )
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results code
  (defun ora-org-to-html-to-clipboard ()
    "Export region to HTML, and copy it to the clipboard."
    (interactive)
    (let
        ((org-html-postamble nil)
         (org-html-xml-declaration nil)
         (org-html-preamble nil))

      (org-export-to-file 'html "/tmp/org.html")
      (apply ; comment
       'start-process "xclip" "*xclip*"
       (split-string
        "xclip -verbose -i /tmp/org.html -t text/html -selection clipboard" " "))))

  (defun ora-org-to-slack-to-clipboard ()
    "Export region to md, and copy it to the clipboard."
    (interactive)
    (let
        ((org-html-postamble nil)
         (org-html-xml-declaration nil)
         (org-html-preamble nil))

      (org-export-to-file 'slack "/tmp/org.slack")
      (apply
       'start-process "xclip" "*xclip*"
       (split-string
        "xclip -verbose -i /tmp/org.slack -t text/plain -selection clipboard" " "))))

  (defun ora-org-export-to-clipboard-as-slack ()
    "Export region to FMT, and copy to the kill ring for pasting into other programs."
    (interactive)
    (let* ((org-export-with-toc nil)
           (org-export-with-smart-quotes nil))
      (kill-new (org-export-as 'slack) ))
    )

  (defun mwp-org-export-to-clipboard (fmt)
    "Export region to FMT, and copy to the kill ring for pasting into other programs."
    (interactive)
    (let* ((org-export-with-toc nil)
           (org-export-with-smart-quotes nil))
      (kill-new (org-export-as fmt t nil t)) ;; first t limits to subtree, second makes it body-only
      )
    )

  ;; (use-package ox-md
  ;;   :load-path: "~/src/org-mode/emacs/site-lisp/org/"
  ;;   :after org
  ;;   :config
  ;;   (org-export-register-backend 'md)
  ;;   (require 'ox-gfm)

  ;;   )
  ;; ;;  (require 'ox-md)
  ;; ;;(org-export-register-backend 'gfm)
  ;; ;; (with-eval-after-load "ox-md" )
  ;; (with-eval-after-load "ox-gfm" (org-export-register-backend 'gfm))




  ;; ;;(global-set-key (kbd  "C-c W h") 'ora-org-to-html-to-clipboard)

  ;;(global-set-key (kbd "C-c W s") 'ora-org-export-to-clipboard-as-slack)
#+END_SRC

** Inverse: HTML from browser to org-mode using xclip and pandoc
It's also tedious to copy html from the browser to org. usually I just want to copy some text, not use a complex capture template (since I never integrated org-capture into my regular workflow). 

there's stuff like [[https://github.com/alphapapa/org-protocol-capture-html][this org-protocol code from plphapapa]] but I don't find it easy to use.  

Instead stealing code form [[https://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][stack overflow]] and binding to "C-M-y", at least for now. Pandoc inserts a lot of extraneous crap but still this is OK for now! Not usre that the JSON really helps me much, but hard to say. 
#+begin_src emacs-lisp
(defun mwp/html2org-clipboard ()
  "Convert clipboard contents from HTML to Org and then paste (yank)."
  (interactive)
  (kill-new (shell-command-to-string "xclip -o -t TARGETS | grep -q text/html && (xclip -o -t text/html | pandoc -f html -t json | pandoc --wrap=none -f json -t org) || xclip -o"))
  (yank))

(global-set-key (kbd "C-M-y") 'mwp/html2org-clipboard)
#+end_src
 
#+RESULTS:
: mwp/html2org-clipboard

** More of the mixed up stuff

this is a mess and a lot should be dropped. 
#+BEGIN_SRC emacs-lisp
  ;; ibuffer
  (use-package ibuffer
    :config
  

    (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("dired" (mode . dired-mode))
                   ("java" (mode . java-mode))
                   ("org" (mode . org-mode))
                   ("JS" (or (mode . js2-mode) (mode . json-mode)))
                   ("web" (or (mode . web-mode) (mode . html-mode) (mode . css-mode)))
                   ("mu4e" (name . "\*mu4e\*"))
                   ("elisp" (mode . emacs-lisp-mode))
                   ("xml" (mode . nxml-mode))))))    

    (setq ibuffer-show-empty-filter-groups nil)

    (add-hook 'ibuffer-mode-hook 
              (lambda () 
                (ibuffer-switch-to-saved-filter-groups "default")
                (ibuffer-auto-mode 1)
                (ibuffer-filter-by-filename ".")))) ;; to show only dired and files buffers


  ;; org-mobile
  (setq org-mobile-directory "~/Dropbox/MobileOrg")
  ;; ace
  ;; 
  ;; enable a more powerful jump back function from ace jump mode
  ;;
  (define-key global-map (kbd "C-c C-SPC") 'ace-jump-mode)
  (autoload
    'ace-jump-mode-pop-mark
    "ace-jump-mode"
    "Ace jump back:-)"
    t)
  (eval-after-load "ace-jump-mode"
    '(ace-jump-mode-enable-mark-sync))
  (define-key global-map (kbd "C-x C-SPC") 'ace-jump-mode-pop-mark)

  ;; which function mode
  (use-package which-func)
  ;;(add-to-list 'which-func-modes 'org-mode)
  (which-func-mode 1)


  ;; open links
  ;; (setcdr (assq 'system org-file-apps-defaults-gnu ) '(call-process "xdg-open" nil 0 nil file))
  ;; ox-reveal, change initialization options


  ;; github (pull requests!!! )

  (defun endless/visit-pull-request-url ()
    "Visit the current branch's PR on Github."
    (interactive)
    (browse-url
     (format "https://github.com/%s/pull/new/%s"
             (replace-regexp-in-string
              "\\`.+github\\.com:\\(.+\\)\\.git\\'" "\\1"
              (magit-get "remote"
                         (magit-get-push-remote)
                         "url"))
             (magit-get-current-branch))))

  ;; (defun endless/visit-pull-request-url ()
  ;;   "Visit the current branch's PR on Github."
  ;;   (interactive)
  ;;   (browse-url
  ;;    (format "https://github.com/%s/compare/%s"
  ;;            (replace-regexp-in-string
  ;;             "\\`.+github\\.com:\\(.+\\)\\.git\\'" "\\1"
  ;;             (magit-get "remote"
  ;;                        (magit-get-current-remote)
  ;;                        "url"))
  ;;            (magit-get-current-branch))))

  (eval-after-load 'magit
    '(define-key magit-mode-map "V"
       #'endless/visit-pull-request-url))


  ;; change default c-u values for C-c C-l
  (defun mwp-org-insert-link (&optional complete-file link-location default-description)
    "insert a link at location, but insert a letave link by default, and absolute one only by necessity."
    (interactive)
    (cond
     ((eq current-prefix-arg nil)
      (let ((current-prefix-arg 4)) 
        (call-interactively 'org-insert-link)))
     (t
      (let ((current-prefix-arg nil)) 
        (call-interactively 'org-insert-link)))
     ;;(t (call-interactively 'org-insert-link))
     ))

#+END_SRC

#+RESULTS:
: mwp-org-insert-link

** WAITING Mailing subtrees with Attachments                        :review:
:PROPERTIES:
:ID:       o2b:f2904bd7-c966-4c5a-91c6-6cad0b0f22ef
:POST_DATE: [2015-07-15 Wed 15:17]
:END:
*this really needs to be updated to the new org-mime functions!!!!!!!!!*

This is pretty exciting; I've figured out how to quickly send org-mode subtrees as MIME-encoded emails.  That means that, essentially, I can write in org, as plain text, and very quickly export to HTML, add attachments, and send. The exciting part about this for me is that it should streamline my communications with students, while also letting me stay in Org and keep my records in order. Let's walk through the process.

*** Use-case
For the moment, I still use Thunderbird as my primary MUA. It's pretty easy to use, minimal configuration compared to all things Emacs, and if something goes wrong with it I don't have to quit Emacs (!), just Thunderbird.

In some cases, though, Thunderbird makes for an awkward workflow. That's certainly the case for grading, whih has many, poorly-integrated elements. To mark an assignment I need to:
- log in to Blackboard (in Firefox; I wonder if I could do that in Emacs?)
- download the set of student papers (one at a time, 2 clicks per paper) to ~Downlads~
- move papers to a directory (usually ~/COURSENAME/Grading/ASSIGNMENTNAME )
- Read papers in LibreOffice, comment inline
- record mark in Libreoffice Calc spreadsheet
- email paper back to student with comments
- upload marks back into Blackboard
- find a place to archive the student paper in case I need it later, e.g. for a contested grade.  

The whole process basically sucks. I spend maybe 20% of my time fussing with paths and mouse clicks and email addresses. So I am experimenting with moving as much of this process into Emacs. So far, I don't think there's any way at all to bulk-download the papers -- that sucks, but I can live with it I guess (I have to!).  So I start the optimization at the point where I have all my papers ready to go in a subdir.

*** Org-mime
Org-mime is the library that allows org buffers and other elements to be quickly converted to HTML and prepared for multi-part messaging.  Load it and set it up (see [[http://orgmode.org/worg/org-contrib/org-mime.html]]):
#+BEGIN_SRC emacs-lisp
;; enable HTML email from org
(use-package org-mime
  :ensure t
  :load-path "~/src/org-mime/"
  :config
  ;; pretty blockquotes
  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "blockquote" "margin: 0 0 0 .8ex; border-left: 1px solid #ccc; padding-left: 1ex;")
              (org-mime-change-element-style
               "pre" (format "color: %s; background-color: %s; border-radius: 5px; font-size: 1.3em; padding: 1.5em;"
                             "#E6E1DC" "black")) 
              (org-mime-change-element-style
               "code" (format "border: 1px solid black; border-radius: 10px; font-size: 1.2em; font-family: monospace;  background-color: hotpink; padding: 0.5em;"
                              ))))


  (setq org-mime-library 'mu4e)
  (setq org-mime-debug t)
  ;; setup org-mime for wanderlust
  ;; (setq org-mime-library 'semi)
  ;; or for gnus/message-mode
  (setq org-mime-library 'mu4e))

;; easy access to htmlize in message-mode
(add-hook 'message-mode-hook
          (lambda ()
            (local-set-key "\C-c\M-o" 'org-mime-htmlize)))

;; uncomment this to use the org-mome native functions for htmlizing.
;; (add-hook 'org-mode-hook
;;           (lambda ()
;;             (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))

;; uncomment to displyay src blocks with a dark background
;; (add-hook 'org-mime-html-hook
;;           (lambda ()
;;             (org-mime-change-element-style
;;              "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
;;                            "#E6E1DC" "#232323"))))


(setq user-mail-address "matt.price@utoronto.ca"
      user-full-name "Matt Price")
#+END_SRC

#+RESULTS:
: Matt Price

*** Fix htmlization
Upstream org-mime-htmlize unfortunately can't be called uninteractively (bummer!), 
so we have to rewrite it to make programmatic calls work properly. I found the solution 
[[http://emacs.stackexchange.com/questions/13505/a-function-to-org-mime-subtree-then-org-mime-htmlize][Emacs Stackexchange]].  

OK, but actually this no longer works w/ org-mode 9 I think -- so I've commented it out for now -- the new version works great.  With nullmailer as my smtp agent this is unbelievably fast now.  Pretty fantastic.  

using jkitchin's fork of org-mime really helps, moving to that. 

*** Actually perform the export!

 *NOTE <2019-02-04 Mon>:* These look pretty out of date now; may be time to revisit!

These functions are crude helpers that gather extra information about the org subtree, of which org-mime is unaware.  

- ~mwp-org-get-parent-headline~ traverses the tree to the ancestor headline, because that's what I want to set the subject to.
- ~mwp-org-attachment-list~ is stolen directly from the Gnorb package, which looks cool, awesome ,and kinda complex; it just iterates through a subtree's attachments and grabs URLs.  
- ~mwp-send-subtree-with-attachments~ performs the export and is bound to ~C-c M-o~

So, if I want to mail a subtree, I just ~C-c M-o~ and I'm almost done -- the html mail is ready to go, and all org attachments are also attached to the email.

Note there are some real weaknesses here: ~mwp-org-get-parent-headline~ actually gets the top-level /ancestor/ -- which only happens to be what I want right now. Better would be to use org-element to locate the parent (and other headline attributes) directly, but I'm not sure how to do that.

Similarly, the initial greeting is generated from the current headline value -- so this only works because I name my subtrees after the addressee (which I only do because of my use case).  


*URGENT URGENT URGENT*: need to amend mwp-send-subtre-with-attachemnts to make mu4e~draft-drafts-folder into mu4e-drafts-folder before calling mu4e-send. That *might* start to slve the problm w/ stuff not being saved.  
#+BEGIN_SRC emacs-lisp
  (defun mwp-org-get-parent-headline ()
    "Acquire the parent headline & return."
    (save-excursion
      (org-mark-subtree)
      (re-search-backward  "^\\* ")
      (nth 4 (org-heading-components))))

  (defun mwp-send-subtree-with-attachments ()
    "org-mime-subtree and HTMLize"
    (interactive)
    ;;(org-mark-subtree)
    (let ((attachments (mwp-org-attachment-list))
          (subject  (mwp-org-get-parent-headline)))
      ;;(insert "Hello " (nth 4 org-heading-components) ",\n")
      ;;(org-mime-subtree)
      (org-mime-send-subtree)
      (insert "\nBest,\nMP.\n")
      (message-goto-body)
      (insert "Hello,\n\nAttached are the comments from your assignment.\n")
      ;; (message "subject is" )
      ;; (message subject)
      ;;(message-to)
      (org-mime-htmlize)
      ;; (mu4e-compose-mode)
      ;; this comes from gnorb
      ;; I will reintroduce it if I want to reinstate questions.
      ;; (map-y-or-n-p
      ;;  ;; (lambda (a) (format "Attach %s to outgoing message? "
      ;;  ;;                    (file-name-nondirectory a)))
      ;; (lambda (a)
      ;;   (mml-attach-file a (mm-default-file-encoding a)
      ;;                    nil "attachment"))
      ;; attachments
      ;; '("file" "files" "attach"))
      ;; (message "Attachments: %s" attachments)
      (dolist (a attachments) (message "Attachment: %s" a) (mml-attach-file a (mm-default-file-encoding a) nil "attachment"))
      (message-goto-to)
      ))

  ;; add a keybinding for org-mode
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'mwp-send-subtree-with-attachments)))

  ;; stolen from gnorb; finds attachments in subtree
  (defun mwp-org-attachment-list (&optional id)
    "Get a list of files (absolute filenames) attached to the
  current heading, or the heading indicated by optional argument ID."
    (when (featurep 'org-attach)
      (let* ((attach-dir (save-excursion
                           (when id
                           (org-id-goto id))
                           (org-attach-dir t)))
             (files
              (mapcar
               (lambda (f)
                 (expand-file-name f attach-dir))
               (org-attach-file-list attach-dir))))
        files)))
#+END_SRC
(setq starttls-extra-arguments '("--priority" "NORMAL:%COMPAT"))
*** Attachment Improvemnts: drag & drop; allow existing            :ATTACH:
:PROPERTIES:
:Attachments: minimal.el
:ID:       7c9d8afa-0b2d-4be6-94b4-b586b4ea3bd7
:END:
After I make inline comments, I fill out a grading template and attach the paper to the resultant subtree (@@html:<kbd>C-c C-a a PATH</kbd>@@).  This is OK, but sometimes it would nice to be able to drag and drom the files, so I am working on these functions. 

- Even better :: an even better solution be to add the attachments programmatically. The studnet papes follow a strict naming convention, so I should be able to crawl the directory and find the most recent paper with the student's name in it... I'm worried it wil lbe too error prone though.
     
Anyway: unfortunately the following code doesn't work right, so *don't just cut and paste this code!).  I *ought* to be able to bind the drag and drop action to a function -- even several functions -- and, if conditions are right, attach the dragged file to the current org header.  John Kitchin describes this method [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/10/Drag-images-and-files-onto-org-mode-and-insert-a-link-to-them/][here]]. But I do the following instead, which is also broken right now:

Start by loading org-download, which downloads dragged images as attachments and inserts a link. (yay). THen a modification which fixes handling of file links allowing me to drag-n-drop files links onto org as attachments. Unfortunately, I can't get org-attach to process the URI's properly.  Darn it.  

*EDIT <2018-11-27 Tue>:* modify org-attach-attach to allow existing symbolic links, which fixes the errors I'm getting on attachment whenever I repeat a download or similar.  
#+BEGIN_SRC emacs-lisp
(use-package org-download)
(use-package org-attach
  :config
  (defun org-attach-attach (file &optional visit-dir method)
  "Move/copy/link FILE into the attachment directory of the current task.
If VISIT-DIR is non-nil, visit the directory with dired.
METHOD may be `cp', `mv', `ln', `lns' or `url' default taken from
`org-attach-method'."
  (interactive
   (list
    (read-file-name "File to keep as an attachment:"
                    (or (progn
                          (require 'dired-aux)
                          (dired-dwim-target-directory))
                        default-directory))
    current-prefix-arg
    nil))
  (setq method (or method org-attach-method))
  (let ((basename (file-name-nondirectory file)))
    (when (and org-attach-file-list-property (not org-attach-inherited))
      (org-entry-add-to-multivalued-property
       (point) org-attach-file-list-property basename))
    (let* ((attach-dir (org-attach-dir t))
           (fname (expand-file-name basename attach-dir)))
      (cond
       ((eq method 'mv) (rename-file file fname))
       ((eq method 'cp) (copy-file file fname))
       ((eq method 'ln) (add-name-to-file file fname))
       ((eq method 'lns) (make-symbolic-link file fname t))
       ((eq method 'url) (url-copy-file file fname)))
      (when org-attach-commit
        (org-attach-commit))
      (org-attach-tag)
      (cond ((eq org-attach-store-link-p 'attached)
             (org-attach-store-link fname))
            ((eq org-attach-store-link-p t)
             (org-attach-store-link file)))
      (if visit-dir
          (dired attach-dir)
        (message "File %S is now a task attachment." basename))))))
;; extending the dnd functionality
;; but doesn't actually work... 
(defun mwp-org-file-link-dnd (uri action)
    "When in `org-mode' and URI points to local file, 
  add as attachment and also add a link. Otherwise, 
  pass URI and Action back to dnd dispatch"
    (let ((img-regexp "\\(png$\\|jp[e]?g$\\)")
          (newuri (replace-regexp-in-string "file:///" "/" uri)))
      (cond ((eq major-mode 'org-mode)
             (message "Hi! newuri: %s " (file-relative-name newuri))
             (cond ((string-match img-regexp newuri)
                    (insert "#+ATTR_ORG: :width 300\n")
                    (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
                    (insert (format "[[%s]]" uri))
                    (org-display-inline-images t t))
                   (t 
                    (org-attach-new newuri)
                    (insert (format "[[%s]]" uri))))
             )
            (t
             (let ((dnd-protocol-alist
                    (rassq-delete-all
                     'mwp-org-file-link-dnd
                     (copy-alist dnd-protocol-alist))))
               (dnd-handle-one-url nil action uri)))
            )))

  ;; add a new function that DOESN'T open the attachment!
(defun org-attach-new-dont-open (file)
    "Create a new attachment FILE for the current task.
  The attachment is created as an Emacs buffer."
    (interactive "sCreate attachment named: ")
    (when (and org-attach-file-list-property (not org-attach-inherited))
      (org-entry-add-to-multivalued-property
       (point) org-attach-file-list-property file))
    )

(defun mwp-org-file-link-enable ()
    "Enable file drag and drop attachments."
    (unless (eq (cdr (assoc "^\\(file\\)://" dnd-protocol-alist))
                'mwp-org-file-link-dnd)
      (setq dnd-protocol-alist
            `(("^\\(file\\)://" . mwp-org-file-link-dnd) ,@dnd-protocol-alist))))

(defun mwp-org-file-link-disable ()
  "Enable file drag and drop attachments."
  (if (eq (cdr (assoc "^\\(file\\)://" dnd-protocol-alist))
              'mwp-org-file-link-dnd)
      (rassq-delete-all
       'mwp-org-file-link-dnd
       dnd-protocol-alist)

    ))

(mwp-org-file-link-enable)

#+END_SRC

*** Another attempt at attachments: attachfile
John Kitchin uses a custom link type, "attachfile", for a ocupleo f things, and describes it in some detail [[

#+BEGIN_SRC emacs-lisp
  (org-add-link-type
   "attachfile"
   (lambda (link-string) (org-open-file link-string))
   ;; formatting
   (lambda (keyword desc format)
     (cond
      ((eq format 'html) (source-data-uri keyword)); no output for html
      ((eq format 'latex)
       ;; write out the latex command
       (format "\\attachfile{%s}" keyword)))))

(  defun source-data-uri (source)
    "Encode the string in SOURCE to a data uri."
    (format
     "<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\">source</a>"
     (base64-encode-string source)))

#+END_SRC

** Note Taking with PDF Tools
:PROPERTIES:
:ID:       o2b:6ff4548c-1ab7-4ec0-af5a-8b65892ff412
:POSTID:   38
:BLOG:     matt
:POST_DATE: [2015-11-11 Wed 15:11]
:END:

*NOTE:* This post has been modified as of <2015-11-22 Sun> -- the new code is a little cleaner, and I think the discussion a little fuller. 

Almost all of my job-elated reading is now done on a screen.  There are still disadvantages -- I find it much harder to concentrate when reading online -- but in other ways it is markedly more convenient.  

In particular, it is now much easier to assemble quotations from sources; and now that I've found [[https://github.com/politza/pdf-tools][PDF Tools]], it has become even easier.  I've just  started to use it to extract annotations from my PDF's, and it works much better than the lousy command-line hack I was using previously.  

As we're mid-semester, most of my reading is for classes I teach. My current workflow is as follows: 
- Assemble the relevant readings in a Dropbox-synced directory (ClassName/Readings)
- Using [[http://m.cerience.com/reader/][Repligo Reader]] (apparently no longer available in the app store?), highlight the passages I'm interested in.
- execute code block (see below) to insert org headings with all highlights from one or more pdfs
- Assemble reveal.js lecture presentation around those highlights, using [[https://github.com/yjwen/org-reveal][org-reveal]] or Pandoc.  

*** Activating PDF Tools
Begin by installing pdf-tools and org-pdfview from ELPA with ~package-list~packages~ or ~package-install~.  

Then make sure they are activated by adding these lines in your init file:

#+BEGIN_SRC emacs-lisp
  ;; wrapper for save-buffer ignoring arguments
  (defun bjm/save-buffer-no-args ()
    "Save buffer ignoring arguments"
    (save-buffer))

  (use-package pdf-tools
   ;; :pin manual ;; manually update
   :config
   ;; initialise
   (pdf-tools-install)
   ;; open pdfs scaled to fit page
   ;; not quite sure I want this
   ;; (setq-default pdf-view-display-size 'fit-page)
   ;; automatically annotate highlights
   ;; when set to true this makes highlighting also open up a comment box
   (setq pdf-annot-activate-created-annotations nil)
   ;; use normal isearch
   ;; (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
   (define-key pdf-view-mode-map (kbd "M-h") 'pdf-annot-add-highlight-markup-annotation)
   (define-key pdf-view-mode-map (kbd "<tab>") 'pdf-annot-add-highlight-markup-annotation)
   ;; keyboard shortcuts
   (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
   (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
   (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete)
   ;; wait until map is available
   (with-eval-after-load "pdf-annot"
     (define-key pdf-annot-edit-contents-minor-mode-map (kbd "<return>") 'pdf-annot-edit-contents-commit)
     (define-key pdf-annot-edit-contents-minor-mode-map (kbd "<S-return>") 'newline)
     ;; DON;T ACTUALLY OD THIS BY DEFAULT
     ;; (setq pdf-annot-activate-created-annotations t)
     ;; save after adding comment
     (advice-add 'pdf-annot-edit-contents-commit :after 'bjm/save-buffer-no-args)

   ))
  ;; better learn the right place to put this code!
      (eval-after-load 'org '(use-package org-pdfview))
    (add-to-list 'org-file-apps '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))

#+END_SRC

#+RESULTS:
: ((\.odt\' . /usr/bin/libreoffice %s) (\.doc\' . /usr/bin/libreoffice %s) (\.docx\' . /usr/bin/libreoffice %s) (\.pdf::\([[:digit:]]+\)\' . org-pdfview-open) (\.pdf\' lambda (file link) (org-pdfview-open link)) (auto-mode . emacs) (\.mm\' . default) (\.x?html?\' . /usr/bin/firefox-nightly %s) (\.pdf\' . default))

*** Switching to PDF Tools for annotating and extracting PDF's

Last month Penguim proposed some changes in a [[https://github.com/politza/pdf-tools/pull/133][pull request]], that export annotations as a set of org headlines.  It's potentially very interesting but not quite what I want to do, so I modified this code.  ~pdf-annot-markups-as-org-text~ extracts the text of an annotation (stored as the ~subject~ attribute in an alist), and also generates a link back to the page in the pdf.  ~mwp/pdf-multi-extract~ is just a helper function that makes it easier to construct elisp source blocks the way I'm used to doing:

#+BEGIN_SRC emacs-lisp
  ;; modified from https://github.com/politza/pdf-tools/pull/133 

  (defun mwp/pdf-multi-extract (sources)
    "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
  and links back to page of highlight."
    (let (
          (output ""))
      (dolist (thispdf sources)
        (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
      (princ output))
    )

  ;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
  (defun pdf-annot-edges-to-region (edges)
    "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
  We need this to import annotations and to get marked-up text, because annotations
  are referenced by its edges, but functions for these tasks need region."

    (let ((left0 (nth 0 (car edges)))
          (top0 (nth 1 (car edges)))
          (bottom0 (nth 3 (car edges)))
          (top1 (nth 1 (car (last edges))))
          (right1 (nth 2 (car (last edges))))
          (bottom1 (nth 3 (car (last edges))))
          (n (safe-length edges)))
      ;; we try to guess the line height to move
      ;; the region away from the boundary and
      ;; avoid double lines
      (list left0
            (+ top0 (/ (- bottom0 top0) 2))
            right1
            (- bottom1 (/ (- bottom1 top1) 2 )))))

  (defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
    "Acquire highligh annotations as text, and return as org-heading"

    (interactive "fPath to PDF: ")  
    (let* ((outputstring "") ;; the text to be returned
           (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
           (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
           (levelstring (make-string level ?*)) ;; set headline to proper level
           (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                         'pdf-annot-compare-annotations))
           )
      ;; create the header
      (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

      ;; extract text
      (mapc
       (lambda (annot) ;; traverse all annotations
         (if (eq 'highlight (assoc-default 'type annot))
             (let* ((page (assoc-default 'page annot))
                    ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                    (real-edges (pdf-annot-edges-to-region
                                 (pdf-annot-get annot 'markup-edges)))
                    (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                              (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath)
                                                        ) ))
                  
                    (height (nth 1 real-edges)) ;; distance down the page
                    ;; use pdfview link directly to page number
                    (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                      "++" (number-to-string height) "][" title  "]]" ))
                    )
               (setq outputstring (concat outputstring text " ("
                                          linktext ", " (number-to-string page) ")\n\n"))
               )))
       annots)
      outputstring ;; return the header
      )
    )

#+END_SRC

#+RESULTS:
: pdf-annot-markups-as-org-text

*** Using in Org with a Source Block

Now it's more or less trivial to quickly generate the org headers using a source block:

#+BEGIN_EXAMPLE
#+BEGIN_SRC elisp :results output raw :var level=(1+ (org-current-level))
(mwp/pdf-multi-extract '(
                   "/home/matt/HackingHistory/readings/Troper-becoming-immigrant-city.pdf"  "/home/matt/HackingHistory/readings/historical-authority-hampton.pdf"))

#+END_SRC
#+END_EXAMPLE
And the output gives something like

#+BEGIN_EXAMPLE
*** Quotes From Troper becoming immigrant city

Included in the Greater Toronto Area multiethnic mix are an estimated 450,000 Chinese, 400,000 Italians, and 250,000 African Canadians, the largest component of which are ofCar- ibbean background, although a separate and distinct infusion of Soma- lis, Ethiopians, and other Africans is currently taking place. ([[pdfview:/home/matt/HackingHistory/readings/Troper-becoming-immigrant-city.pdf::3][Troper becoming immigrant city]], 3)

Although Toronto is Canada's leading immigrant-receiving centre, city officials have neither a hands-on role in immigrant selection nor an official voice in deciding immigration policy. In Canada, immigration policy and administration is a constitutional responsibility of the fed- eral government, worked out in consultation with the provinces. ([[pdfview:/home/matt/HackingHistory/readings/Troper-becoming-immigrant-city.pdf::4][Troper becoming immigrant city]], 4)

#+END_EXAMPLE
*** Alternative: Temporary buffer with custom link type
An alternative workflow would be to pop to a second, temporary buffer and insert the annotations there; one could do this with a custom link type.  PDF-Tools already has a mechanism for listing annotations in a separate buffer, but it's not designed for quick access to all annotations at once. Anyway, here's one way to do this; I'm not really using it at the moment.

#+BEGIN_SRC emacs-lisp
  (org-add-link-type "pdfquote" 'org-pdfquote-open 'org-pdfquote-export)

  (defun org-pdfquote-open (link)
    "Open a new buffer with all markup annotations in an org headline."
    (interactive)
    (pop-to-buffer
     (format "*Quotes from %s*"
             (file-name-base link)))
    (org-mode)
    (erase-buffer)
    (insert (pdf-annot-markups-as-org-text link nil 1))
    (goto-char 0)
    )

  (defun org-pdfquote-export (link description format)
    "Export the pdfview LINK with DESCRIPTION for FORMAT from Org files."
    (let* ((path (when (string-match "\\(.+\\)::.+" link)
                   (match-string 1 link)))
           (desc (or description link)))
      (when (stringp path)
        (setq path (org-link-escape (expand-file-name path)))
        (cond
         ((eq format 'html) (format "<a href=\"%s\">%s</a>" path desc))
         ((eq format 'latex) (format "\href{%s}{%s}" path desc))
         ((eq format 'ascii) (format "%s (%s)" desc path))
         (t path)))))

  (defun org-pdfquote-complete-link ()
    "Use the existing file name completion for file.
  Links to get the file name, then ask the user for the page number
  and append it."                                  

    (replace-regexp-in-string "^file:" "pdfquote:" (org-file-complete-link)))
#+END_SRC

I've also added two bindings to make highlighting easier from the PDF buffer:

Gonna move this to my use-package stuff above thoiugh!

#+BEGIN_SRC emacs-lisp
(eval-after-load 'pdf-view 
                    '(define-key pdf-view-mode-map (kbd "M-h") 'pdf-annot-add-highlight-markup-annotation))
(eval-after-load 'pdf-view 
                    '(define-key pdf-view-mode-map (kbd "<tab>") 'pdf-annot-add-highlight-markup-annotation))
#+END_SRC

All of this is getting me very close to using Emacs for all my PDF work. I am doing maybe 50% of my PDF work in Emacs instead of on my tablet.  It's incredibly convenient, although I still find it a little harder to concentrate on my laptop than on the tablet (for reasons ergonomic, optical, and psychological).  Here are the remaining papercuts from my perspective:

- Highlighting text with the mouse is more awkward and less intimate than using my fingertip on a laptop.  I often find mouse movement a little awkward in Emacs, but pdf-view purposely relies on the mouse for movement (for good reasons).
- Scrolling in pdf-view is also a bit awkward, and there's no "continuous" mode as one might find in Evince or acroread.  Again, I often find scrolling an issue in Emacs, so this might not be so easy to fix.
- Finally, the laptop screen is just harder on my eyes than my high-res tablet. pdf-view hasa "midnight mode" which makes it a little easier to read, but it's not quite enough.  

So, for the time being I will probably do much of my reading on the tablet. But for short pieces and for review (e.g., papers that I'm reading for the third year in a row in a graduate seminar...) PDF Tools is now my main interface. Which is pretty sweet.  

*** Todo

*UPDATE:* +I would like to extend the pdfview link type (in org-pdfview) to permit me to specify the precise location of an annotation, so I can jump precisely to that part of the page.+ This has now been [[https://github.com/markus1189/org-pdfview/pull/7][done]] and the code above has been updated to reflect the new syntax. 


*UPDATE:* +Also, now that I think about it, it might be interesting to just have a link type that pops up a temporary buffer with all of the annotations; I could then cut and paste the annotations into the master document.  This might be even more convenient.+  OK, I've implemented this, see above!

*Update <2015-11-22 Sun>:* I've cleaned up some of the code, and added a bit more commentary at the end. 

# /home/matt/HackingHistory/readings/Troper-becoming-immigrant-city.pdf http://matt.hackinghistory.ca/wp-content/uploads/2015/11/wpid-Troper-becoming-immigrant-city.pdf

*** Some advanced behaviour: page extraction form within emacs & pdf virtual mode

- pdf-virtual allows you to collect a group of pdfs as a group, to make reading easier.  Some helper functions for assembling collections would make a lot of sense. I could link to this in my syllabi & have the days readings all in one place (!)
- also some [[https://www.reddit.com/r/emacs/comments/9p2yyq/marking_and_splitting_pdfs_with_pdfstools/t1_e7z50e2][simple defuns for extracting pages so I don't have to use the command line to extract pages]]. Lots of possible extensions to this, too, e.g. maybe build a more complex data structure for feeding pages; another one for adjusting the page order, a third for selecting a rnage of pages (the last may be difficult). 
#+begin_src emacs-lisp
(use-package pdf-virtual
:defer t ;; wil lbe loaded by pdf-tools so defer t is ok
:config
(pdf-virtual-global-minor-mode)
;; probably a good idea to add some key bindings too
)

(defvar mwp-pdf-selected-pages '())

(defun mwp-pdf-select-page ()
  "Add current page to list of selected pages."
  (interactive)
  (add-to-list 'mwp-pdf-selected-pages (pdf-view-current-page) t)
  (message "added current page to selection"))

(defun mwp-pdf-extract-selected-pages (file)
  "Save selected pages to FILE."
  (interactive "FSave as: ")
  (setq mwp-pdf-selected-pages (sort mwp-pdf-selected-pages #'<))
  (start-process "pdfjam" "*pdfjam*"
                 "pdfjam"
                 (buffer-file-name)
                 (mapconcat #'number-to-string
                            mwp-pdf-selected-pages
                            ",")
                 "-o"
                 (expand-file-name file)))

(define-key pdf-view-mode-map "S" #'mwp-pdf-select-page) 
#+end_src

#+RESULTS:
: mwp-pdf-select-page

** Elfeed
:PROPERTIES:
:ID:       o2b:f1821f6e-6faf-472b-abac-70e46397d4bc
:POST_DATE: [2015-11-22 Sun 15:52]
:POSTID:   44
:BLOG:     matt
:END:
I've become pretty addicted to the [[https://github.com/skeeto/elfeed][Elfeed RSS reader]]. However, I haven't made much use of its tagging capabilities until recently.  I noticed that, whenever I thought I might want to keep track of the content of a blog, I would mark it "unread" after I'd read it, to make sure I didn't lose it in the deep mists of time. This worked for the first 4 months or so, but now my list of unreads is growing enormously. So I wanted to have a "starred" tag which would do this work for me.  I also wanted a keybinding that would apply the tag right away.  

The code below does that for me. 

*UPDATE <2016-11-23 Wed>:* I also added a few keybindings that mimic the default bindings for mu4e-mode. This way my muscle memory is less confused.  
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :commands elfeed 
    :config
    (define-key elfeed-search-mode-map (kbd "<tab>") 'mwp/elfeed-star)
    (define-key elfeed-search-mode-map (kbd "C-S-u") 'elfeed-search-fetch)
    (define-key elfeed-search-mode-map (kbd "x") 'elfeed-search-update--force)
    (define-key elfeed-search-mode-map (kbd "d") 'elfeed-search-untag-all-unread)

    (defun mwp/elfeed-star ()
      "add a star tag to marked"

      (interactive)
      (elfeed-search-tag-all (list starred))
      )

    (defun mwp/elfeed-star ()
      "Apply TAG to all selected entries."
      (interactive )
      (let* ((entries (elfeed-search-selected))
             (tag (intern "starred")))

        (cl-loop for entry in entries do (elfeed-tag entry tag))
        (mapc #'elfeed-search-update-entry entries)
        (unless (use-region-p) (forward-line))))

    (setq elfeed-use-curl t)
    ;; (use-package elfeed-goodies)

    ;; (elfeed-goodies/setup)
    )
#+END_SRC

I also wanted a visual cue to tell me the tagging had been successful -- now easy to do, thanks to a very recent commit.  I filed an issue as a question -- [[https://github.com/skeeto/elfeed/issues/108][can I do this?]] -- and within 24 hours skeeto had added the functionality.  First you have to define an appropriate face for the tag:
#+BEGIN_SRC emacs-lisp
(defface elfeed-search-starred-title-face
 '((t :foreground "#f77"))
 "Marks a starred Elfeed entry.")
#+END_SRC

All of this works great for me, and simplifies things quite a bit.  

And then simply add an entry to ~elfeed-search-face-alist~. You can do this via ~Customize~, or follow [[https://github.com/skeeto/elfeed#custom-tag-faces][the instructions in the README]], which instruct you to ~(push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)~.  
** Grading todo
I've moved this stuff into its own org file: 
#+RESULTS:
: t


** Grading Keybindings
:PROPERTIES:
:ID:       4899acb1-55f7-4893-be49-7f500ecd032f
:END:
since I don't use the minor mode, adding keybindings here.  Should be added to org-mode using ~use-package~ but I don't understandi t well enough yet.
#+begin_src emacs-lisp
(use-package org-grading
  :load-path "/home/matt/src/org-grading"
  :after (:any org org-plus-contrib)
  :config )

(use-package org-lms
  :load-path "/home/matt/src/org-grading"
  :pin manual
  ;; :ensure t
  :after org
  ;; :commands (org-lms-setup org-lms-get-courseid)
  :config 
  (setq org-lms-baseurl "https://q.utoronto.ca/api/v1/")
  (setq org-lms-token (password-store-get "q.utoronto.ca")) )

#+end_src

#+RESULTS:
: t

-- leftover stuff: 
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "M-o") 'o-g-open-attachment-or-repo))

#+RESULTS:
: o-g-open-attachment-or-repo

** Opening attachments directly from org
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-file-apps '("\\.docx\\'" . "/usr/bin/libreoffice %s"))
  (add-to-list 'org-file-apps '("\\.doc\\'" . "/usr/bin/libreoffice %s"))
  (add-to-list 'org-file-apps '("\\.odt\\'" . "/usr/bin/libreoffice %s"))


#+END_SRC

#+RESULTS:
: ((\.doc\' . /usr/bin/libreoffice %s) (\.docx\' . /usr/bin/libreoffice %s) (\.pdf::\([[:digit:]]+\)\' . org-pdfview-open) (\.pdf\' . org-pdfview-open) (auto-mode . emacs) (\.mm\' . default) (\.x?html?\' . firefox %s) (\.pdf\' . default) (\.odt\' . /usr/bin/libreoffice %s))

** Allow org attach
** tables of contents
this is useful for github:
https://github.com/snosov1/toc-org
#+BEGIN_SRC emacs-lisp
(if (require 'toc-org nil t)
    (add-hook 'org-mode-hook 'toc-org-enable)
  (warn "toc-org not found"))

#+END_SRC

ybindings
really this should go at the end of the file so it doesn't get overwritten

#+BEGIN_SRC emacs-lisp
  ;; abbrevs
  ;; improved autocorrect, with a decent keybinding
  (define-key ctl-x-map "\C-i" 'endless/ispell-word-then-abbrev)

#+END_SRC

** key Chord
I just installed key-chord.el.  I'm interested to see if it really works for me.  

TOtally not using this so ocmmenting out!!
#+BEGIN_SRC emacs-lisp
  ;; (use-package key-chord)
  ;; (key-chord-mode 1) 
  ;; This one was drifing me crazy! 
  ;; (key-chord-define-global "FF" 'helm-find-files)
  ;; (key-chord-define-global "BB" 'helm-mini)
#+END_SRC

#+RESULTS:
: helm-mini


** Adding Google Calendar to the agenda
:PROPERTIES:
:GRADE:    1
:END:
Stolen rom [[https://cestlaz.github.io/posts/using-emacs-26-gcal/][Mike Zamansky]]. Note that I had problems with copy/paste of id's from 


#+BEGIN_SRC emacs-lisp
  (setq package-check-signature nil)


  (use-package org-gcal
    :ensure t
    :after org
    :config
    (setq org-gcal-client-id "335456863204-npccoru6jvb94ka8u6emlrct66m2ous2.apps.googleusercontent.com"
          org-gcal-client-secret "3yjcG1N1KnFzdn_XP4n28UXW"
          org-gcal-file-alist '(("moptop99@gmail.com" .  "~/Dropbox/GTD/gcal.org")
                                ("2qkj7vq2514glpmq3c7mn3ro90@group.calendar.google.com" . "~/Dropbox/GTD/Maceo-cal.org")
                                ("ekvdm17nis4qd2j4h4djrdfvh0@group.calendar.google.com" . "~/Dropbox/GTD/EDGI-cal.org")))
    (add-to-list 'org-agenda-files "~/Dropbox/GTD/gcal.org")
    (add-to-list 'org-agenda-files "~/Dropbox/GTD/Maceo-cal.org")
    (add-to-list 'org-agenda-files "~/Dropbox/GTD/EDGI-cal.org")
    (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
    (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) )))

#+END_SRC


#+RESULTS:
: t

Now I have to also add a capture template 


** Something weird: Splitting src blocks
I don't know if this is a good idea but I often want to split the src bloc kand create a new heading.  So how aobu this:

#+begin_src emacs-lisp
  (defun org-meta-return (&optional arg)
    "Insert a new heading or wrap a region in a table.
  Calls `org-insert-heading', `org-insert-item' or
  `org-table-wrap-region', depending on context.  When called with
  an argument, unconditionally call `org-insert-heading'."
    (interactive "P")
    (org-check-before-invisible-edit 'insert)
    (or (run-hook-with-args-until-success 'org-metareturn-hook)
        (call-interactively (cond (arg #'org-insert-heading)
                                  ((org-at-table-p) #'org-table-wrap-region)
                                  ((org-in-item-p) #'org-insert-item)
                                  ((org-in-src-block-p)
                                   (lambda ()
                                     (interactive)
                                     (org-babel-demarcate-block)
                                     (org-insert-heading)))
                                  (t #'org-insert-heading)))))
#+end_src

#+RESULTS:
: org-meta-return

** Lightly modify org-edit-src-exit for my preferences

I have switched to editing src blocks in the very same window when I activate with ~C-c i~, and if I change the window configuration when I am working, I don't want it to go back to what it was before I starte dworking ( I can do that manually thank you very much). 

*note* this wil lbe obsolete if my recent patch is accepted, so I added a setq for my new variable which wil lbe just great. 
#+begin_src emacs-lisp
(use-package org 
  :config
  (setq org-src-restore-window-config nil)
  (defun org-edit-src-exit ()
    "Kill current sub-editing buffer and return to source buffer."
    (interactive)
    (unless (org-src-edit-buffer-p) (error "Not in a sub-editing buffer"))
    (let* ((beg org-src--beg-marker)
	   (end org-src--end-marker)
	   (write-back org-src--allow-write-back)
	   (remote org-src--remote)
	   (coordinates (and (not remote)
			     (org-src--coordinates (point) 1 (point-max))))
	   (code (and write-back (org-src--contents-for-write-back))))
      (set-buffer-modified-p nil)
      ;; Switch to source buffer.  Kill sub-editing buffer.
      (let ((edit-buffer (current-buffer))
	    (source-buffer (marker-buffer beg)))
        (unless source-buffer (error "Source buffer disappeared.  Aborting"))
        (org-src-switch-to-buffer source-buffer 'exit)
        (kill-buffer edit-buffer))
      ;; Insert modified code.  Ensure it ends with a newline character.
      (org-with-wide-buffer
       (when (and write-back (not (equal (buffer-substring beg end) code)))
         (undo-boundary)
         (goto-char beg)
         (delete-region beg end)
         (let ((expecting-bol (bolp)))
	   (insert code)
	   (when (and expecting-bol (not (bolp))) (insert "\n")))))
      ;; If we are to return to source buffer, put point at an
      ;; appropriate location.  In particular, if block is hidden, move
      ;; to the beginning of the block opening line.
      (unless remote
        (goto-char beg)
        (cond
         ;; Block is hidden; move at start of block.
         ((cl-some (lambda (o) (eq (overlay-get o 'invisible) 'org-hide-block))
		   (overlays-at (point)))
	  (beginning-of-line 0))
         (write-back (org-src--goto-coordinates coordinates beg end))))
      ;; Clean up left-over markers and restore window configuration.
      (set-marker beg nil)
      (set-marker end nil)
      (unless (eq 'current-window org-src-window-setup)
        (when org-src--saved-temp-window-config
          (set-window-configuration org-src--saved-temp-window-config)
          (setq org-src--saved-temp-window-config nil)))))
          (setq org-src-window-setup 'current-window))
#+end_src

#+RESULTS:
: t

** Local Vars, and endless/org-eob

IfI do rewrite my timestamp-finding code, I will likely use a local variable to store a list of the erelvant file.  [[http://endlessparentheses.com/org-mode-subtrees-and-file-local-variables.html][this post from endless parenteheses has a nice touch for managing end of buffer with local variables. Modified very lightly b/c I call mine "Variables", not "Fotter"
#+begin_src emacs-lisp
(use-package org
:config
(defun endless/org-eob ()
  "Move to end of content, then end of buffer."
  (interactive)
  (unless (use-region-p)
    (push-mark))
  (if (looking-at-p "\n\\* COMMENT Footer")
      (goto-char (point-max))
    (goto-char (point-min))
    (if (search-forward "\n* COMMENT Footer"
                        nil 'noerror)
        (goto-char (match-beginning 0))
      (goto-char (point-max)))))
(define-key org-mode-map [remap end-of-buffer]
  #'endless/org-eob))
#+end_src


** Deal with flycheck ckechdoc madness in org src buffers
TThis has been driving me crazy - -giving [[https://emacs.stackexchange.com/questions/16766/how-to-turn-off-emacs-lisp-checkdoc-of-flycheck-when-edit-source-block-in-org][this solution form stackoverflow]] a go now:
#+begin_src emacs-lisp
(defun disable-flycheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

(add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-block)
(remove-hook 'org-src-mode-hook 'disable-fylcheck-in-org-src-block)
#+end_src

#+RESULTS:
| disable-flycheck-in-org-src-block | org-src-babel-configure-edit-buffer | org-src-mode-configure-edit-buffer |

** Improved marking in org-table
Stolen from [[https://www.reddit.com/r/emacs/comments/74ruu0/how_to_copy_the_contents_of_a_single_cell_in_org/][this excellent reddit post]] by Kaushal

#+begin_src emacs-lisp
(use-package org-table
  :defer t
  :config
  (progn
;;;; Table Field Marking
    (defun org-table-mark-field ()
      "Mark the current table field."
      (interactive)
      ;; Do not try to jump to the beginning of field if the point is already there
      (when (not (looking-back "|[[:blank:]]?"))
        (org-table-beginning-of-field 1))
      (set-mark-command nil)
      (org-table-end-of-field 1))

    (defhydra hydra-org-table-mark-field
      (:body-pre (org-table-mark-field)
       :color red
       :hint nil)
      " ^^      ^up^     ^^
   ^^      _p_     ^^
left _b_  selection  _f_ right \rarr          | Org table mark field |
   ^^      _n_     ^^
   ^^      ^down^     ^^ "
      ("x" exchange-point-and-mark "exchange point/mark")
      ("f" (lambda (arg)
             (interactive "p")
             (when (eq 1 arg)
               (setq arg 2))
             (org-table-end-of-field arg)))
      ("b" (lambda (arg)
             (interactive "p")
             (when (eq 1 arg)
               (setq arg 2))
             (org-table-beginning-of-field arg)))
      ("n" next-line)
      ("p" previous-line)
      ("q" nil "cancel" :color blue))

    (bind-keys
     :map org-mode-map
     :filter (org-at-table-p)
     ("S-SPC" . hydra-org-table-mark-field/body))))
#+end_src

#+RESULTS:
: t

** creating shcreenshots of rendered html
[[https://github.com/krisajenkins/ob-browser][ob-browser]] allows quick snapshots of rendered html. probably makes most sense with noweb-style linked blocks or something like that. I'm not so good at that stuff.

See also [[https://www.reddit.com/r/emacs/comments/ac5dtn/announcing_obhtmlchrome/][reddit]] and the similar [[https://github.com/krisajenkins/ob-browser][ob-browser]]
#+begin_src emacs-lisp
(use-package ob-html-chrome
  :ensure t)

(use-package ob-browser
  :ensure t)

#+end_src


#+begin_src browser :out ~/test.png
<h1>hello</h1>
<i>wow</i>
#+end_src

#+RESULTS:
[[file:~/test.png]]

** Fix SVG embedding?
By default ox-html breaks svg embedding.  So here is a fake fixed
#+begin_src emacs-lisp
(defun org-html--format-image (source attributes info)
  "Return \"img\" tag with given SOURCE and ATTRIBUTES.
SOURCE is a string specifying the location of the image.
ATTRIBUTES is a plist, as returned by
`org-export-read-attribute'.  INFO is a plist used as
a communication channel."
  ;; (org-html--svg-image source attributes info)
  (org-html-close-tag
   "img"
   (org-html--make-attribute-string
    (org-combine-plists
     (list :src source
	   :alt (if (string-match-p "^ltxpng/" source)
		    (org-html-encode-plain-text
		     (org-find-text-property-in-string 'org-latex-src source))
		  (file-name-nondirectory source)))
     attributes))
   info))

#+end_src

#+RESULTS:
: org-html--format-image

** Trying ob-html
Just found this on stackoverflow, https://github.com/zweifisch/ob-http

#+begin_src emacs-lisp
(use-package ob-http
  :ensure t
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(     (http . t))))
#+end_src

#+RESULTS:
: t

* STARTED Scimax

John Kitchin's scimax has a *lot* of cool stuff in it,though maybe org-ref is the mosti mportant. I will get to that when I can! But for now I just Have a couple of utilities defined.

So far all I'm using is "hotspots"
#+begin_src emacs-lisp
  (use-package scimax-utils
    :load-path "~/src/scimax"
    :pin manual
    :bind
    ("<f9>" . hotspots)
    :config
    (setq scimax-user-hotspot-locations
          '(("init file" . "~/.emacs.d/emacs-init.org")
            ("Reference File" . "~/GTD/Reference.org")
            ("Scratch Buffer" . "*scratch*")
            ("Password Safe" . "~/GTD/keep-it-safe.org.gpg")
            ("DH Lectures" . "~/DH/Lectures.org")
            ))
    (setq scimax-user-hotspot-commands
          '(("open mu4e" . mu )
            ("bury buffer" . bury-buffer
            )))
    (add-to-list 'process-environment "EMACS_CHILD=t"))

#+end_src

#+RESULTS:
: hotspots

* ACTION hydra! 
I'm excited to learn more about [[https://github.com/abo-abo/hydra/][hydra]], which along with company, helm, and maybe ivy/counsel/avy (which I don't use) has really transformed the wayEmacs is being used out in the wild. For me, only so much, but I'm trying to learn.  

Let's start by loading the package (totally basic)

#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    )
#+end_src

#+RESULTS:

In the following section I'll maybe load some helpers and introduce some sub-commands.

** ox-hydra

I'm going to try to start with replacing the default dispatcher with something easier to navigate.  

#+begin_src emacs-lisp
    ;; adapted from https://github.com/abo-abo/hydra/blob/master/hydra-ox.el
    ;;; hydra-ox.el --- Org mode export widget implemented in Hydra

    ;; Copyright (C) 2015  Free Software Foundation, Inc.

    ;; Author: Oleh Krehel

    ;; This file is part of GNU Emacs.

    ;; GNU Emacs is free software: you can redistribute it and/or modify
    ;; it under the terms of the GNU General Public License as published by
    ;; the Free Software Foundation, either version 3 of the License, or
    ;; (at your option) any later version.

    ;; GNU Emacs is distributed in the hope that it will be useful,
    ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ;; GNU General Public License for more details.

    ;; You should have received a copy of the GNU General Public License
    ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

    ;;; Commentary:
    ;;
    ;; This shows how a complex dispatch menu can be built with Hydra.

    ;;; Code:

    (require 'hydra)
    (require 'org)
    (declare-function org-html-export-as-html 'ox-html)
    (declare-function org-html-export-to-html 'ox-html)
    (declare-function org-latex-export-as-latex 'ox-latex)
    (declare-function org-latex-export-to-latex 'ox-latex)
    (declare-function org-latex-export-to-pdf 'ox-latex)
    (declare-function org-ascii-export-as-ascii 'ox-ascii)
    (declare-function org-ascii-export-to-ascii 'ox-ascii)

    (defhydradio hydra-ox ()
      (body-only "Export only the body.")
      (export-scope "Export scope." [buffer subtree])
      (async-export "When non-nil, export async.")
      (visible-only "When non-nil, export visible only")
      (force-publishing "Toggle force publishing"))

    (defhydra hydra-ox-html (:color blue)
      "ox-html"
      ("H" (org-html-export-as-html
            hydra-ox/async-export
            (eq hydra-ox/export-scope 'subtree)
            hydra-ox/visible-only
            hydra-ox/body-only)
           "As HTML buffer")
      ("h" (org-html-export-to-html
            hydra-ox/async-export
            (eq hydra-ox/export-scope 'subtree)
            hydra-ox/visible-only
            hydra-ox/body-only) "As HTML file")
      ("o" (org-open-file
            (org-html-export-to-html
             hydra-ox/async-export
             (eq hydra-ox/export-scope 'subtree)
             hydra-ox/visible-only
             hydra-ox/body-only)) "As HTML file and open")
      ("b" hydra-ox/body "back")
      ("q" nil "quit"))

    (defhydra hydra-ox-gfm (:color blue)
      "ox-gfm"
      ("M" (org-gfm-export-as-markdown
            hydra-ox/async-export
            (eq hydra-ox/export-scope 'subtree)
            hydra-ox/visible-only
            hydra-ox/body-only)
           "As GFM buffer")
      ("m" (org-gfm-export-to-markdown
            hydra-ox/async-export
            (eq hydra-ox/export-scope 'subtree)
            hydra-ox/visible-only
            hydra-ox/body-only) "As GFM file")
      ("o" (org-open-file
            (org-gfm-export-to-markdown
             hydra-ox/async-export
             (eq hydra-ox/export-scope 'subtree)
             hydra-ox/visible-only
             hydra-ox/body-only)) "As GFM file and open")
      ("b" hydra-ox/body "back")
      ("q" nil "quit"))

    (defhydra hydra-ox-latex (:color blue)
      "ox-latex"
      ("L" org-latex-export-as-latex "As LaTeX buffer")
      ("l" org-latex-export-to-latex "As LaTeX file")
      ("p" org-latex-export-to-pdf "As PDF file")
      ("o" (org-open-file (org-latex-export-to-pdf)) "As PDF file and open")
      ("b" hydra-ox/body "back")
      ("q" nil "quit"))

    (defhydra hydra-ox-text (:color blue)
      "ox-text"
      ("A" (org-ascii-export-as-ascii
            nil nil nil nil
            '(:ascii-charset ascii))
           "As ASCII buffer")

      ("a" (org-ascii-export-to-ascii
            nil nil nil nil
            '(:ascii-charset ascii))
           "As ASCII file")
      ("L" (org-ascii-export-as-ascii
            nil nil nil nil
            '(:ascii-charset latin1))
           "As Latin1 buffer")
      ("l" (org-ascii-export-to-ascii
            nil nil nil nil
            '(:ascii-charset latin1))
           "As Latin1 file")
      ("U" (org-ascii-export-as-ascii
            nil nil nil nil
            '(:ascii-charset utf-8))
           "As UTF-8 buffer")
      ("u" (org-ascii-export-to-ascii
            nil nil nil nil
            '(:ascii-charset utf-8))
           "As UTF-8 file")
      ("b" hydra-ox/body "back")
      ("q" nil "quit"))

  (defhydra hydra-ox-hugo (:color blue)
    "ox-hugo"
    ("H" (org-hugo-export-wim-to-md
          hydra-ox/async-export
          (eq hydra-ox/export-scope 'subtree)
          hydra-ox/visible-only
          hydra-ox/body-only)
         "As HTML buffer")
    ("h" (org-hugo-export-to-md
          hydra-ox/async-export
          (eq hydra-ox/export-scope 'subtree)
          hydra-ox/visible-only
          hydra-ox/body-only) "As HTML file")
    ("o" (org-open-file
          (org-hugo-export-to-md
           hydra-ox/async-export
           (eq hydra-ox/export-scope 'subtree)
           hydra-ox/visible-only
           hydra-ox/body-only)) "As HTML file and open")
    ("b" hydra-ox/body "back")
    ("q" nil "quit"))

  (defhydra hydra-ox-reveal (:color blue)
    "ox-reveal"
    ("R" (org-reveal-export-as-html
          hydra-ox/async-export
          (eq hydra-ox/export-scope 'subtree)
          hydra-ox/visible-only
          hydra-ox/body-only)
         "As REVEAL buffer")
    ("r" (org-reveal-export-to-html
          hydra-ox/async-export
          (eq hydra-ox/export-scope 'subtree)
          hydra-ox/visible-only
          hydra-ox/body-only) "As REVEAL file")
    ("o" (org-open-file
          (org-reveal-export-to-html
           hydra-ox/async-export
           (eq hydra-ox/export-scope 'subtree)
           hydra-ox/visible-only
           hydra-ox/body-only)) "As REVEAL file and open")
    ("b" hydra-ox/body "back")
    ("q" nil "quit"))


    (defhydra hydra-ox ()
      "
    _C-b_ Body only:    % -15`hydra-ox/body-only^^^ _C-v_ Visible only:     %`hydra-ox/visible-only
    _C-s_ Export scope: % -15`hydra-ox/export-scope _C-f_ Force publishing: %`hydra-ox/force-publishing
    _C-a_ Async export: %`hydra-ox/async-export

    "
      ("C-b" (hydra-ox/body-only) nil)
      ("C-v" (hydra-ox/visible-only) nil)
      ("C-s" (hydra-ox/export-scope) nil)
      ("C-f" (hydra-ox/force-publishing) nil)
      ("C-a" (hydra-ox/async-export) nil)
      ("g" hydra-ox-gfm/body "Export to Github Flavoured Markdown"  :exit t)
      ("H" hydra-ox-hugo/body "Export to Hugo MD Files" :exit t)
      ("h" hydra-ox-html/body "Export to HTML" :exit t)
      ("l" hydra-ox-latex/body "Export to LaTeX" :exit t)
      ("r" hydra-ox-reveal/body "Export to REVEAL" :exit t)
      ("t" hydra-ox-text/body "Export to Plain Text" :exit t)
      ("q" nil "quit"))

      (define-key org-mode-map (kbd "C-c C-,") 'hydra-ox/body)

    (provide 'hydra-ox)

    ;;; hydra-ox.el ends here



#+end_src

#+RESULTS:
: hydra-ox

** Org Link Editing
Stolen from [[https://github.com/abo-abo/hydra/wiki/Org-mode-links][the hydra website]] with some other stuff.

I doubt I'll use this much but well still, interesting. 
#+begin_src emacs-lisp
  (use-package org-link-edit
    :after org
    :config
    (defun jk/unlinkify ()
    "Replace an org-link with the description, or if this is absent, the path."
    (interactive)
    (let ((eop (org-element-context)))
      (when (eq 'link (car eop))
        (message "%s" eop)
        (let* ((start (org-element-property :begin eop))
               (end (org-element-property :end eop))
               (contents-begin (org-element-property :contents-begin eop))
               (contents-end (org-element-property :contents-end eop))
               (path (org-element-property :path eop))
               (desc (and contents-begin
                          contents-end
                          (buffer-substring contents-begin contents-end))))
          (setf (buffer-substring start end)
                (concat (or desc path)
                        (make-string (org-element-property :post-blank eop) ?\s)))))))

   (define-key org-mode-map (kbd "C-c )")
        (defhydra hydra-org-link-edit (:color red)
          "Org Link Edit"
          ("f" org-link-edit-forward-slurp "forward slurp")
          ("d" org-link-edit-forward-barf "forward barf")
          ("e" org-link-edit-backward-slurp "backward slurp")
          ("r" org-link-edit-backward-barf "backward barf")
          ("x" jk/unlinkify "remove link" :color blue)
          ("q" nil "cancel" :color blue))))

#+end_src

#+RESULTS:
: t

** Simple hydra for clipboard exports
#+begin_src emacs-lisp
          ;; (global-set-key (kbd "C-c W h") 'ora-org-to-html-to-clipboard)
          ;; (global-set-key (kbd "C-c W s") 'ora-org-export-to-clipboard-as-slack)

        ;; (defhydra hydra-org-clipboard (global-map "C-c W" :hint nil :columns 2 )

        ;; ;; "Export formatted text to the clipboard"
        ;; ;; "
        ;; ;; ^HTML^                   ^Text^
        ;; ;; _h__: to HTML clipboard  _m_: as markdown
        ;; ;; _H_: as HTML             _s_: as slack
        ;; ;; "
        ;; ;; ("h" ora-org-to-html-to-clipboard "to html clipboard" :column "html")
        
        ;; ;; ("m" (mwp-org-export-to-clipboard 'md  ) "as md" :column "text")
        ;; ;; ("s" (mwp-org-export-to-clipboard 'slack ) "as slack" :column "text" ))
        ;;   ("h" ora-org-to-html-to-clipboard)
        ;; ("H" (mwp-org-export-to-clipboard 'html ) )
        ;; ("m" (mwp-org-export-to-clipboard 'md  ) )
        ;; ("s" (mwp-org-export-to-clipboard 'slack ) ))


    (defhydra hydra-o-c (:color blue)
      "
  Export Region or file to clipboard
  ==================================
  To paste into a browser, libreoffice, etc, 
  choose \"_h_\" to use the rich-text system clipboard.

  Region is currently %s(if (use-region-p) \"ACTIVE.\" \"NOT ACTIVE!!!\").

  "

      ("m" (mwp-org-export-to-clipboard 'md) "as gfm md" :column "text"  )
      ("s" (mwp-org-export-to-clipboard 'slack) "as slack" :column "text" )
      ("h" ora-org-to-html-to-clipboard "to html clipboard" :column "html")
      ("H" (mwp-org-export-to-clipboard 'html) "to text as html"   :column "html"))

    (global-set-key (kbd "<f6>") 'hydra-o-c/body)

    (global-set-key (kbd "C-c W") 'hydra-o-c/body)
#+end_src

#+RESULTS:
: hydra-o-c/body

** Replace toggle map with hydra
see [[The Toggle Map][The Toggle Map]] Below

** Pdf-Tools Hydra
well... let's see how this goes!
#+begin_src emacs-lisp

    (use-package pdf-tools
    :after hydra
    :config 
    (defhydra hydra-pdftools (:color blue :hint nil)
      "
                                                                        
           Move  History   Scale/Fit     Annotations  Search/Link    Do    PDF Tools 
              ^^_g_^^      _B_    ^^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
             ^^^^^^      ^^    _H_    ^   [_am_] markup  [_o_] outline   [_i_] info
             ^^_p_^^      ^ ^    ^    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
             ^^_G_^^
       --------------------------------------------------------------------------------
            "
      ;; ("\\" hydra-master/body "back")
      ("<ESC>" nil "quit")
      ("al" pdf-annot-list-annotations)
      ("ad" pdf-annot-delete)
      ("aa" pdf-annot-attachment-dired)
      ("am" pdf-annot-add-markup-annotation)
      ("at" pdf-annot-add-text-annotation)
      ("y"  pdf-view-kill-ring-save)
      ("+" pdf-view-enlarge :color red)
      ("-" pdf-view-shrink :color red)
      ("0" pdf-view-scale-reset)
      ("H" pdf-view-fit-height-to-window)
      ("W" pdf-view-fit-width-to-window)
      ("P" pdf-view-fit-page-to-window)
      ("n" pdf-view-next-page-command :color red)
      ("p" pdf-view-previous-page-command :color red)
      ("d" pdf-view-dark-minor-mode)
      ("b" pdf-view-set-slice-from-bounding-box)
      ("r" pdf-view-reset-slice)
      ("g" pdf-view-first-page)
      ("G" pdf-view-last-page)
      ("e" pdf-view-goto-page)
      ("o" pdf-outline)
      ("s" pdf-occur)
      ("i" pdf-misc-display-metadata)
      ("u" pdf-view-revert-buffer)
      ("F" pdf-links-action-perfom)
      ("f" pdf-links-isearch-link)
      ("B" pdf-history-backward :color red)
      ("N" pdf-history-forward :color red)
      ("l" image-forward-hscroll :color red)
      ("h" image-backward-hscroll :color red))
      :bind
      (:map pdf-view-mode-map 
  ("\\" . hydra-pdftools/body)))
#+end_src

#+RESULTS:
: hydra-pdftools/body

** Courses
I think it would be interesting to have hydras for some of my courses, e.g.:
- hydra-courses
  - hydra-ww
    - Grades
    - Lectures
    - Syllabus
    - perhaps an action or two?
  - hydra-dh
    - Grades
    - Lectures
    - Assignments
    - build...
  - etc

#+begin_src emacs-lisp
(defhydra hydra-ww (:color blue :columns 3)
  "
Wildwater actions
================
"
  ("s" (find-file "~/Wildwater/ww1-syllabus.org") "Syllabus")
  ("g" (find-file "~/Wildwater/Grades/Comments.org") "Grades")
  ("n" (find-file "~/Wildwater/Slides-and-notes.org") "Notes"))


(defhydra hydra-dh (:color blue :columns 2)
  "
Digital History Grading actions
================
"
  ("f" (dh-find-files) "Open Files")
  ("v" (dh-view) "Browse files")
  ("d" (quick-diff) "get diff fast")
  ("i" (dh-prep) "Install (prep) repo")
  ("p" (dh-visit-pr) "Browse PR")
  ("u" (dh-pull-repo) "Update (pull) repo")
  
  ("s" (dh-status) "Open in Magit")
  ("t" (dh-tests) "Run Tests"))

(defhydra hydra-hh (:color blue :columns 3)
  "
Wildwater actions
================
"
  ("s" (find-file "~/Wildwater/ww1-syllabus.org") "Syllabus")
  ("g" (find-file "~/Wildwater/Grades/Comments.org") "Grades")
  ("n" (find-file "~/Wildwater/Slides-and-notes.org") "Notes"))

(defhydra hydra-modernity (:color blue :columns 3)
  "
Modernity actions
================
"
  ("s" (find-file "~/Wildwater/ww1-syllabus.org") "Syllabus")
  ("g" (find-file "~/Wildwater/Grades/Comments.org") "Grades")
  ("n" (find-file "~/Wildwater/Slides-and-notes.org") "Notes"))

(define-key org-mode-map (kbd "C-c D") 'hydra-dh/body)
#+end_src

#+RESULTS:
: hydra-dh/body

* Projects
I don't have a really good system for delaing with projects. There's projectile, and there's speedbar, both of which kind of helpful... but for now I'm going to just experiment with projectile. 

#+BEGIN_SRC emacs-lisp

(use-package projectile 
:after hydra
:config 
(projectile-global-mode +1)
(helm-projectile-on)
(setq projectile-indexing-method 'alien)
(projectile-register-project-type 'npm '("package.json")
                  :compile "npm install"
                  :test "npm test"
                  :run "npm start"
                  :test-suffix ".spec")
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(defhydra hydra-projectile (:color teal
			    :columns 4)
  "Projectile"
  ("f"   projectile-find-file                "Find File")
  ("r"   projectile-recentf                  "Recent Files")
  ("z"   projectile-cache-current-file       "Cache Current File")
  ("x"   projectile-remove-known-project     "Remove Known Project")
  
  ("d"   projectile-find-dir                 "Find Directory")
  ("b"   projectile-switch-to-buffer         "Switch to Buffer")
  ("c"   projectile-invalidate-cache         "Clear Cache")
  ("X"   projectile-cleanup-known-projects   "Cleanup Known Projects")
  
  ("o"   projectile-multi-occur              "Multi Occur")
  ("s"   projectile-switch-project           "Switch Project")
  ("k"   projectile-kill-buffers             "Kill Buffers")
  ("q"   nil "Cancel" :color blue))
)
#+END_SRC

#+RESULTS:
: t

* Non-org text modes
** Improved markdown
Markdown sucks bompared to org but needsto bsued constantly. Partial solutin: add someorg-like keybindings to make text movements easier:

add "edit-indirect" for better sourc doe editing!

cf docs: https://leanpub.com/markdown-mode/read

#+begin_src emacs-lisp
(define-minor-mode mwp-bindings-mode
  "Some new bindings, at first justfor markdown mode."
  :lighter "mwp"
  :keymap(let ((map (make-sparse-keymap)))
            (define-key map (kbd "<M-right>") 'markdown-demote)
            (define-key map (kbd "<M-left>") 'markdown-promote)
            (define-key map (kbd "<M-up>") 'markdown-move-up)
            (define-key map (kbd "<M-down>") 'markdown-move-down)
            map) )

(add-hook 'markdown-mode 'mwp-bindings-mode)

#+end_src

#+RESULTS:
| mwp-bindings |

* Miscellaneous programming
** Get minor modes in the minibuffer
This is stolen from http://emacsredux.com/blog/2016/03/02/pimp-my-minibuffer/

In Emacs you can evaluate Emacs Lisp pretty much anywhere - even in the minibuffer. Writing Emacs Lisp in the minibuffer, however, is not exactly fantastic experience out-of-the-box - there’s TAB completion, but what about eldoc and paredit for instance?

If only there was a way to enable them… I suggested one trick in my original post on eval-expression, but Emacs 24.4 made things even easier by adding eval-expression-minibuffer-setup-hook. To enable eldoc for minibuffer evaluations use this snippet:

#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode)
#+END_SRC
** markdown
use github markdown instead of regular
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC
** Emacs Refadctor
#+begin_src emacs-lisp
  ;; (use-package emr
  ;; :ensure t
  ;; )
  (use-package emr
:ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook 'emr-initialize)
    ;; (bind-key "R" #'emr-show-refactor-menu lisp-evaluation-map)
)
#+end_src

#+RESULTS:
: t

* Open current file with Sudo
I very often want to reopen a current bufferin sudo. I stalling ~sudo-edit~ has done the trick for me.  

* WON'T DO Unused 
#+BEGIN_SRC emacs-lisp :tangle no
  ;; This is how Magnar manages his packages.  I'm not there yet.  soon I hope.  
  ;; Setup packages
  ;; (use-package setup-package)
  ;; Install extensions if they're missing
  ;; (defun init--install-packages ()
  ;;   (packages-install
  ;;    '(magit
  ;;      paredit
  ;;      move-text
  ;;      gist
  ;;      htmlize
  ;;      visual-regexp
  ;;      flycheck
  ;;      flx
  ;;      flx-ido
  ;;      css-eldoc
  ;;      yasnippet
  ;;      smartparens
  ;;      ido-vertical-mode
  ;;      ido-at-point
  ;;      simple-httpd
  ;;      guide-key
  ;;      nodejs-repl
  ;;      restclient
  ;;      highlight-escape-sequences
  ;;      whitespace-cleanup-mode
  ;;      elisp-slime-nav
  ;;      git-commit-mode
  ;;      gitconfig-mode
  ;;      gitignore-mode
  ;;      clojure-mode
  ;;      groovy-mode
  ;;      prodigy
  ;;      cider
  ;;      cider-tracing)))

  ;; (condition-case nil
  ;;     (init--install-packages)
  ;;   (error
  ;;    (package-refresh-contents)
  ;;    (init--install-packages)))

  ;; this is the main structure of magnar's .emacs; it's a little complex for me
  ;; Setup extensions
  ;; (eval-after-load 'ido '(require 'setup-ido))
  ;; (eval-after-load 'org '(require 'setup-org))
  ;; (eval-after-load 'dired '(require 'setup-dired))
  ;; (eval-after-load 'magit '(require 'setup-magit))
  ;; (eval-after-load 'grep '(require 'setup-rgrep))
  ;; (eval-after-load 'shell '(require 'setup-shell))
  ;; (require 'setup-hippie)
  ;; (require 'setup-yasnippet)
  ;; (require 'setup-perspective)
  ;; (require 'setup-ffip)
  ;; (require 'setup-html-mode)
  ;; (require 'setup-paredit)

  ;; ;; Elisp go-to-definition with M-. and back again with M-,
  ;; (autoload 'elisp-slime-nav-mode "elisp-slime-nav")
  ;; (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t) (eldoc-mode 1)))

  ;; ;; Run at full power please
  ;; (put 'downcase-region 'disabled nil)
  ;; (put 'upcase-region 'disabled nil)
  ;; (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)

  ;; ;; Conclude init by setting up specifics for the current user
  ;; (when (file-exists-p user-settings-dir)
  ;;   (mapc 'load (directory-files user-settings-dir nil "^[^#].*el$")))


  ;; add opened files to gnome recent-files list
  (defun fd-add-file-to-recent ()
    (when buffer-file-name
      (start-process "addtorecent" nil "addtorecent"
                     (concat "file://" buffer-file-name)
                     "text/plain"
                     "Emacs"
                     "emacsclient %F")))

  ;; (add-hook 'find-file-hook 'fd-add-file-to-recent)
  ;;; Speedbar and Imenu
  ;; This adds support for speedbar and Imenu.  Right now I'm not actually using either though.
  ;; (add-hook 'org-mode-hook
  ;;                     (lambda () (imenu-add-to-menubar "Imenu")))
  ;; (require 'speedbar)
  ;; (speedbar-add-supported-extension ".org")

  ;;;; changing languages for e.g. spellcheck.  I don't use this much right now
  ;; (let ((langs '("canadian" "francais")))
  ;;   (setq lang-ring (make-ring (length langs)))
  ;;   (dolist (elem langs) (ring-insert lang-ring elem)))

  ;; (defun cycle-ispell-languages ()
  ;;   (interactive)
  ;;   (let ((lang (ring-ref lang-ring -1)))
  ;;     (ring-insert lang-ring lang)
  ;;     (ispell-change-dictionary lang)))

  ;; (global-set-key [f6] 'cycle-ispell-languages)
  ;;; Worg and Wanderlust
  ;; also some org-wl interaction
  ;; stolen from worg: http://orgmode.org/worg/org-hacks.html

  ;; (defun dmj/wl-send-html-message ()
  ;;   "Send message as html message.
  ;; Convert body of message to html using
  ;;   `org-export-region-as-html'."
  ;;   (require 'org)
  ;;   (save-excursion
  ;;     (let (beg end html text)
  ;;       (goto-char (point-min))
  ;;       (re-search-forward "^--text follows this line--$")
  ;;       ;; move to beginning of next line
  ;;       (beginning-of-line 2)
  ;;       (setq beg (point))
  ;;       (if (not (re-search-forward "^--\\[\\[" nil t))
  ;;           (setq end (point-max))
  ;;         ;; line up
  ;;         (end-of-line 0)
  ;;         (setq end (point)))
  ;;       ;; grab body
  ;;       (setq text (buffer-substring-no-properties beg end))
  ;;       ;; convert to html
  ;;       (with-temp-buffer
  ;;         (org-mode)
  ;;         (insert text)
  ;;         ;; handle signature
  ;;         (when (re-search-backward "^-- \n" nil t)
  ;;           ;; preserve link breaks in signature
  ;;           (insert "\n#+BEGIN_VERSE\n")
  ;;           (goto-char (point-max))
  ;;           (insert "\n#+END_VERSE\n")
  ;;           ;; grab html
  ;;           (setq html (org-export-region-as-html
  ;;                       (point-min) (point-max) t 'string))))
  ;;       (delete-region beg end)
  ;;       (insert
  ;;        (concat
  ;;         "--" "<<alternative>>-{\n"
  ;;         "--" "[[text/plain]]\n" text
  ;;         "--" "[[text/html]]\n"  html
  ;;         "--" "}-<<alternative>>\n")))))

  ;; (defun dmj/wl-send-html-message-toggle ()
  ;;   "Toggle sending of html message."
  ;;   (interactive)
  ;;   (setq dmj/wl-send-html-message-toggled-p
  ;;         (if dmj/wl-send-html-message-toggled-p
  ;;             nil "HTML"))
  ;;   (message "Sending html message toggled %s"
  ;;            (if dmj/wl-send-html-message-toggled-p
  ;;                "on" "off")))

  ;; (defun dmj/wl-send-html-message-draft-init ()
  ;;   "Create buffer local settings for maybe sending html message."
  ;;   (unless (boundp 'dmj/wl-send-html-message-toggled-p)
  ;;     (setq dmj/wl-send-html-message-toggled-p nil))
  ;;   (make-variable-buffer-local 'dmj/wl-send-html-message-toggled-p)
  ;;   (add-to-list 'global-mode-string
  ;;                '(:eval (if (eq major-mode 'wl-draft-mode)
  ;;                            dmj/wl-send-html-message-toggled-p))))

  ;; (defun dmj/wl-send-html-message-maybe ()
  ;;   "Maybe send this message as html message.

  ;; If buffer local variable `dmj/wl-send-html-message-toggled-p' is
  ;; non-nil, add `dmj/wl-send-html-message' to
  ;; `mime-edit-translate-hook'."
  ;;   (if dmj/wl-send-html-message-toggled-p
  ;;       (add-hook 'mime-edit-translate-hook 'dmj/wl-send-html-message)
  ;;     (remove-hook 'mime-edit-translate-hook 'dmj/wl-send-html-message)))

  ;; (add-hook 'wl-draft-reedit-hook 'dmj/wl-send-html-message-draft-init)
  ;; (add-hook 'wl-mail-setup-hook 'dmj/wl-send-html-message-draft-init)
  ;; (add-hook 'wl-draft-send-hook 'dmj/wl-send-html-message-maybe) 

  ;; (defun dmj/org-export-region-as-html-attachment (beg end arg)
  ;;   "Export region between BEG and END as html attachment.
  ;; If BEG and END are not set, use current subtree.  Region or
  ;; subtree is exported to html without header and footer, prefixed
  ;; with a mime entity string and pushed to clipboard and killring.
  ;; When called with prefix, mime entity is not marked as
  ;; attachment."
  ;;   (interactive "r\nP")
  ;;   (save-excursion
  ;;     (let* ((beg (if (region-active-p) (region-beginning)
  ;;                   (progn
  ;;                     (org-back-to-heading)
  ;;                     (point))))
  ;;            (end (if (region-active-p) (region-end)
  ;;                   (progn
  ;;                     (org-end-of-subtree)
  ;;                     (point))))
  ;;            (html (concat "--[[text/html"
  ;;                          (if arg "" "\nContent-Disposition: attachment")
  ;;                          "]]\n"
  ;;                          (org-export-region-as-html beg end t 'string))))
  ;;       (when (fboundp 'x-set-selection)
  ;;         (ignore-errors (x-set-selection 'PRIMARY html))
  ;;         (ignore-errors (x-set-selection 'CLIPBOARD html)))
  ;;       (message "html export done, pushed to kill ring and clipboard"))))

  ;; temp fix for heckboxes in orgh-html export
  ;; disabling cause it messes up my export
  ;; (defun org-html-checkbox (checkbox)
  ;;   "Format CHECKBOX into HTML."
  ;;   (case checkbox (on "<input type=\"checkbox\" checked />")
  ;;      (off "<input type=\"checkbox\" />")
  ;;      (trans "<code>[-]</code>")
  ;;      (t "")))

  ;; (defun org-html-format-list-item (contents type checkbox info
  ;;                                         &optional term-counter-id
  ;;                                         headline)
  ;;   "Format a list item into HTML."
  ;;   (let ((checkbox (concat (org-html-checkbox checkbox) (and checkbox " ")))
  ;;      (br (org-html-close-tag "br" nil info)))
  ;;     (concat
  ;;      (case type
  ;;        (ordered
  ;;      (let* ((counter term-counter-id)
  ;;             (extra (if counter (format " value=\"%s\"" counter) "")))
  ;;        (concat
  ;;         (format "<li%s>" extra)
  ;;         (when headline (concat headline br)))))
  ;;        (unordered
  ;;      (let* ((id term-counter-id)
  ;;             (extra (if id (format " id=\"%s\"" id) ""))
  ;;             (chkclass (if checkbox (format " class=\"checkbox\"") "")))
  ;;        (concat
  ;;         (format "<li%s%s>" extra chkclass)
  ;;         (when headline (concat headline br)))))
  ;;        (descriptive
  ;;      (let* ((term term-counter-id))
  ;;        (setq term (or term "(no term)"))
  ;;        ;; Check-boxes in descriptive lists are associated to tag.
  ;;        (concat (format "<dt> %s </dt>"
  ;;                        (concat checkbox term))
  ;;                "<dd>"))))
  ;;      (unless (eq type 'descriptive) checkbox)
  ;;      contents
  ;;      (case type
  ;;        (ordered "</li>")
  ;;        (unordered "</li>")
  ;;        (descriptive "</dd>")))))

  ;; wl-message-id-domain "smtp.gmail.com")

  ;; (setq wl-from "Matt Price <matt.price@utoronto.ca>"

  ;;       ;;all system folders (draft, trash, spam, etc) are placed in the
  ;;       ;;[Gmail]-folder, except inbox. "%" means it's an IMAP-folder
  ;;       wl-default-folder "%inbox"
  ;;       wl-draft-folder   "%[Gmail]/Drafts"
  ;;       wl-trash-folder   "%[Gmail]/Trash"
  ;;       wl-fcc            "%[Gmail]/Sent"

  ;;       ;; mark sent messages as read (sent messages get sent back to you and
  ;;       ;; placed in the folder specified by wl-fcc)
  ;;       wl-fcc-force-as-read    t

  ;;       ;;for when auto-compleating foldernames
  ;;       wl-default-spec "%")

#+END_SRC
** Smallcaps
I actually have no need for smallcaps right now, but I had this code lying around so might as well save it.
*** Eric Schulte's filter for HTML small caps

# #+name: es-small-caps
# #+begin_src emacs-lisp
;;; "sc" links for the \sc{} latex command
(defun org-export-html-small-caps (string backend channel)
(when (org-export-derived-backend-p backend 'html)
(let ((rx "{\\\\sc ")
(fmt "<span style=\"font-variant:small-caps;\">%s</span>"))
(with-temp-buffer
(insert string)
(goto-char (point-min))
(while (re-search-forward rx nil t)
(let* ((start (match-beginning 0))
(end (progn (goto-char start)
(forward-sexp)
(point)))
(content (buffer-substring (+ start 5) (- end 1))))
(delete-region start end)
(goto-char start)
(insert (format fmt content))))
(buffer-string)))))

(add-to-list 'org-export-filter-final-output-functions
'org-export-html-small-caps)

(defun org-export-latex-sc (tree backend info)
"Handle sc: links for latex export."
(org-element-map tree 'link
(lambda (object)
(when (equal (org-element-property :type object) "sc")
(org-element-insert-before
(cond
((org-export-derived-backend-p backend 'latex)
(list 'latex-fragment
(list :value (format "{\\sc %s}"
(org-element-property :path object))
:post-blank (org-element-property
:post-blank object))))
((org-export-derived-backend-p backend 'html)
(list 'export-snippet
(list :back-end "html"
:value
(format "<span class=\"sc\">%s</span>"
(org-element-property :path object))
:post-blank
(org-element-property :post-blank object))))
(:otherwise
(error "unsupported backend for `org-export-latex-sc'")))
object)
(org-element-extract-element object))))
tree)

(org-add-link-type "sc")

(add-hook 'org-export-filter-parse-tree-functions
'org-export-latex-sc)

# #+end_src
* The Toggle Map 
Inspired by [[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org#hideshow][this beautiful literate config fro mmwfogeolman]]

Now using a hydra rather than a map so I don't forget stuff.  
#+begin_src emacs-lisp
    (defun narrow-or-widen-dwim (p)
      "If the buffer is narrowed, it widens. Otherwise, it narrows
        intelligently.  Intelligently means: region, org-src-block,
        org-subtree, or defun, whichever applies first.  Narrowing to
        org-src-block actually calls `org-edit-src-code'.

        With prefix P, don't widen, just narrow even if buffer is already
        narrowed."
      (interactive "P")
      (declare (interactive-only))
      (cond ((and (buffer-narrowed-p) (not p)) (widen))
            ((and (boundp 'org-src-mode) org-src-mode (not p))
             (org-edit-src-exit))
            ((region-active-p)
             (narrow-to-region (region-beginning) (region-end)))
            ((derived-mode-p 'org-mode)
             (cond ((ignore-errors (org-edit-src-code))
                    (delete-other-windows)
                    )
                   ((org-at-block-p)
                    (org-narrow-to-block))
                   (t (org-narrow-to-subtree))))
            ((derived-mode-p 'prog-mode) (narrow-to-defun))
            (t (error "Please select a region to narrow to"))))

  ;; this is a bit brilliant - -common error for me!        
    (eval-after-load 'org-src
      '(bind-key "C-x C-s" 'org-edit-src-exit org-src-mode-map))

    (use-package hideshow
      :hook ((prog-mode . hs-minor-mode)))

    (defun toggle-fold ()
      (interactive)
      (save-excursion
        (end-of-line)
        (hs-toggle-hiding)))
        (define-key emacs-lisp-mode-map (kbd "<C-tab>") 'toggle-fold )


    (defun read-write-toggle ()
      "Toggles read-only in any relevant mode: ag-mode, Dired, or
        just any file at all."
      (interactive)
      (if (equal major-mode 'ag-mode)
          ;; wgrep-ag can support ag-mode
          (wgrep-change-to-wgrep-mode)
        ;; dired-toggle-read-only has its own conditional:
        ;; if the mode is Dired, it will make the directory writable
        ;; if it is not, it will just toggle read only, as desired
        (dired-toggle-read-only)))

    (bind-keys :prefix-map toggle-map
               :prefix "C-x t"
               ("d" . toggle-debug-on-error)
               ("f" . toggle-fold)
               ("l" . linum-mode)
               ("n" . narrow-or-widen-dwim)
               ("o" . org-mode)
               ("r" . read-write-toggle)
               ("t" . text-mode)
                                            ;("w" . whitespace-mode)
               ("w" . toggle-windows-split)
               )

    ;; switchint to a hydra for clarity

    (global-set-key 
     (kbd "C-x t")
     (defhydra hydra-toggle (:color blue :columns 3)
       "
      toggle
      ------
      "
       ("d" toggle-debug-on-error "debug")
       ("f" toggle-fold "folding")
       ("l" linum-mode "line numbers")
       ("n" narrow-or-widen-dwim "narrowing")
       ("o" org-mode "org-mode (??)")
       ("r" read-write-toggle "read-write mode")
       ("t" text-mode "text mode (??)")
                                            ;("w" . whitespace-mode)
       ("w" toggle-windows-split "windows split")))
#+end_src


#+end_src

#+RESULTS:
: toggle-windows-split

* New Packages

** <2016-10-25 Tue>
I have justi nstalled a whole bunch of emacs packages, including:
- bog -- research note extensions to org-mode
- speed-type -- speed typing
- biblio -- lookup sources online (potentially helpful, maybe replace zotero a little bit)
- spacemacs theme
- org-beautify-theme, let's see how that looks
- impatient-mode -- live preview!!
- org-journal -- might use someday
**  iedit
OK mbork, [[http://mbork.pl/2016-02-20_Iedit_mode][I'm convinced]]. Giving this this a try. It looks pretty fabulous now that it appears to be set up right.
#+BEGIN_SRC emacs-lisp
(use-package iedit
:bind (("C-;" . iedit-mode)))

(use-package iedit
  :ensure t
  :commands (iedit-mode)
  :bind* (("M-m *" . iedit-mode) ("C-;" . iedit-mode))
)
#+END_SRC


** Dired-Ranger
TThis cool introdution to dired-ranger is really helpful: http://pragmaticemacs.com/emacs/copy-and-paste-files-with-dired-ranger/
#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
  :ensure t
  :bind (:map dired-mode-map
              ("W" . dired-ranger-copy)
              ("X" . dired-ranger-move)
              ("Y" . dired-ranger-paste)))

#+END_SRC

#+RESULTS:
** dired-subtree
allows use of subtrees in dired; cf: http://pragmaticemacs.com/emacs/tree-style-directory-views-in-dired-with-dired-subtree/

#+BEGIN_SRC emacs-lisp
  ;; (use-package dired-subtree
  ;;   :config
  ;;   (bind-keys :map dired-mode-map
  ;;              ("i" . dired-subtree-insert)
  ;;              (";" . dired-subtree-remove)))

#+END_SRC

#+RESULTS:
** Dired-Narrow and dired-filter
another cool dired hack
#+BEGIN_SRC emacs-lisp
;;narrow dired to match filter
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))

#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
  ;;narrow dired to match filter
  (use-package dired-filter
    :ensure t
  ;; :bind (:map dired-mode-map
  ;;               ("/" . dired-narrow))
    )

#+END_SRC

#+RESULTS:

** ACTION emojify-mode


I think this is deeply messing w/ ocmpnay mode, os I'm turning completion off for now, which is a huge bummer (!!)

<2018-10-28 Sun> turned back on for now but let's see!
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :config
    (add-hook 'after-init-hook #'global-emojify-mode)
    (add-hook 'markdown-mode-hook 'emojify-mode)
    (add-hook 'git-commit-mode-hook 'emojify-mode)
    )

  ;; (use-package company-emoji
  ;;   :ensure t
  ;;   :preface
  ;;   (defun mwp-dont-insert-unicode-emoji ()
  ;;     (make-local-variable 'company-emoji-insert-unicode)
  ;;     (setq company-emoji-insert-unicode nil))
  ;;   :after (emojify company)
  ;;   :hook
  ;;   (org-mode . mwp-dont-insert-unicode-emoji)
  ;;   (markdown-mode . mwp-dont-insert-unicode-emoji)
  ;;   (gfm-mode . mwp-dont-insert-unicode-emoji)
  ;;   (git-commit-mode . mwp-dont-insert-unicode-emoji)
  ;;   :config
  ;;   (add-to-list 'company-backends 'company-emoji))
#+END_SRC

#+RESULTS:
| mwp-dont-insert-unicode-emoji | emojify-mode |
#+RESULTS:
** editorconfig
trying to get htis to wrok with atom
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+END_SRC

#+RESULTS:
: t
** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind* ("M-p" . ace-window)
  ;; :init (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  )
#+END_SRC

#+RESULTS:
** DUmb Jump.
Thank you sacha chua for a link to hist discussion of dumb-jump

https://www.reddit.com/r/emacs/comments/7cawkm/after_a_week_i_must_begrudgingly_admit_vscode_is/

aso [[https://github.com/jacktasia/dumb-jump][here is the gh page]] with more instructions.
Doesn't seem to be working
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g i" . dumb-jump-go-prompt)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window))
    :config 
    ;; (setq dumb-jump-selector 'ivy) ;;
    (setq dumb-jump-selector 'helm)
    (setq dumb-jump-force-searcher 'ag)
    :ensure)
#+END_SRC

#+RESULTS:
** shell-pop
[[http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/][This Pragmatic Emacs post]] describes an easy way to pop up shells.  I modified the modifier a bit b/c I was accidentally popping up shells too often. 

To quickly acces a shell from a file: 
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :bind (("C-s-t" . shell-pop))
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/bin/zsh")
  ;; need to do this manually or not picked up by `shell-pop'
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC

#+RESULTS:
* magit and magithub
** manually set ghub

#+begin_src emacs-lisp
(use-package ghub
;; :load-path "~/src/ghub"
:ensure t
;; :pin manual
)
#+end_src

#+RESULTS:

** Initial setup
First setup auth sources for magithub

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc"))
#+end_src

#+RESULTS:
| ~/.authinfo.gpg | ~/.authinfo | ~/.netrc |


try to use dev version
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'package
        

        (unless t
          (dolist (magit-elpa-install-path (directory-files-recursively
                                          package-user-dir
                                          "\\`magit-[0-9.]+\\'"
                                          :include-directories))
            (setq load-path (delete magit-elpa-install-path load-path))
            ;; Also ensure that the associated path is removed from Info
            ;; search list.
            ))

        )
#+END_SRC

use magit, magithub
#+BEGIN_SRC emacs-lisp
(use-package magithub
  :after magit
  :ensure t
  ;; :config
  ;; (magithub-feature-autoinject
          ;;  '(completion status-checks-header commit-browse pull-request-merge))
  )

(use-package magit
  ;;:load-path "/home/matt/src/magit/lisp"
  ;;:pin manual
  :commands magit-status
  :ensure t
  :bind
  ("C-x g" . magit-status)
  :config
  (setq
   magit-diff-use-overlays nil
   magit-repolist-columns
   '(("Name" 25 magit-repolist-column-ident nil)
     ("Version" 25 magit-repolist-column-version nil)
     ("L<U" 3 magit-repolist-column-unpulled-from-upstream
      ((:right-align t)))
     ("L>U" 3 magit-repolist-column-unpushed-to-upstream
      ((:right-align t)))
     ("D" 4 magit-repolist-column-dirty nil)
     ("Path" 99 magit-repolist-column-path nil))
   magit-repository-directories '(("~/src/" . 2))
   git-commit-major-mode 'markdown-mode)
  )


(use-package magit-gitflow
  :after magit
  :hook
  (magit-mode . turn-on-magit-gitflow))
;; (require 'magit-gitflow)
;; (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
#+END_SRC

#+RESULTS:
| turn-on-magit-gitflow | forge-bug-reference-setup | magit-load-config-extensions | magit-xref-setup |

** Magit forge
#+begin_src emacs-lisp 
(use-package forge
;; :load-path "~/src/magit-forge/lisp"
:after magit
;; :ensure t
;;:pin manual
)
#+end_src

#+RESULTS:



* Old Customizations -- moving out of cusotmize

#+begin_src emacs-lisp :tangle no
'(highlight-changes-colors '("#d33682" "#6c71c4"))
 '(highlight-symbol-colors
   (--map
    (solarized-color-blend it "#002b36" 0.25)
    '("#b58900" "#2aa198" "#dc322f" "#6c71c4" "#859900" "#cb4b16" "#268bd2")))
 '(highlight-symbol-foreground-color "#93a1a1")
 '(highlight-tail-colors
   '(("#073642" . 0)
     ("#546E00" . 20)
     ("#00736F" . 30)
     ("#00629D" . 50)
     ("#7B6000" . 60)
     ("#8B2C02" . 70)
     ("#93115C" . 85)
     ("#073642" . 100)))
 '(hl-bg-colors
   '("#7B6000" "#8B2C02" "#990A1B" "#93115C" "#3F4D91" "#00629D" "#00736F" "#546E00"))
 '(hl-fg-colors
   '("#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36"))
 '(hl-paren-colors '("#2aa198" "#b58900" "#268bd2" "#6c71c4" "#859900"))
 '(httpd-port 8888)
 '(js-indent-level 2)
 '(linum-format " %5i ")
 
#+end_src

* Theme
Well, I tried spacemacs theme and so far I hate it for org!

#+BEGIN_SRC emacs-lisp
  ;; (defun enab-theme (theme) 
  ;;  (if current-t43m3 (disable-theme current-t43m3))
  ;;  (setq current-t43m3 theme) 
  ;;  (load-theme theme t)) 

  ;; (defadvice load-theme (before theme-dont-propagate activate)
  ;;  (mapcar #'disable-theme custom-enabled-themes))

#+END_SRC
 
I still don't know much about themes, about the difference between color-themes and custom-themes, and about how to unload them.  For now I am enabling themes by hand -- quite cumbersome! -- and setting color-theme-is-global to nil, so I can have frames that look different (one for org, one for code, one for mail).


Unsetting to avoid loading for now!

#+BEGIN_SRC 
(use-package color-theme)
;;(load-file "~/.emacs.d/themes/zenburn.el")
;;(setq color-theme-is-global nil)
(setq color-theme-is-cumulative nil)
;;(color-theme-initialize)
#+END_SRC

#+RESULTS:

Once the frames have loaded, I call ~(color-theme-initialize)~ and then ~color-theme-wheat~ in the mail frame, and ~color-theme-zenburn~ in the code frame. THh main org frame stays white for now (not perfect though).

The theme i'm using in mail, ~color-theme-wheat~, was giving me some trouble with the org-hide face that provides the indentation in org-mode.  With John Kitchin's help, I was able to fix this by adding a hook to ~focus-in-hook~:
#+BEGIN_SRC emacs-lisp
(defun set-org-hide ()
  (interactive)
  (face-spec-set 'org-hide `((((background light)) (:foreground ,(face-attribute 'default :background) ))
    (((background dark)) (:foreground  ,(face-attribute 'default :background)))))
  )

(add-hook 'focus-in-hook 'set-org-hide t)
#+END_SRC

#+RESULTS:
| set-org-hide |

Note the backtick in front of the long list, and the commas in face of ~(face-attribute...)~. wthout these the lists don't evaluate properly and this doesn't work. I would like to understand lisp well enough to know intuitively why this is.  

* Mail again
I've moved to using mu4e for most of my mail needs, and it works great. Still not great for reading or replying to html mail.  But in general, it's really great.
** Initial Setup
I have been really enjoying mu4e and it appears to have allowed me to finally switch my main mail activity & archiving from Thunderbird to Emacs. There are stilll a few pain points that I haven't figured out -- in particular, some HTML mails are just easier to read in Thunderbird, and I have not yet set up group aliases for e.g. my courses, etc., so to send those messages  I switch back to Thunderbird. But in general it's working great.  

This first bit of code loads mu4e and dependencies that might be needed later, establishes it as the default mail program, and sets some sane defaults. It also tells mu4e that we'll be using offlineimap to collect mail, and sendmail (in this case nullmailer) to send messages out. 

Switching to nullmailer has been really great.  Setup if pretty straightforward, and as it has its own queue it's much, much more responsive than Emacs's own sendmail programs. As a result, programmatically sending mail (e.g., when I send out grades) is much quicker and less error-prone.  
(require 'mu4e)
#+BEGIN_SRC emacs-lisp
  ;; I install mu4e from source/git; the arch package was difficult to
  ;; install, and now I find myself modifying the source code with some
  ;; frequency


  ;; In additoin to mu4e, I use org-mu4e and org-mime quite a bit, so
  ;; might as well load here.
  (use-package mu4e
    :load-path "~/src/mu/mu4e"
    :functions mu
    :commands (mu4e mu)
    :init
    ;; set mu4e as the default mail agent
    ;; NOT setting this led to quite a number of small frustrations
    (setq mail-user-agent 'mu4e-user-agent)

    ;; identify the maildir where mail is stored
    (setq mu4e-maildir "/home/matt/UofTMail/")
    ;; postponed message is put in the following draft file
    (setq message-auto-save-directory "~/UofTMail/drafts")

    ;; more default directories.  
    (setq mu4e-sent-folder   "/Sent")
    (setq mu4e-drafts-folder "/Drafts")
    (setq mu4e-trash-folder  "/Trash")
    (setq mu4e-refile-folder  "/Archives")
    (setq mu4e-use-fancy-chars t)
    (setq mu4e-compose-format-flowed t)
    ;; smtp mail setting; these are the same that `gnus' uses. I don't
    ;; realy need these anymore as I ave switched to nullmailer, but
    ;; useful to keep around in case my setup changes in future
    (setq
     smtpmail-default-smtp-server "smtp.utoronto.ca"
     smtpmail-smtp-server         "smtp.utoronto.ca"
     smtpmail-local-domain        "utoronto.ca")

    ;; nullmailer provides a /usr/bin/sendmail
    (setq message-send-mail-function 'message-send-mail-with-sendmail)
    (setq sendmail-program "/usr/bin/sendmail")

    ;; the maildirs you use frequently; access them with 'j' ('jump')
    (setq   mu4e-maildir-shortcuts
            '(("/inbox"       . ?i)
              ("/Archives"     . ?a)
              ("/Sent"        . ?s)))
    ;; use flyspell and abbrevs
    (add-hook 'mu4e-compose-mode-hook
              (lambda()
                (flyspell-mode 1)))

    ;; address options
    (setq mu4e-reply-to-address "matt.price@utoronto.ca"
          user-mail-address "matt.price@utoronto.ca"
          user-full-name  "Matt Price")
    (setq mu4e-compose-signature
          "")
    ;; from customize interface, moving here where they belong
    (setq mu4e-bookmarks
          '(("maildir:/inbox AND NOT (contact:notifications@github.com OR contact:noreply@github.com OR contact:builds@travis-ci.com OR contact:builds@travis-ci.org) AND NOT flag:trashed" "non-github msgs in Inbox" 105)
            ("maildir:/inbox AND (contact:notifications@github.com OR contact:noreply@github.com OR contact:builds@travis-ci.com OR contact:builds@travis-ci.org) AND NOT flag:trashed" "github msgs in Inbox" 103)
            ("maildir:/inbox AND (HIS395 OR NEW113 OR HIS455 OR RLG231 OR RLG239 OR \"hacking history\" OR \"digital history\") AND NOT flag:trashed" "Teaching msgs in inbox" 84)
            ("flag:unread AND maildir:/inbox AND NOT flag:trashed" "Unread in inbox" 117)
            ("maildir:/inbox AND date:today..now AND NOT flag:trashed" "Today's messages" 116)
            ("maildir:/inbox AND date:7d..now AND NOT flag:trashed" "Last 7 days" 119)
            ("mime:image/*" "Messages with images" 112)
            ("maildir:/inbox AND NOT flag:trashed" "the whole maildir, but not trash" 109))
          mu4e-headers-results-limit 700
          mu4e-update-interval 900
          mu4e-view-show-addresses t)

    (setq mu4e-user-mail-address-list '("matt.price@utoronto.ca" "moptop99@gmail.com"))
    :config
    (define-key mu4e-headers-mode-map (kbd "C-c c") 'org-mu4e-store-and-capture)
    (define-key mu4e-view-mode-map    (kbd "C-c c") 'org-mu4e-store-and-capture)
    (define-key mu4e-headers-mode-map "x" #'my-mu4e-mark-execute-all-no-confirm)  ;; turn off execution confirmation
    (define-key mu4e-view-mode-map "x" #'my-mu4e-mark-execute-all-no-confirm)  ;; turn off execution confirmation
    ;; (define-key mu4e-compose-mode-map (kbd "C-c o") 'mwp-add-mu-keys-to-org) ;; switch to org, also add a keybinding
    (define-key mu4e-compose-mode-map (kbd "C-c o") 'org-mu4e-compose-org-mode)  ;; activate org-mu4e-compose-org-mode

    ;; configure view actions
    (add-to-list 'mu4e-view-actions
                 '("ViewInBrowser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions
                 '("xwidget" . mu4e-action-view-with-xwidget) t)
    (add-to-list 'mu4e-marks
                 '(tag
                   :char       "g"
                   :prompt     "gtag"
                   :ask-target (lambda () (read-string "What tag do you want to add?"))
                   :action      (lambda (docid msg target)
                                  (mu4e-action-retag-message msg (concat "+" target)))))
    '(mu4e-bookmarks
      '(("maildir:/inbox AND NOT (contact:notifications@github.com OR contact:noreply@github.com OR contact:builds@travis-ci.com OR contact:builds@travis-ci.org) AND NOT flag:trashed" "non-github msgs in Inbox" 105)
        ("maildir:/inbox AND (contact:notifications@github.com OR
         contact:noreply@github.com OR contact:builds@travis-ci.com
         OR contact:builds@travis-ci.org) AND NOT
         flag:trashed" "github msgs in Inbox" 103)
        ("maildir:/inbox AND (HIS395 OR NEW113 OR HIS455 OR RLG231 OR RLG239 OR \"hacking history\" OR \"digital history\") AND NOT flag:trashed" "Teaching msgs in inbox" 84)
        ("flag:unread AND maildir:/inbox AND NOT flag:trashed" "Unread in inbox" 117)
        ("maildir:/inbox AND date:today..now AND NOT flag:trashed" "Today's messages" 116)
        ("maildir:/inbox AND date:7d..now AND NOT flag:trashed" "Last 7 days" 119)
        ("mime:image/*" "Messages with images" 112)
        ("maildir:/inbox AND NOT flag:trashed" "the whole maildir, but not trash" 109))) 
    '(mu4e-headers-results-limit 700)
    '(mu4e-update-interval 900)
    '(mu4e-view-show-addresses t)

    ;; (mu4e~headers-defun-mark-for tag)
    ( define-key mu4e-headers-mode-map (kbd "g") 'mu4e-headers-mark-for-tag)
    ;; this was a pain to set up but finally mu4e compose uses the lorg-mode abbrev table
    ;; whew!!!!
    (defun mwp-always-set-abbrev () 
      (interactive)
      (setq local-abbrev-table org-mode-abbrev-table))
    (add-hook 'mu4e-compose-mode-hook #'mwp-always-set-abbrev)
    )


  (use-package org-mu4e
    :after (org mu4e))

  (use-package mu4e-contrib
    :after (org mu4e)
    :config
    (setq mu4e-html2text-command 'mu4e-shr2text)
    (add-hook 'mu4e-view-mode-hook
              (lambda()
                ;; try to emulate some of the eww key-bindings
                (local-set-key (kbd "<tab>") 'shr-next-link)
                (local-set-key (kbd "<backtab>") 'shr-previous-link)))

    ;; the headers to show in the headers list -- a pair of a field
    ;; and its width, with `nil' meaning 'unlimited'
    ;; (better only use that for the last field.
    ;; These are the defaults:
    (setq mu4e-headers-fields
          '( (:human-date          .  25)    ;; alternatively, use :human-date
             (:flags         .   6)
             (:mailing-list         .   10)
             ;;(:attachments   .   6)
             (:from-or-to          .  22)
             (:subject       .  nil))) ;; alternatively, use :thread-subject

    ;; program to get mail; alternatives are 'fetchmail', 'getmail'
    ;; isync or your own shellscript. called when 'U' is pressed in
    ;; main view.

    ;; If you get your mail without an explicit command,
    ;; use "true" for the command (this is the default)
    (setq mu4e-get-mail-command "offlineimap")
    ;; (setq mu4e-get-mail-command "/usr/local/bin/mbsync -aq")
    ;; (setq mu4e-change-filenames-when-moving t) 
    ;; (setq mu4e-update-interval 300)
    ;; smtp mail setting
    ;; I don't think this is being used by nullmailer at all, so probably irrelefant for me.
    ;; (setq

    ;;  ;; if you need offline mode, set these -- and create the queue dir
    ;;  ;; with 'mu mkdir', i.e.. mu mkdir /home/user/Maildir/queue
    ;;  smtpmail-queue-mail  nil
    ;;  smtpmail-queue-dir  "/home/matt/UofTMail/queue/cur")

    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t)


    ;; split horizontally, which is how I like it
    ;; actually, switch to vertical (which is bizarrely called horizontal)
    ;; can't seem to get it to switch, so we'll see how it goes.
    (setq ;; mu4e-split-view 'horizontal
     mu4e-headers-visible-lines 15
     mu4e-headers-visible-columns 80)

    ;; view images inline
    ;; enable inline images
    (setq mu4e-view-show-images t)
    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
    (message "initial setup of mu4e accomplished")
    )  

  ;; when you want to use some external command for text->html
  ;; conversion, e.g. the 'html2text' program
  ;; (setq mu4e-html2text-command "html2text")
  ;; (require 'mu4e-contrib)
#+END_SRC

#+RESULTS:

** ACTION Setting modeline
By default, mu4e doesn't show the number of messgaes in the modeline. This fixes that. Taken from [[https://github.com/djcb/mu/issues/52][this bug report]]

I'm not sure this really works, but keeping it for now. 
#+BEGIN_SRC emacs-lisp
  (setq kzar/mu4e-activity-string "")
  (add-to-list 'global-mode-string '((:eval kzar/mu4e-activity-string)) t)
  (defun kzar/get-mu4e-incoming-count ()
    "Get the incoming message count."
    (let* ((query "flag:unread AND \(maildir:/INBOX or maildir:/INBOX.Eyeo\)")
           (command
            "echo -n $( mu find date:1w..now maildir:/INBOX flag:unread 2>/dev/null | wc -l )"

           ;; "GUILE_LOAD_PATH='/usr/local/share/guile/site/2.0' GUILE_AUTO_COMPILE=0 mu msgs-count --query='flag:unread AND maildir:/INBOX'"
            )


           )
      (string-trim (shell-command-to-string command))))
  (defun kzar/format-mu4e-mode-string (count)
    (concat "[" (if (string= count "0") "" count)
            (if (get-buffer "*mu4e-headers*" )
                (concat 
                 "|" 
                 (with-current-buffer "*mu4e-headers*"
                   (number-to-string (count-lines (point-min) (point-max)))))
              "")

            "]"))
  (defun kzar/update-mu4e-activity-string (&rest args)
    (interactive)
    (setq kzar/mu4e-activity-string
          (kzar/format-mu4e-mode-string (kzar/get-mu4e-incoming-count)))
    (force-mode-line-update))
  (add-hook 'mu4e-main-mode-hook #'kzar/update-mu4e-activity-string)
  (add-hook 'mu4e-view-mode-hook #'kzar/update-mu4e-activity-string)
  (add-hook 'mu4e-index-updated-hook #'kzar/update-mu4e-activity-string)
#+END_SRC

#+RESULTS:
: kzar/update-mu4e-activity-string

** Saving and sending attachments
Saving attachments is actually pretty easy in mu4e. I like the way that mu4e allows you to filter the default save location by attachment type.  I haven't done much with this now, but it's convenient to have images in a separate location from documents.

#+BEGIN_SRC emacs-lisp
  ;; extract attachments
  ;; consider doing some sorting, e.g.: http://www.djcbsoftware.nl/code/mu/mu4e/Attachments.html#Attachments
  (setq mu4e-attachment-dir  "~/Downloads")
  (setq mu4e-attachment-dir
        (lambda (fname mtype)
          (cond
           ;; jpgs go to ~/Pictures/FromEmails
           ((and fname (string-match "\\.jpg$" fname))  "~/Pictures/FromEmails")
           ;; ... other cases  ...
           (t "~/Downloads")))) ;; everything else
#+END_SRC
** Sending HTML mail  *NOT TANGLED*                                :ARCHIVE:
I keep these experimental functions around in case I want to get a look at what I learned while I was experimenting, but I don't use them anymore; that's why it's all commented out.  

#+BEGIN_SRC emacs-lisp :tangle no

  ;; (defun org-mime-org-buffer-htmlize ()
  ;;   "Create an email buffer containing the current org-mode file
  ;;        exported to html and encoded in both html and in org formats as
  ;;        mime alternatives."
  ;;   (interactive)
  ;;   (org-mime-send-buffer 'html)
  ;;   (message-goto-to))


  ;; (defun mu4e-compose-org-mail ()
  ;;   (interactive)
  ;;   (mu4e-compose-new)
  ;;   (org-mu4e-compose-org-mode))

  ;; (defun htmlize-and-send ()
  ;;   "When in an org-mu4e-compose-org-mode message, htmlize and send it."
  ;;   (interactive)
  ;;   (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
  ;;     (org-mime-htmlize)
  ;;     (org-mu4e-compose-org-mode)
  ;;     (mu4e-compose-mode)
  ;;     ;; (remove-hook 'post-command-hook 'org~mu4e-mime-switch-headers-or-body t)
  ;;     ;; (mu4e-compose-mode)
  ;;     ;; (remove-hook 'post-command-hook 'org~mu4e-mime-switch-headers-or-body t)
  ;;     ;; (org-mu4e-compose-org-mode)
  ;;     (message-send-and-exit)))

  ;; (defun mwp-htmlize-and-send ()
  ;;   "When in an org-mu4e-compose-org-mode message, htmlize and send it."
  ;;   (interactive)
  ;;   (message "calling htmlize-and-send")
  ;;   ;; 
  ;;   (org-mime-htmlize)
  ;;   (message "ḧtmlized succssfully")
  ;;   ;; (goto-char (point-min))
  ;;   (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
  ;;     (org-mu4e-compose-org-mode))	
  ;;   (message-send-and-exit)
  ;;   (message "message hopfully sent and saved"))

  ;; ;; let my fingers htmlize-and-send
  ;; (add-hook 'org-ctrl-c-ctrl-c-hook 'htmlize-and-send t)

  ;; ;; this hook allows me to compose in org mode by default
  ;; (add-hook 'mu4e-compose-post-hook
  ;;           (defun do-compose-stuff ()
  ;;             "My settings for message composition."
  ;;             (org-mu4e-compose-org-mode)))

#+END_SRC

** Sending HTML Mail with mu4e
:PROPERTIES:
:ID:       o2b:35128fcd-ad87-40fc-b0d1-fff959282787
:POST_DATE: [2016-11-18 Fri 22:19]
:END:

*Update <2018-10-23 Tue>* reminder that org-mu4e-compose-org-mode is toggled with ~C-c o~, so that's how all this stuff gets activated. Still not clear to me if it relaly works well, so we'll see how it goes. 


John Kitchin [[http://kitchingroup.cheme.cmu.edu/blog/2016/10/29/Sending-html-emails-from-org-mode-with-org-mime/][has a terrific post]] detailing some configuration/improvements to mu4e that make it easier to send html mail.  This original post is really great, but I ran into quite a bit of trouble following this advice. 

He uses a cool feature of mu4e,  ~org-mu4e-compose-org-mode~, which toggles the major mode of  the message buffer between org-mode (when you're in the message body) and mu4e-compose-mode (when you're in the headers area).  With a couple of custom functions, it's easy to convert the org text to html and send a mime-multipart email from Emacs, which is quite convenient.  If you add ~org-mu4e-compose-org-mode~ as a hook to ~mu4e-compose-mode~, you can compose in html by default, which is great.

Unfortunately, ~org-mu4e-compose-org-mode~ is *deprecated* on account of its instability, and while John doesn't have any problems with it, for me it was unworkable. It turns out that this "mode" isn't really a standard emacs mode at all -- instead, it's a sly workaround that trickily adds an internal function to the 'post-command-hook in the draft buffer and switches major modes based on position.  This is a neat hack, but since the function /invokes the major modes directly/, setting the function as a hook to  ~mu4e-compose-mode~ appears to lead to some funky, inadvertent looping effects. On my machine, for some reason, those effects send the underlying ~message-send~ function crazy, and instead of sending directly, I get this amazingly annoying question:

#+BEGIN_QUOTE
Already sent message via mail; resend? (y or n) y 
#+END_QUOTE

On its own, that is already annoying; but worse, the sent message doesn't get saved to my Sent folder. Instead, it's lost completely.  

Anyway, after fruitless hours of paying around with this, I realized that the problem could be fixed by adding a new hook to the mu4e compose functions (rather than to the compose /mode/).  I've [[https://github.com/djcb/mu/pull/952][submitted those changes as a pull request]] and hopefully they will be accepted; if not, though, feel free to navigate back to [[https://github.com/titaniumbones/mu/tree/org-mu4e-compose-stabilization][my branch]] and pull/install mu from there.  With those small changes, I now have frictionless html email working very quickly within emacs, using this small bit of code.  It is at least 90% stolen:

I'm getting rid of this to try to improve the function of org-mime.el in its newer form. Will have to come back to this!!

#+BEGIN_SRC emacs-lisp 
  ;; this is stolen from John but it didn't work for me until I
  ;; made those small changes to mu4e-compose.el
  ;; added a namespace prefix to avoid overlap.
  (defun mwp-htmlize-and-send ()
    "When in an org-mu4e-compose-org-mode message, htmlize and send it."
    (interactive)
    (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
      (org-mime-htmlize nil)
      (org-mu4e-compose-org-mode)
      (mu4e-compose-mode)
      (message-send-and-exit)))


  ;; This overloads the amazing C-c C-c commands in org-mode with one more function
  ;; namely the htmlize-and-send, above.
  (add-hook 'org-ctrl-c-ctrl-c-final-hook #'mwp-htmlize-and-send t)
  (remove-hook 'org-ctrl-c-ctrl-c-hook 'mwp-htmlize-and-send t)


  ;; Originally, I set the `mu4e-compose-mode-hook' here, but
  ;; this new hook works much, much better for me.


  ;; lightly modifies org-mime-org-buffer-htmlize to go to the to header
  ;; change this to an advice on the original fn to avoid confusion!
  ;; may no longer be necessary
  (advice-add 'org-mime-org-buffer-htmlize :after #'message-goto-go) 
  ;; (advice-remove 'org-mime-org-buffer-htmlize  'message-goto-go)

  ;; (defun org-mime-org-buffer-htmlize ()
  ;;   "Create an email buffer containing the current org-mode file
  ;;          exported to html and encoded in both html and in org formats as
  ;;          mime alternatives."
  ;;   (interactive)
  ;;   (org-mime-send-buffer 'html)
  ;;   (message-goto-to))

  ;; I probalby don't need this anymore since I've added the hook! doh!
  ;; (defun mu4e-compose-org-mail ()
  ;;   (interactive)
  ;;   (mu4e-compose-new)
  ;;   (org-mu4e-compose-org-mode))

  ;; maybe not a good idea to do this.  
  ;; (add-hook 'mu4e-compose-post-hook
  ;;           (defun do-compose-stuff ()
  ;;             "My settings for message composition."
  ;;             (org-mu4e-compose-org-mode)))

#+END_SRC

#+RESULTS:

It feels great to have gotten this far. There are still some small things I'd like to be able to improve; and I think I would like to add a few wrapper functions and keybindings to my setup, but for now I'm pretty efficient.  

Still missing:
- a better HTML viewing interface! right now, html mails render as mostly text -- it would be nice to have a rendered html message by default in emacs. This is an issue several times a day when I get promotional emails from organizations I work with -- usually the html part is really important. I can access these in the browser but it's comparatively awkward.
- a way to forward these html emails to someone intact -- right now, the html parts are discarded.  No idea how hard it would be to do this.  

*UPDATE <2016-11-30 Wed>:* 

- It's now possible to use xwidgets to view rendered html in emacs. It's cool for sure -- but still not easy to use, as of November, 2016.
- turns out that the FAQ contains some tips for forwarding HTML mail (as [[https://github.com/djcb/mu/issues/958][dcjb explained in my feature request issue]]:
  #+BEGIN_QUOTE
  How can I attach an existing message? Use
  ‘mu4e-action-capture-message’ (i.e., ‘a c’ in the headers view) to
  ’capture’ the to-be-attached message, then when editing the
  message, use ‘M-x mu4e-compose-attach-captured-message’.
  #+END_QUOTE
Thanks John and Dirk-Jan for these great tools!

** Using mu4e and org-mime together
:PROPERTIES:
:ID:       o2b:8cb2d321-2a5c-48a6-9aa1-52c70a9111e5
:POST_DATE: [2016-11-30 Wed 15:45]
:POSTID:   63
:BLOG:     matt
:END:
I use org-mime in my [[http://matt.hackinghistory.ca/2015/07/15/mailing-subtrees-with-attachments/][grading]] [[https://github.com/titaniumbones/Org-Marking-Mode][system]], to email my comments on student papers. One frustrating element has always been that messages sent by org-mime were never saved to my sent-mail folder.  I realized just recently that this was because I had failed to set emacs's mail-user-agent, which I now do in my initial mu4e setup:

~(setq mail-user-agent 'mu4e-user-agent)~

Now org-mime attempts to send messages using mu4e's internal compose functions. Unfortunately some of the information passed by org-mime is in a format that ~mu4e~compose-mail~ doesn't like, so I had to make some very slight changes to that function:
#+BEGIN_SRC diff :tangle no
diff --git a/mu4e/mu4e-compose.el b/mu4e/mu4e-compose.el
index a24e74a..0c7ec3c 100644
--- a/mu4e/mu4e-compose.el
+++ b/mu4e/mu4e-compose.el
@@ -780,7 +780,14 @@ draft message."
 
   ;; add any other headers specified
   (when other-headers
-    (message-add-header other-headers))
+    (dolist (h other-headers other-headers)
+      (if (symbolp (car h)) (setcar h (symbol-name (car h))))
+      (message-add-header (concat (capitalize (car h)) ": " (cdr h) "\n"  ))
+      )
+    ;; (dolist (h other-headers)
+    ;;  (message-add-header h) )
+    ;;(message-add-header other-headers)
+    )
 
   ;; yank message
   (if (bufferp yank-action)

#+END_SRC

The commit is in its [[https://github.com/titaniumbones/mu/tree/org-mu4e-compose-stabilization][my org-mu4e-compose branch, contianing a couple of other fixes]], and in [[https://github.com/titaniumbones/mu/tree/fix-other-headers][its own branch]] on github, if prefer to pull from there.  A patch has been submitted, we'll see what dcjb thinks of it.  

With these changes, org-mime now works perfectly for me.  

** Key Rebindings

I prefer these keys to the defaults, just because of muscle memory. ~C-c C-v~ is a little awkward for the "actions" menu, which I now use all the time, so I have reverted to the standard 'a' binding for actions, and am slowly unlearning "a" as a binding for "archive".  

#+BEGIN_SRC emacs-lisp
  (defun my-mu4e-main-mode-config ()
    "For use in `mu4e-main-mode-hook'."
    (local-set-key (kbd "m") 'mu4e-main-toggle-mail-sending-mode) ; add a key
    (local-set-key (kbd "f") 'smtpmail-send-queued-mail) ; add a key
    ;;(local-set-key (kbd "C-c C-p") nil) ; example of remove a key
    ;; more here
    )

  (defun my-mu4e-headers-mode-config ()
    "For use in 'mu4e-view-mode-hook'."
    ;; (local-set-key (kbd "a") 'mu4e-headers-mark-for-refile) ;; remap from "r"
    (local-set-key (kbd "f") 'mu4e-headers-mark-for-refile) ;; remap from "r"
    (local-set-key (kbd "r") 'mu4e-compose-reply) ;; add new keymapping, along with "R"
    (local-set-key (kbd "C-c C-v") 'mu4e-headers-action) ;; rebind from "a"
    )

  (defun my-mu4e-view-mode-config ()
    "For use in 'mu4e-view-mode-hook'."
    ;;(local-set-key (kbd "a") 'mu4e-view-mark-for-refile) ;; remap from "r"
    (local-set-key (kbd "f") 'mu4e-view-mark-for-refile) ;; remap from "r"
    (local-set-key (kbd "r") 'mu4e-compose-reply) ;; add new keymapping, along with "R"
    (local-set-key (kbd "C-c C-v") 'mu4e-view-action) ;; rebind from a
    (visual-line-mode)
   )


  ;; function to add a local key to the org-mode map!
  (defun mwp-add-mu-keys-to-org ()
    (interactive)
    (org-mode)
    (local-set-key (kbd "C-c o") 'mu4e-compose-mode))

  ;; add to hook
  (add-hook 'mu4e-main-mode-hook 'my-mu4e-main-mode-config)
  (add-hook 'mu4e-headers-mode-hook 'my-mu4e-headers-mode-config)
  (add-hook 'mu4e-view-mode-hook 'my-mu4e-view-mode-config)



        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Interactive functions

  (defun my-mu4e-mark-execute-all-no-confirm ()
    "Execute all marks without confirmation."
    (interactive)
    (mu4e-mark-execute-all 'no-confirm))

  ;; this seemed essential at first but now I'm not using the mstpmail queue
  (defun mu4e-main-toggle-mail-sending-mode ()
    "Toggle sending mail mode, either queued or direct."
    (interactive)
    (unless (file-directory-p smtpmail-queue-dir)
      (mu4e-error "`smtpmail-queue-dir' does not exist"))
    (setq smtpmail-queue-mail (not smtpmail-queue-mail))
    (message
     (concat "Outgoing mail will now be "
             (if smtpmail-queue-mail "queued" "sent directly")))
    (mu4e~main-view))

#+END_SRC

#+RESULTS:
: mu4e-main-toggle-mail-sending-mode


** Performance issues

Having some trouble here with 
#+begin_src text
+ redisplay_internal (C function)                               24784  50%
- command-execute                                               12780  25%
 - call-interactively                                           12780  25%
  + byte-code                                                   11543  23%
  - funcall-interactively                                        1237   2%
   + mu4e-headers-search-bookmark                                1194   2%
   + helm-M-x                                                      23   0%
   + file-notify-handle-event                                      19   0%
   + handle-focus-in                                                1   0%
- mu4e~proc-filter                                               7568  15%
 - mu4e~headers-header-handler                                   4399   8%
  + mu4e~message-header-description                              3938   7%
    mu4e-get-headers-buffer                                        32   0%
 + mu4e~fill-contacts                                             264   0%
 + mu4e-info-handler                                               66   0%
 + mu4e~headers-found-handler                                       4   0%
+ ...                                                            2594   5%
+ timer-event-handler                                            1664   3%
+ xselect-convert-to-string                                        21   0%
+ ac-handle-pre-command                                            10   0%
+ mu4e~update-sentinel-func                                         7   0%
+ winner-save-old-configurations                                    4   0%
  flycheck-error-list-highlight-errors                              2   0%
+ sp--save-pre-command-state                                        1   0%

#+end_src
** Improving contact completion
There's a lot of stuff out there for this. I'm trying this method stolen from 
https://groups.google.com/forum/#!topic/mu-discuss/kzUlflMY9Zg

#+BEGIN_SRC emacs-lisp
  (setq mwp/contact-blacklist-file "/home/matt/.mu/contact-blacklist")
  (defun mwp/read-contact-blacklist ()
     "Return a list of blacklisted email addresses"
     (with-temp-buffer
       (insert-file-contents mwp/contact-blacklist-file)
       (split-string (buffer-string) "\n" t)))

   (defun mwp/make-contact-blacklist-regexp ()
     "Combine listed addresses into a regexp"
     (mapconcat 'identity (mwp/read-contact-blacklist) "\\|"))

   (setq mu4e-compose-complete-ignore-address-regexp (mwp/make-contact-blacklist-regexp)) 
#+END_SRC

#+RESULTS:
: member@surveymonkey.com\|do-not-reply@\|do-not-reply@blackboard.com\|exa...@exmaple.org\|example@example.or\|ekprice@jps.net\|omaopaprice@gmail.com\|commenting@dropboxmail.com\|mich.murphy@utoronto.ca\|murphyofglad@gmail.com\|murphycmichelle@gmail.com\|michelle.murphy.edgi@gmail.com\|-owner@\|-request@\|-subscribe@\|bureau21.ns.utoronto.ca\|frances.garret@utoronto.ca\|frances.garrett@gmail.com\|francesmgarrett@gmail.com\|dcwalk@gmail.com

** adding tags

I wanted to tag some messages so I don't lose them

see here: 

https://www.djcbsoftware.nl/code/mu/mu4e/Adding-a-new-kind-of-mark.html

This code has been moved to use-package, above
#+BEGIN_SRC emacs-lisp
#+END_SRC


** Convenience function ~mu~ 
just a quick defun to make it quicker to open mu4e headers if they're already open
#+BEGIN_SRC emacs-lisp
  (defun mu ()
    "open the mu-headers buffer if it exists, otherwise start mu4e"
    (interactive)
    (if (get-buffer "*mu4e-headers*")
        (switch-to-buffer "*mu4e-headers*")
      (mu4e)))
#+END_SRC
** Orgalist
It's infuriating not to be able to make lists in mails! Here's a very simple improvement:
#+begin_src emacs-lisp
 (add-hook 'mail-mode-hook #'orgalist-mode)
 (add-hook 'message-mode-hook #'orgalist-mode)
#+end_src

#+RESULTS:
| orgalist-mode | beginend-message-mode | (lambda nil (local-set-key \357 'org-mime-htmlize)) |
** helm mu
I just discovered [[https://github.com/emacs-helm/helm-mu][helm mu]] via [[https://www.reddit.com/r/emacs/comments/9ozezm/regale_me_with_your_mu4e_tips_tricks/#t1_e7xvik1][this reddit comment]] which Sacha Chua referenced in a weekly update, thank you Sacha!  Just trying out for now but it looks cool.

Some things I learned:

- in helm, ~C-z~ *always* brings up a list of actions!  cool!
- also in halm, ~"C-Spc"~ *always* allows multiple selection!!
- ~helm-mu-contacts~ has 4 completion actoins:
  - [F1]: create email
  - [F2]: search through the emails from this contact (!!)
  - [F3]: insert into buffer
  - [F4]: copy email to clipboard 
#+begin_src emacs-lisp
  (use-package helm-mu
  :after (mu4e helm)
  ;; some recommended config vars
  :config
  (setq helm-mu-default-search-string "(maildir:/INBOX OR maildir:/Sent)")
  (setq helm-mu-contacts-after "01-Jan-1995 00:00:00")
  ;; (setq helm-mu-contacts-personal t)
  ;; :bind
  ;; (:map mu 'mu4e-main-mode-map 
  ;; ("s" . 'helm-mu))
  ;; (:map mu 'mu4e-headers-mode-map 
  ;; ("s" . 'helm-mu))
  ;; (:map mu 'mu4e-view-mode-map 
  ;; ("s" . 'helm-mu))
  )
#+end_src

#+RESULTS:
: t

* Youtube
#+BEGIN_SRC emacs-lisp
  (defvar yt-iframe-format
    ;; You may want to change your width and height.
    (concat "<iframe width=\"440\""
            " height=\"335\""
            " src=\"https://www.youtube.com/embed/%s\""
            " frameborder=\"0\""
            " allowfullscreen>%s</iframe>"))

  (org-add-link-type
   "yt"
   (lambda (handle)
     (browse-url
      (concat "https://www.youtube.com/embed/"
              handle)))
   (lambda (path desc backend)
     (cl-case backend
       (html (format yt-iframe-format
                     path (or desc "")))
       (latex (format "\href{%s}{%s}"
                      path (or desc "video"))))))
#+END_SRC
* Miscellanea 
** Reference
Write a quick function to switch to the Refernce.org password safe buffer
#+BEGIN_SRC emacs-lisp
  (defun reference ()
      "open up the refernce doc!"
    (interactive)
    (find-file "~/GTD/Reference.org"))
#+END_SRC

#+RESULTS:
: reference

** keep
Write a quick function to switch to the keep-it-safe password safe buffer
#+BEGIN_SRC emacs-lisp
  (defun keep-it-safe ()
      "open up the password safe!"
    (interactive)
    (find-file "~/GTD/Keep-it-safe.org.gpg"))
#+END_SRC

** Shell
Shell can be pretty annoying w C-z binding.  Trying to simplofy:

#+begin_src emacs-lisp
(global-set-key (kbd "C-z") 'shell)
(defun mwp-exit-shell ()
(interactive)
  (comint-delchar-or-maybe-eof 0)
  (sit-for 1)
  (jcs-kill-a-buffer nil))
(define-key shell-mode-map (kbd "C-d") 'mwp-exit-shell)
(define-key shell-mode-map (kbd "C-x k") 'mwp-exit-shell)


#+end_src

#+RESULTS:
: mwp-exit-shell

* customizations
Need to use them for now! uh-oh...
FInally, let's only load customizations right at the end
#+BEGIN_SRC emacs-lisp


  ;; Keep emacs Custom-settings in separate file
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
   (load "/home/matt/.emacs.d/custom.el")
#+END_SRC

#+RESULTS:
: t

* shift select
turned off in ~better-defaults.el~, but let's turn back on now
#+begin_src emacs-lisp
(setq shift-select-mode t)
(setq org-support-shift-select t)
#+end_src

#+RESULTS:
: t

* polymode
just trying out polymode: 
https://polymode.github.io/installation/

Not clear that it makes sense to use in org mode yet, though that would be the obvious next step.  
#+begin_src emacs-lisp
(use-package poly-markdown
  :ensure t)
#+end_src

#+RESULTS:

* fix freaking yas-global-mode
#+begin_src emacs-lisp
(yas-global-mode -1)
#+end_src

#+RESULTS:
 fkjdsla fkjdlsa 
* Miscellaneous elisp/emacs ocnvenience

** Improve ynking space handling
See Marcel's interesting blog post about it [[http://mbork.pl/2018-07-02_Smart_yanking][here]]
#+begin_src emacs-lisp 
(defun has-space-at-boundary-p (string)
  "Check whether STRING has any whitespace on the boundary.
Return 'left, 'right, 'both or nil."
  (let ((result nil))
    (when (string-match-p "^[[:space:]]+" string)
      (setq result 'left))
    (when (string-match-p "[[:space:]]+$" string)
      (if (eq result 'left)
	  (setq result 'both)
	(setq result 'right)))
    result))

(defun is-there-space-around-point-p ()
  "Check whether there is whitespace around point.
Return 'left, 'right, 'both or nil."
  (let ((result nil))
    (when (< (save-excursion
               (skip-chars-backward "[:space:]"))
             0)
      (setq result 'left))
    (when (> (save-excursion
               (skip-chars-forward "[:space:]"))
             0)
      (if (eq result 'left)
	  (setq result 'both)
	(setq result 'right)))
    result))

(defun set-point-before-yanking (string)
  "Put point in the appropriate place before yanking STRING."
  (let ((space-in-yanked-string (has-space-at-boundary-p string))
	(space-at-point (is-there-space-around-point-p)))
    (cond ((and (eq space-in-yanked-string 'left)
		(eq space-at-point 'left))
	   (skip-chars-backward "[:space:]"))
	  ((and (eq space-in-yanked-string 'right)
		(eq space-at-point 'right))
	   (skip-chars-forward "[:space:]")))))

(defun set-point-before-yanking-if-in-text-mode (string)
  "Invoke `set-point-before-yanking' in text modes."
  (when (derived-mode-p 'text-mode)
    (set-point-before-yanking string)))

(advice-add
 'insert-for-yank
 :before
 #'set-point-before-yanking-if-in-text-mode)

#+end_src

#+RESULTS:

** Tiny space handling trick
#+begin_src emacs-lisp
(defun ap/cycle-spacing ()
  (interactive)
  (cycle-spacing -1))
(bind-key (kbd "<C-M-backspace>") 'ap/cycle-spacing)
#+end_src

#+RESULTS:
: ap/cycle-spacing

** Cask
just getting used to this

Maybe having some trouble so... commenting back out.  
#+begin_src emacs-lisp :tangle no
;; (require 'cask "~/.cask/cask.el")
  ;;   (cask-initialize)
  ;;   (push (format "/home/%s/.cask/bin/" (user-login-name)) exec-path)
  ;; ;; elsa unfortunately notworking...
  ;; ;   (remove-hook 'emacs-lisp-mode-hook #'flycheck-elsa-setup)

#+end_src

#+RESULTS:
| enable-paredit-mode |

* Desktop and customization
My computer used to crash VERY often. Session saving was essential, and becase of the frequent restarts, it's nice to shave some time off of the process. So, first we start session management with ~(require 'desktop)~, set some variables, and then use a function stolen from [[https://www.emacswiki.org/emacs?action=browse;oldid=DeskTop;id=Desktop#toc4][Emacswiki]] and override the stale lockfile from the crashed process. 
#+BEGIN_SRC emacs-lisp
;; check to see if the owner of the current desktop is still alive
(defun emacs-process-p (pid)
  "If pid is the process ID of an emacs process, return t, else nil.
Also returns nil if pid is nil."
  (when pid
    (let ((attributes (process-attributes pid)) (cmd))
      (dolist (attr attributes)
        (if (string= "comm" (car attr))
            (setq cmd (cdr attr))))
      (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

;; advise desktop: if the pid in lockfile is no longer alive, don't require confirmation to steal desktop file
(defadvice desktop-owner (after pry-from-cold-dead-hands activate)
  "Don't allow dead emacsen to own the desktop file."
  (when (not (emacs-process-p ad-return-value))
    (setq ad-return-value nil)))

;;; session management with desktop
(require 'desktop)
;; (setq desktop-dirname "/home/matt/.emacs.d/desktop-sessions/")
(desktop-save-mode 1)
(message "just before recover-session")
(setq auto-save-list-file-prefix "~/.emacs.d/auto-save-list/.saves-")

(defun recover-session ()
  "Recover auto save files from a previous Emacs session.
This command first displays a Dired buffer showing you the
previous sessions that you could recover from.
To choose one, move point to the proper line and then type C-c C-c.
Then you'll be asked about a number of files to recover."
  (interactive)
  (if (null auto-save-list-file-prefix)
      (error "You set `auto-save-list-file-prefix' to disable making session files"))
  (let ((dir (file-name-directory auto-save-list-file-prefix))
        (nd (file-name-nondirectory auto-save-list-file-prefix)))
    (unless (file-directory-p dir)
      (make-directory dir t))
    (unless (directory-files dir nil
                             (if (string= "" nd)
                                 directory-files-no-dot-files-regexp
                               (concat "\\`" (regexp-quote nd)))
			     t)
      (error "No previous sessions to recover")))
  (let ((ls-lisp-support-shell-wildcards t))
    (dired (file-name-directory  auto-save-list-file-prefix)
	   (concat dired-listing-switches " -t")))
  (use-local-map (nconc (make-sparse-keymap) (current-local-map)))
  (define-key (current-local-map) "\C-c\C-c" 'recover-session-finish)
  (save-excursion
    (goto-char (point-min))
    (or (looking-at " Move to the session you want to recover,")
	(let ((inhibit-read-only t))
	  ;; Each line starts with a space
	  ;; so that Font Lock mode won't highlight the first character.
	  (insert " To recover a session, move to it and type C-c C-c.\n"
		  (substitute-command-keys
		   " To delete a session file, type \
\\[dired-flag-file-deletion] on its line to flag
 the file for deletion, then \\[dired-do-flagged-delete] to \
delete flagged files.\n\n"))))))

(recover-session)
;; 
#+END_SRC

#+RESULTS:
: recover-session


* old value of 'after-init-hook
#+begin_verse
#[0 "\303\211\235\203 \304\"\301\305!\210\210	\205 \306 \210\307\211\207" [command-line-args desktop-save-mode inhibit-startup-screen "--no-desktop" delete 0 desktop-read t] 4]
#+end_verse
* minimal config for testing issues
I often need to be able to start with =emacs -Q=; but it's a real pain to do then begin the initialization process there.  So here's what I have as a testing file for now:

#+begin_src emacs-lisp :tangle ~/.emacs.d/minimal.el
  (let* ((all-paths
          '("/home/matt/src/org-mode/emacs/site-lisp/org"
          ;; "/home/matt/src/org-mime"
          ;; "/home/matt/.emacs.d/elpa/htmlize-20180923.1829/"
          "/home/matt/.emacs.d/elpa/org-mime-20180927.1150/"
          )))
    (dolist (p all-paths)
      (add-to-list 'load-path p)))

  (require 'org)
  (require 'ox-md)
  
  (find-file "~/test.org")
(org-export-as 'md)
  ;; (require 'org-mime)
  ;; (setq org-mime-debug t)
  ;; (find-file "~/.emacs.d/minimal.el")
  ;; (find-file "~/Reference.org")
  ;; (goto-char 600)
  ;; (org-mime-org-subtree-htmlize)
#+end_src

Now run emacs:
#+begin_src sh
emacs -Q -l ~/.emacs.d/minimal.el &
#+end_src

#+RESULTS:
